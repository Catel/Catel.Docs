<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>XAML on Catel docs</title>
    <link>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/</link>
    <description>Recent content in XAML on Catel docs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Customizing DataContext subscription behavior</title>
      <link>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/customizing-datacontext-subscription-behavior/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/customizing-datacontext-subscription-behavior/</guid>
      <description>Starting with Catel 4.0, the views watch both the direct and inherited DataContext. Starting with Catel 4.1, it is possible to mimick the pre 4.0 DataContext subscription behavior.
Customizing the behavior for all views To mimick pre Catel 4.0, use the following code:
var dependencyResolver = this.GetDependencyResolver(); var dataContextSubscriptionService = dependencyResolver.Resolve&amp;lt;IDataContextSubscriptionService&amp;gt;(); dataContextSubscriptionService.DefaultDataContextSubscriptionMode = DataContextSubscriptionMode.DirectDataContext;  Customizing the behavior per view It is also customize the behavior per view. This allows very customized fine tuning of the behavior.</description>
    </item>
    
    <item>
      <title>Improving performance by defining the view model grid manually</title>
      <link>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/improving-performance-by-defining-view-model-grid-manually/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/improving-performance-by-defining-view-model-grid-manually/</guid>
      <description>Catel wraps the content of each user control in a grid. This grid is the actual view model container as can be read in the advanced documentation. This wrapper is very convenient, but does have (little) impact on the performance and visual state management. To prevent Catel to wrap the control for you, there are a few things you can do.
Creating the grid manually The easiest way is to create the grid manually.</description>
    </item>
    
    <item>
      <title>UserControl</title>
      <link>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/usercontrol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/usercontrol/</guid>
      <description>The UserControl is a very interesting class of Catel, and fully shows the power of the MVVM Framework that ships with Catel. The user control is able to fully integrate MVVM on a user control level and solves the “nested user control” problem, which is explained in detail a bit further in this documentation.
Automatic construction without parameter It simplest thing to do is to create a view model that has an empty constructor (thus without parameters).</description>
    </item>
    
    <item>
      <title>UserControl Resources</title>
      <link>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/usercontrol-resources/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/usercontrol-resources/</guid>
      <description>For the most part the resources declared within a Catel UserControl behave the exact same as resources defined in the standard UserControl. However because of the way the Catel UserControl operates (see UserControl Under the hood) any bindings performed inside a Resource will not be found at runtime (example CollectionViewSource Source) . The solution is to declare the resource inside an element within the UserControl, not at the UserControl level. Example below:</description>
    </item>
    
    <item>
      <title>Validation controls</title>
      <link>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/validation-controls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/validation-controls/</guid>
      <description>There are some very important controls in Catel which help with visualizing the validation results.
InfoBarMessageControl Ever wanted to show the details of error messages to your end-users? Then, the InfoBarMessageControl is the control to use! The control shows a summary of all business and field errors provided by bindings on objects that implement the IDataErrorInfo interface.
In combination with the WarningAndErrorValidator control, the InfoBarMessageControl can even show field and business warnings for objects that implement the IDataWarningInfo interface that ships with Catel.</description>
    </item>
    
    <item>
      <title>Window and DataWindow</title>
      <link>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/window-and-datawindow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://docs.catelproject.com/5.2/catel-mvvm/views/xaml/window-and-datawindow/</guid>
      <description>Introduction to the Window The Window is a simplified class representing the same logic as the regular System.Windows.Window but with the binding support of Catel.
Introduction to the DataWindow When developing software in XAML, most developers always need the following three types of windows:
 OK / Cancel buttons for data windows; OK / Cancel / Apply buttons for application settings / options; Close button on windows for action windows.</description>
    </item>
    
  </channel>
</rss>