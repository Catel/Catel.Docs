[{"uri":"https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-wpf/","title":"Caveats in WPF","tags":[],"description":"","content":"Below are all caveats in WPF.\nKnow caveats? Feel free to add them!\n"},{"uri":"https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-project/","title":"Creating the WPF project","tags":[],"description":"","content":" In this step we will create the project and add the relevant NuGet packages.\nThis guide uses the on-line templates that are available in the Visual Studio gallery. If you can't find the templates on-line, please download them [here](http://www.catelproject.com/download/general-files/).  Creating the project To create the project, start Visual Studio and choose File =\u0026gt; New Project\u0026hellip; Then switch to the on-line template section as you can see in the screenshot below and search for Catel:\nPick a good name, in our case WPF.GettingStarted and click OK. The template will now be downloaded and the project will be created.\nAdding the NuGet packages As soon as the project is created, the Readme.txt will be opened and instruct your what to do. Right-click on the solution =\u0026gt; *Manage NuGet packages\u0026hellip; *Then search for Catel.MVVM and click Install.\nRunning the project Now the NuGet packages are installed, the project is created and can be built. The basics are created and the application is ready:\nExplanation of the project structure The project template creates the project structure that fits best with Catel. Below is an explanation of the new project structure:\nThe ViewModels folder contains the MainWindowViewModel, which contains the logic for the interaction with the MainWindow view.\nThe Views folder contains the MainWindow, which represents the actual view.\nThis structure ties to how Catel implements viewmodel location. You do not however have to follow this structure and could for example decide to place both the View and ViewModel under the same namespace/folder and implement a custom IViewModelLocator.\nUp next Creating the models\n"},{"uri":"https://docs.catelproject.com/vnext/getting-started/xamarin-forms/creating-the-project/","title":"Creating the Xamarin.Forms project","tags":[],"description":"","content":"In this step we will create the project and add the relevant NuGet packages.\nThis documentation is work in progress\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/customizing-serialization-engines/","title":"Customizing the serialization engines","tags":[],"description":"","content":"Since the SerializerBase does all the heavy lifting, it is very easy to customize the behavior of an existing serializer or create a completely new one. Each serializer implements its own interface and are registered in the *ServiceLocator *using the following interfaces:\n XmlSerializer =\u0026gt; IXmlSerializer BinarySerializer =\u0026gt; IBinarySerializer  To customize a serializer, derive from an existing class and customize a method. The serializer below makes sure that specific members are never serialized. It keeps all other serialization logic intact.\npublic class SafeXmlSerializer : XmlSerializer { protected override bool ShouldIgnoreMember(ModelBase model, PropertyData property) { if (model is SecurityModel) { if (string.Equals(property.Name, \u0026quot;Password\u0026quot;)) { return true; } } return base.ShouldIgnoreProperty(model, property); } }  The only thing to do now is to register this custom instance in the ServiceLocator:\nServiceLocator.Default.RegisterType\u0026lt;IXmlSerializer, SafeXmlSerializer\u0026gt;();  The following methods on the serializer classes might be of interest when customizing the serialization:\n ShouldIgnoreProperty\n BeforeSerialization\n BeforeSerializeProperty\n AfterSerializeProperty\n AfterSerialization\n BeforeDeserialization\n BeforeDeserializeProperty\n AfterDeserializeProperty\n AfterDeserialization\n  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/dependency-injection/","title":"Dependency injection","tags":[],"description":"","content":" The ServiceLocator in Catel supports dependency injection.\nIntroduction to dependency injection Some people make dependency injection hard to understand, or maybe they don\u0026rsquo;t understand it themselves. Dependency injection simply means that instead of hard referencing or instantiating other classes (dependendies), the dependencies are injected into the class via the constructor.\nExample 1: bad, instantiates the dependencies itself\npublic class MyClass { private IFirstDependency _firstDependency; private ISecondDependency _secondDependency; public MyClass() { _firstDependency = new FirstDependency(); _secondDependency = new SecondDependency(); } }  Example 2: good, retrieves the dependencies via the service locator\npublic class MyClass { private IFirstDependency _firstDependency; private ISecondDependency _secondDependency; public MyClass() { _firstDependency = ServiceLocator.Instance.ResolveType\u0026lt;IFirstDependency\u0026gt;(); _secondDependency = ServiceLocator.Instance.ResolveType\u0026lt;ISecondDependency\u0026gt;(); } }   Example 3: good, gets the dependencies injected\npublic class MyClass { private IFirstDependency _firstDependency; private ISecondDependency _secondDependency; public MyClass(IFirstDependency firstDependency, ISecondDependency secondDepdenceny) { Argument.IsNotNull(\u0026quot;firstDependency\u0026quot;, firstDependency); Argument.IsNotNull(\u0026quot;secondDependency\u0026quot;, secondDependency); _firstDependency = firstDependency; _secondDependency = secondDependency; } }  There are other ways of using dependency injection, for example via attributes. This documentation will focus on dependency injection via the constructor only  Using dependency injection in Catel Constructor injection Dependency injection via the ServiceLocator in Catel is enabled by default. This means that when a type is resolved from the container, it will automatically use dependency injection to construct the type if it is not registered as instance.\nIt will first search for all available constructors on the type that will be instantiated. Then, for each constructor, starting with the one with the most parameters, it will try to retrieve all values. If one fails, it will go to the next. If all fail, it will try to use the default constructor without parameters. If that fails as well, then the type cannot be constructed and an exception will be thrown.\nTo get a better understanding of what happens, see the class below:\npublic class MyClass { private IFirstDependency _firstDependency; private ISecondDependency _secondDependency; public MyClass() : this(null) { } public MyClass(IFirstDependency firstDependency) : this(firstDependency, null) { } public MyClass(IFirstDependency firstDependency, ISecondDependency secondDependency) { _firstDependency = firstDependency; _secondDependency = secondDependency; } }  When the MyClass will be retrieved from the ServiceLocator, this will happen:\n Find constructor with most parameters (the one with both firstDependency and secondDependency). If both IFirstDependency and ISecondDependency can be resolved from the ServiceLocator, the type will be constructed with the constructor. Otherwise it will proceed with step 2. Find next constructor with most parameters (the one with only firstDependency). If IFirstDependency can be resolved from the ServiceLocator, the type will be constructed with the constructor. Otherwise it will proceed with step 3. At this point, no constructor could be used. In this case, the ServiceLocator will try to use the default constructor (the one without parameters) as last resort to instantiate the type.  Manually defining the constructor to use for dependency injection Catel first sorts the constructors based on the number of parameters. Then it will \u0026ldquo;sub-sort\u0026rdquo; the same number of parameters and puts parameters with Object and DynamicObject as last so it will first try all constructors with the best possible matches\nIf Catel is still unable to pick the right constructor in a class, this behavior can be overridden by decorating the constructor with the DependencyInjectionConstructor attribute:\npublic MyClass(IPerson person) { } [InjectionConstructor] public MyClass(Person person) { // Catel will now first try to use this constructor, no matter the order or number of parameters }  Advanced dependency injection Starting with Catel 3.7, a new type of dependency injection is supported. It allows a developer to instantiate types that combine custom constructor injection with dependency injection. The class belows shows an interesting combination of custom values that need to be injected and dependencies that can be retrieved from the IoC container. Before Catel 3.7, one had to manually retrieve the dependencies from the IoC container when it also required other dependencies to be injected that were not registered in the IoC container:\npublic class PersonViewModel : ViewModelBase { private readonly IMessageService _messageService; private readonly IProcessService _processService; public PersonViewModel(IPerson person) { Argument.IsNotNull(() =\u0026gt; person); Person = person; _messageService = ServiceLocator.Default.ResolveType\u0026lt;IMessageService\u0026gt;(); _processService = ServiceLocator.Default.ResolveType\u0026lt;IProcessService\u0026gt;(); } ... }  With the new technology, such a constructor can be rewritten to truly support dependency injection:\npublic class PersonViewModel : ViewModelBase { private readonly IMessageService _messageService; private readonly IProcessService _processService; public PersonViewModel(IPerson person, IMessageService messageService, IProcessService processService) { Argument.IsNotNull(() =\u0026gt; person); Argument.IsNotNull(() =\u0026gt; messageService); Argument.IsNotNull(() =\u0026gt; processService); Person = person; _messageService = messageService; _processService = processService } ... }  This feature is initially written to support dependency injection in combination with [nested user controls](Introduction_to_the_nested_user_controls_problem)  The advanced dependency injection can be used by using the TypeFactory class. Below is an example on how to create a new type using advanced dependency injection:\nvar personViewModel = TypeFactory.Default.CreateInstanceWithParametersAndAutoCompletion\u0026lt;PersonViewModel\u0026gt;(new Person());  As you can see it is only required to pass in the objects that are not registered in the IoC container. All other dependencies will be automatically resolved from the ServiceLocator.\nNote that the order of the parameters must be the same as the constructor, otherwise the *TypeFactory* cannot determine the right constructor to use  Property injection Starting with Catel 3.8, it is also possible to use property injection. The difference with constructor injection is that the TypeFactory will automatically set up all properties that required dependency injection.\nNote that the Catel team recommends using constructor injection over property injection. Property injection looks like a silver bullet, but is very tricky because: 1) It does not allow you to check for *null* values and store dependencies in private fields (when)? 2) Dependency Injection is just a technique. When using a constructor, you can force a user to provide the value and check the input. With property injection, you can only *hope* that the user will set them for you, there is no way to check this (unless that is some *after constructor and dependency injection* initialization routine. This is never the case if a user manually creates a type though.  To use property injection, simply decorate the properties of a class with the Inject attribute. Below are several options:\nType is automatically determined based on property type public class MyClass { [Inject] public IMyDependency MyDependency { get; set; } }  Type is manually defined public class MyClass { [Inject(typeof(IMySubclassedDependency))] public IMyDependency MyDependency { get; set; } }  Using tags It is also possible to determine the tag of a registered dependency:\npublic class MyClass { [Inject(Tag = \u0026quot;myTag\u0026quot;)] public IMyDependency MyDependency { get; set; } }  Disabling dependency injection  Maybe you don\u0026rsquo;t want dependency injection because it does not give you what you need or you want a very, very small improvement in performance. In that case, the dependency injection can be disabled using the code below:\nServiceLocator.Default.SupportedDependencyInjection = false  "},{"uri":"https://docs.catelproject.com/vnext/introduction/mvvm/different-interpretations-of-mvvm/","title":"Different interpretations of MVVM","tags":[],"description":"","content":" There are two different interpretations of MVVM, the \u0026ldquo;purist\u0026rdquo; way where the model is protected, or the \u0026ldquo;shortcut\u0026rdquo; way where the view model only provides the instance of the model and the view then binds directly to the model.\nShortcut interpretation This is what most people do. The view model implements the model, and then provides the model to the view. The view then binds directly to the model.\n Advantages\n Easy to use Fast since view model hardly contains any properties  Disadvantages\n Always need to bind to Model.[PropertyName], but for view model properties it\u0026rsquo;s just [PropertyName], might be confusing Less control over validation (you cannot insert logic between View \u0026lt;=\u0026gt; Model where MVVM is all about  Purist interpretation This is what the developers of Catel strongly believe in. It requires a bit more code, but gives great freedom and control and protection of the model because all bindings go through the view model.\n Advantages\n Full contol and freedom, you can inject both logic and validation between view and model (what MVVM is actually about) Everything is available on the view model, no need for \u0026ldquo;sub-bindings\u0026rdquo; (such as Model.[PropertyName]) Protection of your model from the view  Disadvantages\n Needs a bit more code (but thanks to code snippets and the Expose attribute, this is not a big disadvantage)\n"},{"uri":"https://docs.catelproject.com/vnext/faq/general/","title":"General","tags":[],"description":"","content":""},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/getting-prerelease-versions-via-nuget/","title":"Getting prerelease (beta) versions via NuGet &amp; MyGet","tags":[],"description":"","content":" Adding the custom package source Starting with Catel v5, the alpha prereleases are only available on the [MyGet feed for Catel](https://www.myget.org/feed/Packages/catel). Therefore you must first add the custom url to the NuGet Package Manager. The easiest way to do this is via Visual Studio.   Go to Tools =\u0026gt; NuGet Package Manager =\u0026gt; Package Manager Settings Select Package Sources Click the + button at the right top and use the following values at the bottom: Name: MyGet - Catel Source: https://www.myget.org/F/catel/api/v3/index.json  Installing via package manager Please make sure to select the same settings as in the screenshow below:\nInstalling via package manager console This example installs Catel.MVVM as a package. However, to install other packages simple change the ID (name) of the package.\nInstalling the latest beta\nInstall-Package Catel.MVVM –IncludePrerelease  Installing a specific beta\nInstall-Package Catel.MVVM –IncludePrerelease -version 5.0.0-unstable0532  Updating to the latest beta\nUpdate-Package Catel.MVVM –IncludePrerelease  Updating to a specific beta\nUpdate-Package Catel.MVVM –IncludePrerelease -version 5.0.0-unstable0532  Updating to the latest stable version\nUpdate-Package Catel.MVVM  "},{"uri":"https://docs.catelproject.com/vnext/introduction/","title":"Introduction","tags":[],"description":"","content":" Welcome to the introduction of Catel. Catel is a framework (or enterprise library, just use whatever you like) with data handling, diagnostics, logging, WPF controls, and an MVVM-framework. So Catel is more than \u0026ldquo;just\u0026rdquo; another MVVM-framework or some nice Extension Methods that can be used. It\u0026rsquo;s more like a library that you want to include in all the XAML applications you are going to develop in the near future.\nCatel is primarily meant for Line of Business (LoB) applications  It\u0026rsquo;s important to realize that Catel is not just another Extension Methods library, nor only an MVVM-framework, but it is a combination of basic data handling, useful controls, and an MVVM-framework.\nWhy another framework? You might be thinking: why another framework, there are literally thousands of them out there. Well, first of all, thousands of them is quite a lot, let\u0026rsquo;s just say there are hundreds of them. A few years ago, the lead developer of Catel was using serialization to serialize data from/to disk. But, as he noticed, he had to take care of different versions after every release. After every release, he had to take care of the serialization and backwards compatibility. Also, he had to implement some very basic interfaces (such as INotifyPropertyChanged) for every data object. Then, he decided to write a base class for data handling which can take care of different versions and serialization by itself, and implements the most basic interfaces of the .NET Framework out of the box. The article was published on CodeProject as DataObjectBase.\nThen, he was working on a WPF project with five other developers and needed an MVVM-framework since the application was not using MVVM at the moment. Writing an MVVM-framework was no option because there were so many other frameworks out there. But, after looking at some Open-Source MVVM-frameworks (such as the excellent Cinch framework, which was the best one we could find), none of them seemed to be a real option. Creating the View Models was too much work, and the View Models still contained lots of repetitive code in, for example, the property definitions. After taking a closer look at the source code of Cinch and other frameworks, the lead developer thought: if we use the DataObjectBase published before as the base for a View Model class, it should be possible to create a framework in a very short amount of time.\nThen, all other developers of the team he was working on the project got enthusiastic, and then the whole team decided to merge their personal libraries into one big enterprise library, and Catel was born.\nWhy use this framework? Before reading any further, it\u0026rsquo;s important to know why you should use the framework. Below are a few reasons why Catel might be interesting for you:\n Catel is Open-Source. This way, you can customize it any way you want. If you want a new feature request, and the team does not respond fast enough, you can simply implement it yourself. The codebase for Catel is available on GitHub. This way, you have the option to either download the latest stable release, or live on the edge by downloading the latest source code. Catel uses unit tests to make sure that new updates do not break existing functionality. Catel is very well documented. Every method and property has comments, and the comments are available in a separate reference help file. There is also a lot of documentation available, and in the future, in-depth articles will be written. Catel is developed by a group of talented software developers, and is heavily under development. This is a great advantage because the knowledge is not at just one person, but at a whole group. The developers of Catel all have more than three years of development experience with WPF, and are using Catel in real life applications for at least 2 years.  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/","title":"Log listeners","tags":[],"description":"","content":" Batch log listeners   ConsoleLogListener   DebugLogListener   Event Tracing for Windows (ETW)   EventLogListener   FileLogListener   RollingInMemoryLogListener   SeqLogListener   "},{"uri":"https://docs.catelproject.com/vnext/catel-core/messaging/messagebase/","title":"MessageBase","tags":[],"description":"","content":" The MessageMediator is a very powerful class to send messages to other objects inside an application. However, it can sometimes by cumbersome to register and create messages. Therefore the MessageBase class is a very nice convenience class to create messages and allow easier registration.\nThe MessageBase provides the following additional functionality out of the box:\n Send messages with data without instantiating a message Register message handlers Unregister message handlers  Creating messages based on the MessageBase  It is very easy to create a new message. The message below is a message that contains a string and this little class provides lots of capabilities.\npublic class DemoMessage : MessageBase\u0026lt;DemoMessage, string\u0026gt; { public DemoMessage() { } public DemoMessage(string content) : base(content) { } }  Note that the message needs an empty constructor  ## Sending messages\nA user can send a message by using the following code:\nDemoMessage.SendWith(\u0026quot;hello world\u0026quot;);  Registering to messages\n A class that is interested in message can register to a message using the Register method:\nDemoMessage.Register(this, OnDemoMessage);  Unregistering from messages DemoMessage.Unregister(this, OnDemoMessage);  Instantiating a message with data The MessageBase class can also instantiate messages by using the With method:\nvar message = DemoMessage.With(\u0026quot;hello world\u0026quot;);  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/data-handling/observableobject/","title":"ObservableObject","tags":[],"description":"","content":"The ObservableObject is a very lightweight class that only implements the INotifyPropertyChanging and INotifyPropertyChanged interfaces. This class is ideal for simple objects that only need property notification. Below is an example:\npublic class Person : ObservableObject { private string _firstName; private string _middleName; private string _lastName; public Person(string firstName, string middleName, string lastName) { FirstName = firstName; MiddleName = middleName; LastName = lastName; } public string FirstName { get { return _firstName; } set { RaisePropertyChanging(() =\u0026gt; FirstName); var oldValue = _firstName; _firstName = value; RaisePropertyChanged(() =\u0026gt; FirstName, oldValue, value); } } public string MiddleName { get { return _middleName; } set { RaisePropertyChanging(() =\u0026gt; MiddleName); var oldValue = _middleName; _middleName = value; RaisePropertyChanged(() =\u0026gt; MiddleName, oldValue, value); } } public string LastName { get { return _lastName; } set { RaisePropertyChanging(() =\u0026gt; LastName); var oldValue = _lastName; _lastName = value; RaisePropertyChanged(() =\u0026gt; LastName, oldValue, value); } } }  "},{"uri":"https://docs.catelproject.com/vnext/getting-started/quick-introduction-for-developers/","title":"Quick introduction for developers","tags":[],"description":"","content":" This is a quick introduction for developers who don\u0026rsquo;t have a lot of time to read all the docs. This document contains the absolute basics of what a developer needs to know.\nCore This pare contains the core functionality of Catel and what you should know when using Catel.\nLogging / debugging If you ever think Catel is behaving strange or does not work as expected, make sure to enable the logging. Below is an example on how to enable the logging:\n#if DEBUG LogManager.RegisterDebugListener(); #endif  Catel will then log everything to the output window and provide all the information about its internals.\nFor more information, read about logging.\nCatel properties All properties in classes deriving from ModelBase (thus also ViewModelBase) require a special property definition.\nNormally one would write something like this:\nprivate string _firstName; public string FirstName { get { return _firstName; } set { RaisePropertyChanging(\u0026quot;FirstName\u0026quot;); _firstName = value; RaisePropertyChanged(\u0026quot;FirstName\u0026quot;); } }  In Catel one should write this:\npublic string FirstName { get { return GetValue\u0026lt; string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string), null);  Catel will automatically take care of change notifications.\nNote that you can use the modelprop or vmprop to easily create these properties using code snippets. You can also use Catel.Fody instead\nMVVM This part is especially meant for the MVVM part.\nHandling of viewmodels In other MVVM frameworks, you are obliged to set the data context of a view manually. It will look something like this:\nvar view = new PersonView(); view.DataContext = new PersonViewModel();  Catel automatically resolves the right view model based on the view. If a view is created, Catel automatically creates the view model:\nvar view = new PersonView(); // view model is automatically created  It goes even further. Catel can create view models based on the data context. For more information, read nested user controls.\nHandling hierarchy and parent/child view models Note that Catel is already fully aware of parent/child relations of view models so you don’t have to do anything for this yourself. For more information, read nested user controls.\nResolving views and view models Catel resolves views and view models by naming convention. This means that based on the name of a view, the view model can be determined. This also works the other way around where the view model can be determined based on the view. For more information, read about naming conventions.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/servicelocator/","title":"ServiceLocator","tags":[],"description":"","content":" The ServiceLocator services as the container inside Catel.\nInternally it uses the TypeFactory as instantiator for the services.\nCatel uses it\u0026rsquo;s own ServiceLocator implementing the IServiceLocator to gather all services required by Catel. For example, default services are the IPleaseWaitService and the IUIVisualizerService. By default, when the first view model is instantiated, Catel registers all default out of the box services to the ServiceLocator. However, it only does this when the specific services are not already registered. This allows an end-developer to register his/her own implementations of the services before any view model is instantiated (for example, at application startup).\nThe ServiceLocator can be instantiated, but Catel instantiates one instance that can be used and shared amongst all objects inside the same AppDomain. The ServiceLocator can be retrieved by using ServiceLocator.Default.\nFor more information how types are instantiated and dependency injection, take a look at the [TypeFactory documentation](/vnext/catel-core/ioc/introduction-to-components/typefactory/)  Registering a type Use the following code to register a specific type in the ServiceLocator:\nServiceLocator.Default.RegisterType\u0026lt;IPleaseWaitService, PleaseWaitService\u0026gt;();  Registering a late-bound type Use the following code to register a late-bound type in the ServiceLocator:\nServiceLocator.Default.RegisterType\u0026lt;IPleaseWaitService\u0026gt;(x =\u0026gt; new PleaseWaitService());  Registering an instance of a type Catel uses the TypeFactory or Activator.CreateInstance to create the interface implementations when the object is first resolved. However, sometimes a service constructor requires parameters or takes a long time to construct. In such cases, it is recommended to create the type manually and register the instance of the type:\nvar pleaseWaitService = new PleaseWaitService(); ServiceLocator.Default.RegisterInstance\u0026lt;IPleaseWaitService\u0026gt;(pleaseWaitService);  Registering a type via MissingType event The ServiceLocator gives the end-developer a last-resort chance to register a type when it is not registered in the ServiceLocator or any of the external containers. This event is very useful for logging (then the developer in the log knows exactly what type is missing from the IoC container) or it can be used to determine at runtime in a very late stage what implementation of the service must be used. To register a type via the event, subscribe to the event and then use the following code:\nprivate void OnMissingType(object sender, MissingTypeEventArgs e) { if (e.InterfaceType == typeof(IPleaseWaitService)) { // Register an instance e.ImplementingInstance = new PleaseWaitService(); // Or a type e.ImplementingType = typeof(PleaseWaitService); } }  If both the ImplementingInstance and ImplementingType are filled, the ImplementingIntance will be used.\nResolving a type To retrieve the implementation of a service, use the following code:\nvar pleaseWaitService = ServiceLocator.Default.ResolveType\u0026lt;IPleaseWaitService\u0026gt;();  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/serialization/specifying-what-gets-serialized/","title":"Specifying what gets serialized","tags":[],"description":"","content":" By default, Catel only serializes the defined Catel properties on the ModelBase or any deriving classes. It is possible to customize this behavior. Below is a class which will be used in all examples:\npublic class MyModel : ModelBase { private string _fieldValue; public string RegularProperty { get; set; } public string CatelProperty { get { return GetValue\u0026lt;string\u0026gt;(CatelPropertyProperty); } set { SetValue(CatelPropertyProperty, value); } } public static readonly PropertyData CatelPropertyProperty = RegisterProperty(\u0026quot;CatelProperty\u0026quot;, typeof(string), null); }     Member name Gets serialized     _fieldValue false   RegularProperty false   CatelProperty true    Including fields and properties using IncludeInSerialization attribute To include fields or regular properties on an object, use the following code:\npublic class MyModel : ModelBase { [IncludeInSerialization] private string _fieldValue; [IncludeInSerialization] public string RegularProperty { get; set; } public string CatelProperty { get { return GetValue\u0026lt;string\u0026gt;(CatelPropertyProperty); } set { SetValue(CatelPropertyProperty, value); } } public static readonly PropertyData CatelPropertyProperty = RegisterProperty(\u0026quot;CatelProperty\u0026quot;, typeof(string), null); }     Member name Gets serialized     _fieldValue true   RegularProperty true   CatelProperty true    Note that private members can only be serialized in full .NET, not in limited platforms such as UWP  Excluding fields and properties using ExcludeFromSerialization attribute To exclude Catel properties on an object, use the following code:\npublic class MyModel : ModelBase { private string _fieldValue; public string RegularProperty { get; set; } [ExcludeFromSerialization] public string CatelProperty { get { return GetValue\u0026lt;string\u0026gt;(CatelPropertyProperty); } set { SetValue(CatelPropertyProperty, value); } } public static readonly PropertyData CatelPropertyProperty = RegisterProperty(\u0026quot;CatelProperty\u0026quot;, typeof(string), null); }     Member name Gets serialized     _fieldValue false   RegularProperty false   CatelProperty false    Serializing a ModelBase as collection There is a very edge case that a class derives from ModelBase, but also implements IList\u0026lt;T\u0026gt;. In this case, it\u0026rsquo;s hard for the serializers to determine what to do. By default, it will treat the model as a Catel model (since it can contain more properties than just the Items property. If such a class should be serialized as collection (meaning it will only serialize the Items property), decorate it with the SerializeAsCollection attribute:\n [SerializeAsCollection] public class MyModel : ModelBase, IList\u0026lt;int\u0026gt; { // implementation left out for readability }  Implementing a custom ISerializationManager Internally Catel uses a default implementation of the ISerializationManager to determine what members of a type should be serialized. It is possible to customize this behavior by overriding a single method or by creating a brand new type. Below is an example which always excludes Password properties and fields from serialization.\npublic class SafeSerializationManager : SerializationManager { public override HashSet\u0026lt;string\u0026gt; GetFieldsToSerialize(Type type) { var fieldsList = new List\u0026lt;string\u0026gt;(base.GetFieldsToSerialize(type)); for (int i = 0; i \u0026lt; fieldsList.Count; i++) { if (string.Equals(fieldsList[i], \u0026quot;_password\u0026quot;)) { fieldsList.RemoveAt(i--); } } return new HashSet\u0026lt;string\u0026gt;(fieldsList); } public override HashSet\u0026lt;string\u0026gt; GetPropertiesToSerialize(Type type) { var propertiesList = new List\u0026lt;string\u0026gt;(base.GetPropertiesToSerialize(type)); for (int i = 0; i \u0026lt; propertiesList.Count; i++) { if (string.Equals(propertiesList[i], \u0026quot;Password\u0026quot;)) { propertiesList.RemoveAt(i--); } } return new HashSet\u0026lt;string\u0026gt;(propertiesList); } }  Don\u0026rsquo;t forget to register it in the ServiceLocator as well:\nvar serviceLocator = ServiceLocator.Default; serviceLocator.RegisterType\u0026lt;ISerializationManager, SafeSerializationManager\u0026gt;();  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/automatic-type-registration/using-attributes/","title":"Using attributes","tags":[],"description":"","content":" The ServiceLocator in Catel can be set up to discover attribute based registration. Declaring a registration since the type definition There is a way to automatically register types into a service locator. Using ServiceLocatorRegistrationAttribute it is possible to register types into the service locator in a declarative way. The following code shows how use this attribute:\n[ServiceLocatorRegistration(typeof(IMyClass))] public class MyClass : IMyClass { }  All registration options are available in attribute based registration, such as registration type and tag, as ServiceLocatorRegistrationAttribute constructor arguments. The following code shows how use such options (it registers the MyClass using the IMyClass interface in a transient way (new type every time it is resolved) using the tag MyTag:\n[ServiceLocatorRegistration(typeof(IMyClass), RegistrationType.Transient, \u0026quot;MyTag\u0026quot;)] public class MyClass : IMyClass { }  Activating service locator to scan for automatically registration By default the service locator doesn\u0026rsquo;t scan for automatic registration. In order to activate this you should set AutoRegisterTypesViaAttributes to true.\nvar serviceLocator = ServiceLocator.Default; serviceLocator.AutoRegisterTypesViaAttributes = true;  "},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/code-snippets-templates/using-the-code-snippets/","title":"Using the code snippets","tags":[],"description":"","content":"This part of the documentation explains all the code snippets.\n   Code snippet Explanation     modelobject Defines a model using the ModelBase class.   modelprop Defines a new property on a model class.   modelpropchanged Defines a new property with change notification on a model class.   vm Defines a new view model.   vmcommand Defines a new view model command with only an executed action.   vmcommandwithcanexecute Defines a new view model command with an executed action, but also a canexecute function.   vmprop Defines a new property on a view model.   vmpropmodel Defines a new property on a view model and decorates it with the ModelAttribute.   vmpropviewmodeltomodel Defines a new property on a view model and decorates it with the ViewModelToModelAttribute.    "},{"uri":"https://docs.catelproject.com/vnext/catel-core/validation/validation-via-validate-method/","title":"Validation via validate methods","tags":[],"description":"","content":"The ViewModelBase derives from ModelBase, thus all information here also applies to the ViewModelBase  The easiest way to implement validation is to override the ValidateFields and ValidateBusinessRules methods. Below is an example of an implementation of the ValidateFields method:\nprotected override void ValidateFields(List\u0026lt;IFieldValidationResult\u0026gt; validationResults) { if (string.IsNullOrEmpty(FirstName)) { validationResults.Add(FieldValidationResult.CreateError(FirstNameProperty, \u0026quot;First name is required\u0026quot;)); } if (string.IsNullOrEmpty(LastName)) { validationResults.Add(FieldValidationResult.CreateError(LastNameProperty, \u0026quot;Last name is required\u0026quot;)); } if (Gender == Gender.Unknown) { validationResults.Add(FieldValidationResult.CreateError(GenderProperty, \u0026quot;Gender cannot be unknown\u0026quot;)); } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/exception-handling/wpf-implementation-for-exception-handling/","title":"WPF implementation for exception handling","tags":[],"description":"","content":" Creating a watcher The watcher below is a self-managed watcher that takes care of exception handling in case of unhandled exceptions in both the AppDomain and Dispatcher.\npublic class ExceptionWatcher { private static readonly ILog Log = LogManager.GetCurrentClassLogger(); private readonly IExceptionService _exceptionService; private readonly IMessageService _messageService; public ExceptionWatcher(IExceptionService exceptionService, IMessageService messageService) { Argument.IsNotNull(() =\u0026gt; exceptionService); Argument.IsNotNull(() =\u0026gt; messageService); _exceptionService = exceptionService; _messageService = messageService; exceptionService.Register\u0026lt;Exception\u0026gt;(async exception =\u0026gt; { await _messageService.ShowAsync(\u0026quot;An unknown exception occurred, please contact the developers\u0026quot;); }); var appDomain = AppDomain.CurrentDomain; appDomain.FirstChanceException += OnAppDomainFirstChanceException; appDomain.UnhandledException += OnAppDomainUnhandledException; var dispatcher = DispatcherHelper.CurrentDispatcher; if (dispatcher != null) { dispatcher.UnhandledException += OnDispatcherUnhandledException; } } private void OnAppDomainFirstChanceException(object sender, FirstChanceExceptionEventArgs e) { //var exception = e.Exception; //if (exception != null) //{ // _exceptionService.HandleException(exception); //} } private void OnAppDomainUnhandledException(object sender, UnhandledExceptionEventArgs e) { var exception = e.ExceptionObject as Exception; if (exception != null) { Log.Error(exception, \u0026quot;AppDomain.UnhandledException occurred\u0026quot;); _exceptionService.HandleException(exception); } } private void OnDispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e) { var exception = e.Exception; if (exception != null) { Log.Error(exception, \u0026quot;Dispatcher.UnhandledException occurred\u0026quot;); if (_exceptionService.HandleException(exception)) { e.Handled = true; } } } }  Registering the exception watcher In order for this exception handler to work, you need to register it so it stays alive in the application. Use the code below:\nvar serviceLocator = ServiceLocator.Default; serviceLocator.RegisterTypeAndInstantiate\u0026lt;ExceptionWatcher\u0026gt;();  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/automatic-type-registration/","title":"Automatic type registration","tags":[],"description":"","content":" Using attributes   Using conventions   "},{"uri":"https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-uwp/","title":"Caveats in UWP","tags":[],"description":"","content":"Below are all caveats in UWP.\nKnow caveats? Feel free to add them!\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/apicop/cops/","title":"Cops","tags":[],"description":"","content":" The *IApiCop* is responsible for containing all the rules that are used inside a class. A class should contain only one *IApiCop* and one or more rules.\nRetrieving an IApiCop for a class To retrieve an IApiCop for a class, use the following code:\nprivate static readonly IApiCop = ApiCopManager.GetCurrentClassApiCop();  "},{"uri":"https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-models/","title":"Creating the models","tags":[],"description":"","content":" In this step we will create models. Since this application is about families and persons inside those families, we need to create the following models: Settings, Family and Person. Creating the model classes The models that will be used in this application will derive from the ModelBase, ValidatableModelBase or SavableModelBase class of Catel. These classes enable support for change notifications, validations and persistence. The SavableModelBase adds additional methods to save and load from/to streams or files without having to create a serializer first.\nTo create the model classes, create the following classes in the Models folder.\nThe *model* code snippet is available to create models  Settings class The settings class is the top container that will store all families and other settings (which might be added in the future).\nnamespace WPF.GettingStarted.Models { using Catel.Data; public class Settings : SavableModelBase\u0026lt;Settings\u0026gt; { } }  Family class namespace WPF.GettingStarted.Models { using Catel.Data; public class Family : ValidatableModelBase { } }  Person class namespace WPF.GettingStarted.Models { using Catel.Data; public class Person : ValidatableModelBase { } }  Adding properties to the models The next step is to add properties to the models. An important concept to understand is that Catel uses specific \u0026ldquo;dependency-a-like\u0026rdquo; properties in order to provide all the functionality in the ModelBase classes. Below are the properties per model that need to be registered.\nAt first sight, these properties might look very overwhelming. Let\u0026rsquo;s take a look at how the property system works. The most important thing is the actual property registration:\npublic static readonly PropertyData PersonsProperty = RegisterProperty(\u0026quot;Persons\u0026quot;, typeof(ObservableCollection\u0026lt;Person\u0026gt;), () =\u0026gt; new ObservableCollection\u0026lt;Person\u0026gt;());  This defines a property on the model with the following data:\n Name =\u0026gt; Persons Type =\u0026gt; ObservableCollection DefaultValue =\u0026gt; new ObservableCollection()  This will create a property in the property bag of the model. The next piece of the property is the actual wrapper around the property value which is managed by the property bag. The Catel properties always need a wrapper to be exposed to the \u0026ldquo;outside world\u0026rdquo; of the class.\npublic ObservableCollection\u0026lt;Person\u0026gt; Persons { get { return GetValue\u0026lt;ObservableCollection\u0026lt;Person\u0026gt;\u0026gt;(PersonsProperty); } set { SetValue(PersonsProperty, value); } }  If you want to get the functionality in the `ModelBase` classes without the \"dependency-a-like\" properties you have the option to make use of normal properties and Catel.Fody.  The *modelprop* code snippet is available to create models  Settings class public class Settings : SavableModelBase\u0026lt;Settings\u0026gt; { /// \u0026lt;summary\u0026gt; /// Gets or sets all the families. /// \u0026lt;/summary\u0026gt; public ObservableCollection\u0026lt;Family\u0026gt; Families { get { return GetValue\u0026lt;ObservableCollection\u0026lt;Family\u0026gt;\u0026gt;(FamiliesProperty); } set { SetValue(FamiliesProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Families property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FamiliesProperty = RegisterProperty(\u0026quot;Families\u0026quot;, typeof(ObservableCollection\u0026lt;Family\u0026gt;), () =\u0026gt; new ObservableCollection\u0026lt;Family\u0026gt;()); }  Family class public class Family : ValidatableModelBase { /// \u0026lt;summary\u0026gt; /// Gets or sets the family name. /// \u0026lt;/summary\u0026gt; public string FamilyName { get { return GetValue\u0026lt;string\u0026gt;(FamilyNameProperty); } set { SetValue(FamilyNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FamilyName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FamilyNameProperty = RegisterProperty(\u0026quot;FamilyName\u0026quot;, typeof(string), null); /// \u0026lt;summary\u0026gt; /// Gets or sets the list of persons in this family. /// \u0026lt;/summary\u0026gt; public ObservableCollection\u0026lt;Person\u0026gt; Persons { get { return GetValue\u0026lt;ObservableCollection\u0026lt;Person\u0026gt;\u0026gt;(PersonsProperty); } set { SetValue(PersonsProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Persons property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData PersonsProperty = RegisterProperty(\u0026quot;Persons\u0026quot;, typeof(ObservableCollection\u0026lt;Person\u0026gt;), () =\u0026gt; new ObservableCollection\u0026lt;Person\u0026gt;()); public override string ToString() { return FamilyName; } }  Person class public class Person : ValidatableModelBase { /// \u0026lt;summary\u0026gt; /// Gets or sets the first name. /// \u0026lt;/summary\u0026gt; public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FirstName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string), null); /// \u0026lt;summary\u0026gt; /// Gets or sets the last name. /// \u0026lt;/summary\u0026gt; public string LastName { get { return GetValue\u0026lt;string\u0026gt;(LastNameProperty); } set { SetValue(LastNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the LastName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData LastNameProperty = RegisterProperty(\u0026quot;LastName\u0026quot;, typeof(string), null); public override string ToString() { string fullName = string.Empty; if (!string.IsNullOrEmpty(FirstName)) { fullName += FirstName; } if (!string.IsNullOrEmpty(FirstName) \u0026amp;\u0026amp; !string.IsNullOrWhiteSpace(LastName)) { fullName += \u0026quot; \u0026quot;; } if (!string.IsNullOrWhiteSpace(LastName)) { fullName += LastName; } return fullName; } }  Up next Serializing data from/to disk\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/customizing-listeners/","title":"Customizing listeners","tags":[],"description":"","content":"Each listener can be customized to only receive the logs that the listener is interested in. This way, the listener does not receive events it is not interested in. For example, to only receive errors, create a new listener and use the following customization:\nvar listener = new MyLogListener(); listener.IsDebugEnabled = false; listener.IsInfoEnabled = false; listener.IsWarningEnabled = false; listener.IsErrorEnabled = true;  By default, all types of logging are enabled on a log listener.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/customizing-serialization-for-specific-models/","title":"Customizing the serialization for specific models","tags":[],"description":"","content":" Catel has a default behavior for what gets serialized. It can be tweaked by including / excluding fields and properties by using the IncludeInSerialization and ExcludeFromSerialization attributes. But sometimes one needs more specific customization of the serialization for a specific type. This customization is possible via the ISerializerModifier.\nCreating the modifier To customize the serialization of a specific model type, one needs to implement the ISerializerModifier interface. The example belows shows how to encrypt the Password property on the Person model class.\npublic class PersonSerializerModifier : SerializerModifierBase\u0026lt;Person\u0026gt; { public override void SerializeMember(ISerializationContext context, MemberValue memberValue) { if (string.Equals(memberValue.Name, \u0026quot;Password\u0026quot;)) { memberValue.Value = EncryptionHelper.Encrypt(memberValue.Value); } } public override void DeserializeMember(ISerializationContext context, MemberValue memberValue) { if (string.Equals(memberValue.Name, \u0026quot;Password\u0026quot;)) { memberValue.Value = EncryptionHelper.Decrypt(memberValue.Value); } } }  Registering the modifier To register a modifier for a specific class, define the SerializerModifier attribute:\n[SerializerModifier(typeof(PersonSerializerModifier))] public class Person : ModelBase { // .. class contents }  Note that modifiers are inherited from base classes. When serializing, the modifiers defined on the most derived classes will be called last. When deserializing, the modifies defined on the most derived classes will be called first.  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/data-handling/dispatcherobservableobject/","title":"DispatcherObservableObject","tags":[],"description":"","content":"Note that the *DispatcherObservableObject* is located in *Catel.MVVM* because it uses the *IDispatcherService*  The DispatcherObservableObject is a class that derives from the ObservableObject class. The only difference is that the DispatcherObservableObject will dispatch all property change notifications to the UI thread. Below is a class that uses the DispatcherObservableObject and is thread-safe for the change notifications.\npublic class Person : DispatcherObservableObject { private string _firstName; private string _middleName; private string _lastName; public Person(string firstName, string middleName, string lastName) { FirstName = firstName; MiddleName = middleName; LastName = lastName; } public string FirstName { get { return _firstName; } set { RaisePropertyChanging(() =\u0026gt; FirstName); var oldValue = _firstName; _firstName = value; RaisePropertyChanged(() =\u0026gt; FirstName, oldValue, value); } } public string MiddleName { get { return _middleName; } set { RaisePropertyChanging(() =\u0026gt; MiddleName); var oldValue = _middleName; _middleName = value; RaisePropertyChanged(() =\u0026gt; MiddleName, oldValue, value); } } public string LastName { get { return _lastName; } set { RaisePropertyChanging(() =\u0026gt; LastName); var oldValue = _lastName; _lastName = value; RaisePropertyChanged(() =\u0026gt; LastName, oldValue, value); } } }  "},{"uri":"https://docs.catelproject.com/vnext/faq/","title":"FAQ","tags":[],"description":"","content":" General   MVVM   Problem solving   Performance considerations   "},{"uri":"https://docs.catelproject.com/vnext/getting-started/wpf/","title":"Getting started with WPF","tags":[],"description":"","content":"Welcome to the Getting started guide for Catel and WPF. In this guide, a very simple application will be created with the most commonly used aspects of Catel and WPF.\nThe application will manage family members and will display the families in separate views.\nNote that this guide assumes that the reader has a basic understanding of XAML and WPF since this guide will not cover these basics  The source code for this example can be found at   Note that this guide will recommend code snippets that can be found [here](http://www.catelproject.com/downloads/general-files/). They are not required, just recommended to speed up creating Catel classes and properties.   Creating the WPF project   Creating the models   Serializing data from/to disk   Creating the view models   Creating the views (user controls)   Creating the views (windows)   Hooking up everything together   Finalizing the application   Download the final result: WPF.GettingStarted.zip\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/","title":"Introduction to components","tags":[],"description":"","content":" ServiceLocator   TypeFactory   DependencyResolver and DependencyResolverManager   Ensuring integrity of the ServiceLocator   "},{"uri":"https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/","title":"Introduction to customizing serialization","tags":[],"description":"","content":" The serialization engine explained All classes deriving from ModelBase use the serialization engine of Catel to serialize itself in a whole or as a subset of properties. Below is a schema which sheds some light on the architecture.\nThe SerializerBase now contains all the serialization and deserialization logic. The advantage is that this logic is no longer contained by the ModelBase itself which makes the class much simpler to understand and maintain. Now the SerializerBase contains all the heavy lifting, the deriving classes (XmlSerializer and BinarySerializer) only have to implement a few methods.\nThe serialization process works as shown in the diagram below:\nWorkflow 1 represents the serialization. Workflow 2 represents the deserialization.  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/messaging/message-mediator/","title":"Message mediator","tags":[],"description":"","content":" Catel allows sending messages to unknown targets by implementing the mediator pattern. The mediator is assured memory leak free, and can be used safely in any .NET environment (even ASP.NET). Below are a few usage examples of the MessageMediator class.\nRegistering to a message  To register a handler for a specific message type, in this case a string, use the following code:\nvar mediator = ServiceLocator.Default.ResolveType\u0026lt;IMessageMediator\u0026gt;(); mediator.Register\u0026lt;string\u0026gt;(this, OnMessage);  Sending out a message  To send a message to all recipients, use the following code:\nvar mediator = ServiceLocator.Default.ResolveType\u0026lt;IMessageMediator\u0026gt;(); mediator.SendMessage\u0026lt;string\u0026gt;(\u0026quot;message\u0026quot;);  Sending out a message with a tag  Sometimes, you want to send messages only based on a tag. For example, you want to let other view models know that you just added a person. All recipients that registered to the string message type with the Person tag will receive the message:\nvar mediator = ServiceLocator.Default.ResolveType\u0026lt;IMessageMediator\u0026gt;(); mediator.SendMessage\u0026lt;string\u0026gt;(\u0026quot;Person added\u0026quot;, \u0026quot;Person\u0026quot;);  "},{"uri":"https://docs.catelproject.com/vnext/faq/mvvm/","title":"MVVM","tags":[],"description":"","content":" How to support example data with view models? To find out how to create design time data, see the designerstopic.\nHow to use events with MVVM? When writing MVVM, it\u0026rsquo;s \u0026ldquo;forbidden\u0026rdquo; (read: not a best practice) to use click handlers (or other UI events) in your view-model. But then should you react to events?\n Start with creating a command like you are used to using MVVM. This command will be executed when the event occurs. Add a reference to System.Windows.Interactivity.dll (ships with Catel). If you have used NuGet to add a reference, it is automatically included for you. Add the following namespace definitions to your view declaration:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  Use the following code to convert an event to a command:\n\u0026lt;i:Interaction.Triggers\u0026gt; \u0026lt;i:EventTrigger EventName=\u0026quot;[YourEvent]\u0026quot;\u0026gt; \u0026lt;catel:EventToCommand Command=\u0026quot;{Binding [YourCommand]}\u0026quot; DisableAssociatedObjectOnCannotExecute=\u0026quot;False\u0026quot; /\u0026gt; \u0026lt;/i:EventTrigger\u0026gt; \u0026lt;/i:Interaction.Triggers\u0026gt;   An example for a *ListBox *double click:\n\u0026lt;ListBox ItemsSource=\u0026quot;{Binding PersonCollection}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedPerson}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Triggers\u0026gt; \u0026lt;i:EventTrigger EventName=\u0026quot;MouseDoubleClick\u0026quot;\u0026gt; \u0026lt;catel:EventToCommand Command=\u0026quot;{Binding Edit}\u0026quot; DisableAssociatedObjectOnCannotExecute=\u0026quot;False\u0026quot; /\u0026gt; \u0026lt;/i:EventTrigger\u0026gt; \u0026lt;/i:Interaction.Triggers\u0026gt; \u0026lt;ListBox.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;StackPanel Orientation=\u0026quot;Horizontal\u0026quot;\u0026gt; \u0026lt;Label Content=\u0026quot;{Binding FirstName}\u0026quot; /\u0026gt; \u0026lt;Label Content=\u0026quot;{Binding MiddleName}\u0026quot; /\u0026gt; \u0026lt;Label Content=\u0026quot;{Binding LastName}\u0026quot; /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListBox.ItemTemplate\u0026gt; \u0026lt;/ListBox\u0026gt;  How can I add the MVVM behaviors via code (programmatically)? Below is the code-behind of a view that adds the UserControlBehavior via code:\npublic partial class DynamicBehaviorView : UserControl, IViewModelContainer { private Catel.Windows.Controls.MVVMProviders.UserControlBehavior _mvvmBehavior; /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;DynamicBehaviorView\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; public DynamicBehaviorView() { InitializeComponent(); _mvvmBehavior = new Catel.Windows.Controls.MVVMProviders.UserControlBehavior(); _mvvmBehavior.ViewModelType = typeof(ViewModels.MyViewModel); System.Windows.Interactivity.Interaction.GetBehaviors(this).Add(_mvvmBehavior); _mvvmBehavior.ViewModelChanged += (sender, e) =\u0026gt; ViewModelChanged.SafeInvoke(this, e); _mvvmBehavior.ViewModelPropertyChanged += (sender, e) =\u0026gt; ViewModelPropertyChanged.SafeInvoke(this, e); } /// \u0026lt;summary\u0026gt; /// Gets the view model that is contained by the container. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;The view model.\u0026lt;/value\u0026gt; public IViewModel ViewModel { get { return _mvvmBehavior.ViewModel; } } /// \u0026lt;summary\u0026gt; /// Occurs when the \u0026lt;see cref=\u0026quot;ViewModel\u0026quot;/\u0026gt; property has changed. /// \u0026lt;/summary\u0026gt; public event EventHandler\u0026lt;EventArgs\u0026gt; ViewModelChanged; /// \u0026lt;summary\u0026gt; /// Occurs when a property on the \u0026lt;see cref=\u0026quot;ViewModel\u0026quot;/\u0026gt; has changed. /// \u0026lt;/summary\u0026gt; public event EventHandler\u0026lt;PropertyChangedEventArgs\u0026gt; ViewModelPropertyChanged; /// \u0026lt;summary\u0026gt; /// Occurs when a property on the container has changed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;remarks\u0026gt; /// This event makes it possible to externally subscribe to property changes of a \u0026lt;see cref=\u0026quot;DependencyObject\u0026quot;/\u0026gt; /// (mostly the container of a view model) because the .NET Framework does not allows us to. /// \u0026lt;/remarks\u0026gt; public event EventHandler\u0026lt;PropertyChangedEventArgs\u0026gt; PropertyChanged; /// \u0026lt;summary\u0026gt; /// Invoked whenever the effective value of any dependency property on this \u0026lt;see cref=\u0026quot;T:System.Windows.FrameworkElement\u0026quot;/\u0026gt; has been updated. The specific dependency property that changed is reported in the arguments parameter. Overrides \u0026lt;see cref=\u0026quot;M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)\u0026quot;/\u0026gt;. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;e\u0026quot;\u0026gt;The event data that describes the property that changed, as well as old and new values.\u0026lt;/param\u0026gt; protected override void OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs e) { base.OnPropertyChanged(e); PropertyChanged.SafeInvoke(this, new PropertyChangedEventArgs(e.Property.Name)); } }  Using this technique, it is even possible to determine the view model of any view dynamically at runtime.\nHow can I inject or manipulate the view model of a UserControl? The UserControl is a very powerful control. It allows lazy loaded dynamic view model construction. However, sometimes you just don\u0026rsquo;t want the user control to dynamically create the view model. Luckily, the user control instantiates a new view model with this logic:\n The DataContext of the control can be injected into a constructor of the view model The view model has an empty constructor   You can set the DataContext of the control to a view model, and this way \u0026ldquo;inject\u0026rdquo; a view model into a control instead of letting it be created first. In fact, the user control first checks whether the DataContext is already a valid view model for the user control. If so, it keeps it that way.\nHow can I prevent validation of required fields? Catel does not validate the properties with data annotations at startup. It will only validate the data annotations when properties change or when the view model is about to be saved. This is implemented this way to allow a developer to show required fields with an asterisk (*) instead of errors. If a developer still wants to initially display errors, only a single call has to be made in the constructor:\nValidate(true, false);  If the validation is implemented in the models and not in the view model, set the ValidateModelsOnInitialization to false.\n "},{"uri":"https://docs.catelproject.com/vnext/catel-core/apicop/rules/","title":"Rules","tags":[],"description":"","content":" Rules always belong to an *IApiCop* instance. Rules are registered once and then updated when needed, based on the requirement of the rule. Rules are normally custom-made, but Catel does provide a few base implementations.\nRegistering rules To register a rule in the IApiCop, use the following code:\nApiCop.RegisterRule(new UnusedFeatureApiCopRule(\u0026quot;UserControlLogic.InfoBarMessageControl\u0026quot;, \u0026quot;The InfoBarMessageControl is not found in the visual tree. This will have a negative impact on performance. Consider setting the SkipSearchingForInfoBarMessageControl or DefaultSkipSearchingForInfoBarMessageControlValue to true.\u0026quot;, ApiCopRuleLevel.Error, \u0026quot;https://catelproject.atlassian.net/wiki/display/CTL/Performance+considerations\u0026quot;));  The first argument is the name of the rule. This is a unique identifier and allows users to ignore rules by this name. The next parameter is a good extension which will explain to the end-developer what is wrong and why the rule is created in the first place. In this case it is about the InfoBarMessageControl which might have a negative impact on performance.\nIt is good practice to use the *ClassName*.*FeatureName* for the rule names  Updating rules Once a rule is registered, it must be updated to actually provide any useful information. How a rule must be updated depends on the rule implementation, but the code below shows how the feature can be used. This specific rule is implemented to check if the InfoBarMessageControl is actually used by the software. If it is, the counter is increased as \u0026ldquo;feature being used\u0026rdquo;, otherwise \u0026ldquo;feature not being used\u0026rdquo;.\n_infoBarMessageControl = FindParentByPredicate(TargetControl, o =\u0026gt; o is InfoBarMessageControl) as InfoBarMessageControl; ApiCop.UpdateRule\u0026lt;UnusedFeatureApiCopRule\u0026gt;(\u0026quot;UserControlLogic.InfoBarMessageControl\u0026quot;, rule =\u0026gt; rule.IncreaseCount(_infoBarMessageControl != null, TargetControlType.FullName));  This code shows the regular code executed by the framework (the search in the visual tree) and the update of the rule. Note that the update method only requires the following things: the name, a callback method and a tag. The reason a callback method is being used is that the callback will only be executed when a debugger is attached to minimize the impact on performance in production scenarios.\nIt is good practice to use the final class name as as tag (especially when the rule is registered in a base class)  Available rules Catel provides the following rules out of the box.\nUnusedFeatureApiCopRule This rule contains several counters. Each time code is executed, one must call the IncreaseCount method and specify if the feature is being used.\nUsage ApiCop.UpdateRule\u0026lt;UnusedFeatureApiCopRule\u0026gt;(\u0026quot;ruleName\u0026quot;, rule =\u0026gt; rule.IncreaseCount(isFeatureBeingUsed));  "},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/stepping-through-the-code/","title":"Stepping through the code","tags":[],"description":"","content":"It is possible to step through the source code of Catel. This will give great insights when debugging applications because you can actually see what is happening inside Catel.\nTo enable stepping through the source code, use the following steps:\n Install any Catel package via NuGet (all have support for stepping through the code) Enable source server support in Visual Studio:  Note that you must have defined a valid symbols directory in order for symbols to be stored on disk  Note that **Visual Studio 2012** needs to run elevated in order to download the source server files due to a bug in Visual Studio 2012  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/typefactory/","title":"TypeFactory","tags":[],"description":"","content":" The TypeFactory is responsible for actually creating types inside Catel. It uses the following mechanism:\n List all the constructors, order them from most parameters to least parameters While (constructors available) try to construct type using injection If all constructors fail, the TypeFactory will fallback to Activator.CreateInstance()  Dependency injection The ServiceLocator in Catel supports dependency injection.\nIntroduction to dependency injection Some people make dependency injection hard to understand, or maybe they don\u0026rsquo;t understand it themselves. Dependency injection simply means that instead of hard referencing or instantiating other classes (dependendies), the dependencies are injected into the class via the constructor.\nExample 1: bad, instantiates the dependencies itself\npublic class MyClass { private IFirstDependency _firstDependency; private ISecondDependency _secondDependency; public MyClass() { _firstDependency = new FirstDependency(); _secondDependency = new SecondDependency(); } }  Example 2: good, retrieves the dependencies via the service locator)\npublic class MyClass { private IFirstDependency _firstDependency; private ISecondDependency _secondDependency; public MyClass() { _firstDependency = ServiceLocator.Instance.ResolveType\u0026lt;IFirstDependency\u0026gt;(); _secondDependency = ServiceLocator.Instance.ResolveType\u0026lt;ISecondDependency\u0026gt;(); } }   Example 3: good, gets the dependencies injected\npublic class MyClass { private IFirstDependency _firstDependency; private ISecondDependency _secondDependency; public MyClass(IFirstDependency firstDependency, ISecondDependency secondDepdenceny) { Argument.IsNotNull(\u0026quot;firstDependency\u0026quot;, firstDependency); Argument.IsNotNull(\u0026quot;secondDependency\u0026quot;, secondDependency); _firstDependency = firstDependency; _secondDependency = secondDependency; } }  There are other ways of using dependency injection, for example via attributes. This documentation will focus on dependency injection via the constructor only  Using dependency injection in Catel Dependency injection via the ServiceLocator in Catel is enabled by default. This means that when a type is resolved from the container, it will automatically use dependency injection to construct the type if it is not registered as instance.\nIt will first search for all available constructors on the type that will be instantiated. Then, for each constructor, starting with the one with the most parameters, it will try to retrieve all values. If one fails, it will go to the next. If all fail, it will try to use the default constructor without parameters. If that fails as well, then the type cannot be constructed and an exception will be thrown.\nTo get a better understanding of what happens, see the class below:\npublic class MyClass { private IFirstDependency _firstDependency; private ISecondDependency _secondDependency; public MyClass() : this(null) { } public MyClass(IFirstDependency firstDependency) : this(firstDependency, null) { } public MyClass(IFirstDependency firstDependency, ISecondDependency secondDepdenceny) { _firstDependency = firstDependency; _secondDependency = secondDependency; } }  When the MyClass will be retrieved from the ServiceLocator, this will happen:\n Find constructor with most parameters (the one with both firstDependency and secondDependency). If both IFirstDependency and ISecondDependency can be resolved from the ServiceLocator, the type will be constructed with the constructor. Otherwise it will proceed with step 2. Find next constructor with most parameters (the one with only firstDependency). If IFirstDependency can be resolved from the ServiceLocator, the type will be constructed with the constructor. Otherwise it will proceed with step 3. At this point, no constructor could be used. In this case, the ServiceLocator will try to use the default constructor (the one without parameters) as last resort to instantiate the type.  Disabling dependency injection  Maybe you don\u0026rsquo;t want dependency injection because it does not give you what you need or you want a very, very small improvement in performance. In that case, the dependency injection can be disabled using the code below:\nServiceLocator.Default.SupportedDependencyInjection = false  Custom initialization All types created with the TypeFactory can be initialized with custom code. This can be done by implementing the INeedCustomInitialization interface. As soon as a type is created, the TypeFactory will check whether it implements the INeedCustomInitialization interface. If so, it will call the Initialize method of the interface.\nTo prevent misuse of the `Initialize` method, it is best to implement the interface explicitly  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/automatic-type-registration/using-conventions/","title":"Using conventions","tags":[],"description":"","content":" The ServiceLocator in Catel can be set up to automatically register types based on the conventions. The convention based registration should to be run first than the others registration methods to be sure to have all your types registered correctly.  Some conventions are provided by default to allow us to register types.\nRegister using Naming Convention You can want to register all types which match with the default naming convention, means when I have a *IService *interface, I expect the convention to find and register the Service class as implementation.\nTo discover types for naming convention registration, we have to simply do :\nvar serviceLocator = new ServiceLocator(); serviceLocator.RegisterTypesUsingDefaultNamingConvention();  Register using FirstInterface Convention You can want to register all types which match with the default first interface convention, means when I have a *Service *class which implements more than one interface, I expect the convention to find the first interface and use it as service registration.\nTo discover types for first interface convention registration, we have to simply do :\nvar serviceLocator = new ServiceLocator(); serviceLocator.RegisterTypesUsingDefaultFirstInterfaceConvention();  Filter types to register You have the ability to apply filtering on the registration process to exclude for example or include some types.\nExclude all types of the namespace containing the specified type If you want to exclude all types of the namespace which belong to a particular type, just do that: var serviceLocator = new ServiceLocator(); serviceLocator.RegisterTypesUsingDefaultNamingConvention() .ExcludeAllTypesOfNamespaceContaining\u0026lt;IFooService\u0026gt;();  Here, we say to the ServiceLocator to ignore all types included into the namespace which belong to the IFooService type.\nYou can manually specify the namespace of the types to exclude using the *ExcludeAllTypesOfNamespace ***** method like this: *ExcludeAllTypesOfNamespace(\"MyNamespace\")*  Exclude a specific type If you want to exclude a specific type, you can do that by using the ExcludeType method like shown below:\nvar serviceLocator = new ServiceLocator(); serviceLocator.RegisterTypesUsingDefaultNamingConvention() .ExcludeType\u0026lt;IFooService\u0026gt;();  The IFooService will be exclude on the registration process.\nExclude types using predicate You also have the possibility to filter types by using a predicate, below an example :\nvar serviceLocator = new ServiceLocator(); serviceLocator.RegisterTypesUsingDefaultNamingConvention() .ExcludeTypesWhere(type =\u0026gt; type == typeof(IFooService));  All *Exclude* methods have an *Include* version    "},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/code-snippets-templates/using-the-item-templates/","title":"Using the item templates","tags":[],"description":"","content":" There are lots of item templates available for Catel so it is really easy to develop new views very fast.\nDifference between logic in view base or behavior As you might have noticed, there are lots of \u0026ldquo;double\u0026rdquo; item templates. However, there is a substantial difference between the item templates that implement the logic in the view base or the logic in a behavior.\nShortly said, a view with the logic in the view base is defined like this:\npublic class MyView : Catel.Windows.Controls.UserControl { // rest of the class definition }  This means that the logic for MVVM is located in the view base (in this example, the UserControl).\n An item template where the logic is located in a behavior uses regular controls and uses one of the available MVVM behaviors to implement the logic. The behaviors are extremely powerful, but we still recommend the use of logic in the view base since that takes more work out of the hands from the developer.\nView model The view model is the easiest and smallest item template available. The question is even whether a new view model should be created via an item template or by using the vm code snippet.\nUser control The user control templates create a user control deriving from UserControl. First it is very important to make a decision whether the logic should be implemented in the view base or a behavior. Then, select the appropriate template:\nThe item template will assume that a view model with the same name is already created. For example, if a view with the name PersonView is created, the template assumes that the view model name is PersonViewModel. If you prefer a different naming convention, simply change the view model type name after the item has been created.\nUnfortunately, there is a bug in the item templates system of Visual Studio so it is not possible to also set the namespace of the view models to [ProjectRootNamespace].ViewModels, so this has to be done manually  Window The window templates create a window deriving from DataWindow. First it is very important to make a decision whether the logic should be implemented in the view base or a behavior. Then, select the appropriate template:\nThe item template will assume that a view model with the same name is already created. For example, if a view with the name PersonView is created, the template assumes that the view model name is PersonViewModel. If you prefer a different naming convention, simply change the view model type name after the item has been created.\nUnfortunately, there is a bug in the item templates system of Visual Studio so it is not possible to also set the namespace of the view models to [ProjectRootNamespace].ViewModels, so this has to be done manually  "},{"uri":"https://docs.catelproject.com/vnext/introduction/mvvm/validation-in-model-or-view-model/","title":"Validation in model or view model?","tags":[],"description":"","content":"I have had lots of discussion whether the validation should take place in the model or the view model. Some people think that the validation should always occur inside the model because you don’t want to persist invalid models to the persistence store. Others say that the models itself don’t need validation, but the state the view model is in requires the validation. I think both are true, and I will tell you why.\nFirst of all, you don’t want invalid models in your persistence store. Thus, the most basic checks such as type, ranges and required fields should be validated in the model. But sometimes, it is required to restrict the user more than the model does, and that’s where validation in the view model comes in handy. Another reason why you want to implement (a part of) the validation in the view model is the state of the model inside a workflow. If you have a workflow that updates the model step by step, the model isn’t valid after the first step in the workflow. However, you already want to persist the model because the user might decide to execute the following steps at a later time. You don’t want to implement the state logic of a workflow in your model (and if you did that, get rid of it, as soon as possible). This is another feature where the view model validation comes in handy.\nThe good news is that with Catel, it doesn’t matter what you want, because it’s all possible. If you want your model to do all the validation, then this is possible using the Model and ViewModelToModel attributes which map the values of the properties and the errors directly to the model so the view model acts as a proxy between the view and the model. If you want to do all of the validation inside the view model, then you can implement the ValidateFields and ValidateBusinessRules methods in the view model. And, if you want the best of both worlds, such as me, than you can use a combination of the techniques described above.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/validation/validation-via-data-annotations/","title":"Validation via data annotations","tags":[],"description":"","content":" The ViewModelBase derives from ModelBase, thus all information here also applies to the ViewModelBase  Data annotations are validation when the specific property is set. For example, when a property FirstName is set, all the data annotations on the FirstName property are validated.\nDecorating properties with data annotations Decorating properties is very simple. For example, to make a property mandatory, use the following definition (note the Required attribute):\n/// \u0026lt;summary\u0026gt; /// Gets or sets the middle name. /// \u0026lt;/summary\u0026gt; [Required] public string MiddleName { get { return GetValue\u0026lt;string\u0026gt;(MiddleNameProperty); } set { SetValue(MiddleNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the property so it is known in the class. /// \u0026lt;/summary\u0026gt; public readonly PropertyData MiddleNameProperty = RegisterProperty(\u0026quot;MiddleName\u0026quot;, typeof(string), string.Empty);  For more information about data annotations, read the official MSDN documentation .\n"},{"uri":"https://docs.catelproject.com/vnext/introduction/why-catel/","title":"Why Catel","tags":[],"description":"","content":"We care a lot about the freedom you need as a software developer. Most frameworks require a developer to learn its conventions, or use the whole framework or nothing at all. When we, the developers of Catel, use an external framework, we choose that framework for a specific reason, and don’t want to be bothered by all the other superb stuff it has to offer (maybe later, but not now).\nDuring the development of Catel, we tried to maintain this freedom aspect which is very important to us. Therefore, all functionality is loosely coupled. Sounds great, but everything is called loosely coupled nowadays. Catel contains a lot of different aspects, such as logging, diagnostics, reflection, MVVM, user controls, windows, etc. All these aspects are complementary to each other, but the great thing about Catel is that you decide whether to use just one, some, or maybe all aspects.\nAs an example: you have a legacy application and want to use the DataWindow to write simple entry windows, but you are not ready for MVVM yet. No problem, the DataWindow is complementary to MVVM, but does not require it. Therefore, you have all the freedom to use just what you need, whenever you need it.\nMost frameworks require a bootstrapper that completely decides how your application structure should look like. For example, your Views must have this name, your controls must have that name. Again, in Catel, we wanted to give you the freedom you would expect from a framework.\nThe great thing about this freedom is that the different aspects of Catel can be used side-by-side with other frameworks, so you as a developer can use the best framework for every aspect in your application.\nCatel offers a solution in the following fields:\n Data handling MVVM And much more which you will find out during the use of Catel!  "},{"uri":"https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-android/","title":"Caveats in Android","tags":[],"description":"","content":" Below are all caveats in Android.\n Linker settings  Know caveats? Feel free to add them!\nLinker settings When linking in release mode (or debug if you would like), the linker will remove all non-used items from the final application assembly. Since the binding system in Catel uses reflection, it might break when the linker is too aggressive when optimizing the app. To prevent optimalization, create a dummy file that uses the members of each type so the linker will not exclude them. Note that this class will never be instantiated, nor will its methods be invoked. It is purely to let the static analysis be notified of the usage.\nNote that this applies to both properties and bindings\nBelow is an example class to force the inclusion of members in Android. For each type and its members, a method is added. Then each used property is accessed and each used event is subscribed to.\npublic class LinkerInclude { public void IncludeActivity(Activity activity) { activity.Title = activity.Title = string.Empty; } public void IncludeButton(Button button) { button.Text = button.Text + string.Empty; button.Click += (sender, e) =\u0026gt; { }; } public void IncludeEditText(EditText editText) { editText.Text = editText.Text + string.Empty; editText.TextChanged += (sender, e) =\u0026gt; { }; } public void IncludeCommand(ICatelCommand command) { command.CanExecuteChanged += (sender, e) =\u0026gt; { }; } }  "},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/compiling-from-source/","title":"Compiling from source","tags":[],"description":"","content":"In order to compile, the following 3rd party software is required:\n Visual Studio 2017 Xamarin (if you want to compile this part)  All other libraries required are located inside the lib folder or are retrieved via NuGet.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/creating-log-listeners-via-configuration/","title":"Creating log listeners via configuration","tags":[],"description":"","content":"Starting with Catel 3.8, it is possible to instantiate LogListener classes from the configuration. Below is an example on how to customize the listeners:\n\u0026lt;configSections\u0026gt; \u0026lt;sectionGroup name=\u0026quot;catel\u0026quot;\u0026gt; \u0026lt;section name=\u0026quot;logging\u0026quot; type=\u0026quot;Catel.Logging.LoggingConfigurationSection, Catel.Core\u0026quot; /\u0026gt; \u0026lt;/sectionGroup\u0026gt; \u0026lt;/configSections\u0026gt; \u0026lt;catel\u0026gt; \u0026lt;logging\u0026gt; \u0026lt;listeners\u0026gt; \u0026lt;listener type=\u0026quot;Catel.Logging.FileLogListener\u0026quot; FilePath=\u0026quot;{AppData}\\CatelLogging.txt\u0026quot; IgnoreCatelLogging=\u0026quot;true\u0026quot; IsDebugEnabled=\u0026quot;false\u0026quot; IsInfoEnabled=\u0026quot;true\u0026quot; IsWarningEnabled=\u0026quot;true\u0026quot; IsErrorEnabled=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;/listeners\u0026gt; \u0026lt;/logging\u0026gt; \u0026lt;/catel\u0026gt;  It is important to register the logging section as shown in the example above. Then the logging section in the bottom can contain an unlimited number of listeners. Each listener has to provide at least the type property which contains the type and namespace of the ILogListener which must be added:\n\u0026lt;listener type=\u0026quot;Catel.Logging.FileLogListener\u0026quot; /\u0026gt;  The other properties are fully customizable and can be defined on the fly. This means that the configuration is fully customizable for every listener that needs to be added. Below is an example to register the FileLogListener via configuration:\n\u0026lt;listener type=\u0026quot;Catel.Logging.FileLogListener\u0026quot; FilePath=\u0026quot;CatelLogging.txt\u0026quot; IgnoreCatelLogging=\u0026quot;true\u0026quot; IsDebugEnabled=\u0026quot;false\u0026quot; IsInfoEnabled=\u0026quot;true\u0026quot; IsWarningEnabled=\u0026quot;true\u0026quot; IsErrorEnabled=\u0026quot;true\u0026quot;/\u0026gt;  The *ILogListener *properties (IsDebugEnabled, IsInfoEnabled, IsWarningEnabled and IsErrorEnabled) are available to all listeners. All other properties depend on the the actual listener being registered. This allows major flexibility at runtime.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/dependencyresolver/","title":"DependencyResolver and DependencyResolverManager","tags":[],"description":"","content":" Introduction to Managing different scoping of service locators and dependency injection can be hard. To aid developers with this, the IDependencyResolver and DependencyResolverManager are introduced.\nWhy the need for a DependencyResolver That\u0026rsquo;s a good question. Catel already provides the IServiceLocator which allows to resolve types. The downside is that if you want to customize the way dependencies are resolved in Catel, you will have to implement a custom version of the ServiceLocator. To make it simple to customize this behavior, the DependencyResolver is introduced.\nThe main strategy will be to use the `DependencyResolver` instead of `ServiceLocator` to resolve the types in Catel, starting with version 3.8  Though in simple situations, Catel will resolve and inject all types automatically, there are a few exceptions to the rule. One of these exceptions are extension methods. These are static classes which can be used to add functionality to an object. The downside is that you cannot use dependency injection in static classes, and each object that is extended can have their own scoping of dependency resolvers. To solve this issue, Catel introduces the DependencyResolverManager. This is a manager that keeps track of all types and objects and the DependencyResolver that were used to create the object. This way it is still possible to retrieve additional dependencies in extensions methods in the same dependency resolver the type was created with.\nTo illustrate this issue, take a look at the view model below:\n// Set up a different scoping with a custom service locator var serviceLocator = new ServiceLocator(); // ... register custom services here var typeFactory = serviceLocator.ResolveType\u0026lt;ITypeFactory\u0026gt;(); var vm = typeFactory.CreateInstance\u0026lt;MyViewModel\u0026gt;();  In this example, a view model is created with a custom dependency scope. When writing an extension method for the view models, it is impossible to get to this custom scope:\npublic static class MyViewModelExtensions { public static void DoSomething(this MyViewModel myViewModel) { // You can use ServiceLocator.Default here, but that is a `different and wrong` scope var additionalDependency = ServiceLocator.Default.ResolveType\u0026lt;IAdditionalDependency\u0026gt;(); } }  One option to solve this is to create a property on the view model called DependencyResolver or ServiceLocator. However, it is not the responsibility of the view model to store this property. In fact, the view model does not know which scoping was used to create itself. The only way to solve this is to inject the IServiceLocator into the view model, but that\u0026rsquo;s not a good practice.\nBelow is a rewritten version of the extensions class which uses the DependencyResolverManager:\npublic static class MyViewModelExtensions { public static void DoSomething(this MyViewModel myViewModel) { // Get the `right` scope var dependencyResolverManager = DependencyResolverManager.Default; var dependencyResolver = dependencyResolverManager.GetDependencyResolverForInstance(myViewModel); var additionalDependency = dependencyResolver.Resolve\u0026lt;IAdditionalDependency\u0026gt;(); } }  Now you have the actual IDependencyResolver that was use to create the view model and can easily provide the right logic with the right scoping.\nNote that there will only be a single instance of a `DependencyResolverManager`. It is possible to customize the default instance, but there is no need for different scoping of `DependencyResolverManager` instances so it is valid to use the static instance  Managing the dependency resolvers per instance The DependencyResolverManager can manage dependency resolvers per instance. This way it is possible to retrieve the actual dependency resolver for a specific object instance.\nRegistering a dependency resolver for an instance To register a dependency resolver for an instance, use this code:\nvar serviceLocator = new ServiceLocator(); var dependencyResolver = new CatelDependencyResolver(serviceLocator); var myObject = new MySpecialObject(); var dependencyResolverManager = DependencyResolverManager.Default; dependencyResolverManager.RegisterDependencyResolverForInstance(myObject, dependencyResolver);  Note that it is not required to register a `DependencyResolver` for instances created with the `TypeFactory`. The `TypeFactory` automatically registers the `DependencyResolver` used in the `DependencyResolverManager`.  Retrieving a dependency resolver for an instance To retrieve the dependency resolver for a specific instance, use this code:\nvar dependencyResolverManager = DependencyResolverManager.Default; var dependencyResolver = dependencyResolverManager.GetDependencyResolverForInstance(myObject);  Below is a graph that shows how the dependency resolver of an instance is determined:\nManaging the dependency resolvers per type The DependencyResolverManager can manage dependency resolvers per type. This way it is possible to retrieve the actual dependency resolver for a specific type.\nRegistering a dependency resolver for a type To register a dependency resolver for a type, use this code:\nvar serviceLocator = new ServiceLocator(); var dependencyResolver = new CatelDependencyResolver(serviceLocator); var dependencyResolverManager = DependencyResolverManager.Default; dependencyResolverManager.RegisterDependencyResolverForType(typeof(MyClass), dependencyResolver);  Note that these registrations are type-specific. You cannot register an interface and all classes deriving from that interface will return the same `DependencyResolver`. All actual types must be registered separately.  Retrieving a dependency resolver for a type To retrieve the dependency resolver for a specific instance, use this code:\nvar dependencyResolverManager = DependencyResolverManager.Default; var dependencyResolver = dependencyResolverManager.GetDependencyResolverForType(typeof(MyClass));  Customizing the default DependencyResolver By default, the DependencyResolverManager creates a CatelDependencyResolver that wraps the ServiceLocator.Default instance. In simple applications this is sufficient to get everything working. However sometimes it might be needed to customize the default DependencyResolver. To change the default one, use the code below:\nvar dependencyResolverManager = DependencyResolverManager.Default; dependencyResolverManager.DefaultDependencyResolver = new MyCustomDependencyResolver();  Customizing the DependencyResolverManager Customizing the DependencyResolverManager is not recommended. If you still want to do this for whatever reason, create a class implementing the IDependencyResolverManager or derive from the DependencyResolverManager:\npublic class CustomizedDependencyResolverManager : DependencyResolverManager { public override IDependencyResolver GetDependencyResolverForType(Type type) { if (type == typeof(MySpecialClass)) { return new MySpecialDependencyResolver(); } return base.GetDependencyResolverForType(type); } }  Note that there is no use to override the `DependencyResolverManager` as the example, but this keeps it easy to understand  Then set the DependencyResolverManager.Default static property:\nDependencyResolverManager.Default = new CustomizedDependencyResolverManager();  "},{"uri":"https://docs.catelproject.com/vnext/getting-started/xamarin-forms/","title":"Getting started with Xamarin.Forms","tags":[],"description":"","content":"Welcome to the *Getting started* guide for Catel and Xamarin.Forms. In this guide, a very simple application will be created with the most commonly used aspects of Catel and Xamarin.Forms.\nNote that this guide assumes that the reader has a basic understanding of XAML and Xamarin.Forms since this guide will not cover these basics\nThe source code for this example can be found at https://github.com/Catel/Catel.GettingStarted.Xamarin.Forms\nNote that this guide will recommend code snippets that can be found here. They are not required, just recommended to speed up creating Catel classes and properties.\n Creating the Xamarin.Forms project   This documentation is work in progress\n"},{"uri":"https://docs.catelproject.com/vnext/introduction/mvvm/introduction-to-mvvm-and-models/","title":"Introduction to MVVM and models","tags":[],"description":"","content":" This part of the documentation will explain all the parts of MVVM, in the order in which we think they must be built. First of all, the Models, which are the closest to the business. Then, the View Models which define what part of the Models should be visible to the user in a specific situation. This also includes validation that is specific for the functionality that the View Model represents. Last, but not least, the View itself, which is the final representation of the View Model to the end-user.\nAs you will notice (or maybe you don\u0026rsquo;t), this framework has a lot in common with other MVVM frameworks out there. This is normal because all of the frameworks are trying to implement the same pattern, which isn\u0026rsquo;t that hard to understand if you think about it long enough. Before we started writing the MVVM framework, we first investigated other frameworks because there already are enough, probably too many. However, even the better (or best) still took too much time to use, and there was too much code we had to write to create a View Model. That\u0026rsquo;s the point where we decided to write our own framework that contains lots of luxury for lazy developers such as us.\nModels The Models part is one of the three major parts of MVVM. Therefore, I want to tell you a bit about what kind of Models we use to store our data. Basically, you can use all types of objects as Models, as long as the Models implement the most commonly used interfaces.\nFor MVVM, it is very important that the following interfaces are implemented:\n INotifyPropertyChanged If this interface is not implemented, changes will not be reflected to the UI via bindings. In other words, your Model and View Model will be useless in an MVVM setting.  Finally, it is strongly recommended to have your Models implement the following interfaces as well:\n IDataErrorInfo If this interface is not implemented, errors cannot be shown to the user. IEditableObject If this interface is not implemented, a Model cannot work with “states”. This means that a user cannot start editing an object and finally cancel it (because there is no stored “state” that can be used to restore the values).  View Models View models are the classes that contain the view logic. They can be seen as a container for all models in a specific view, including the behavior to interact with these models (for example adding or removing them from a collection). It is very important that a view model also implements the INotifyPropertyChanged interfaces just like the models do.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/apicop/listeners/","title":"Listeners","tags":[],"description":"","content":" Listeners are a way to get information about the cops and their rules in the framework. The *ApiCopManager* will take care of all the retrieval of the results and the registration of the cops. The registered listeners are used by the *ApiCopManager.WriteResults* method to write the output to. To add a listener and be able to see the output of the *ApiCop* feature, use the following code:\nvar apiCopListener = new ConsoleApiCopListener(); ApiCopManager.AddListener(apiCopListener);  After the listeners are added, one can call ApiCopManager.WriteResults:\nApiCopManager.WriteResults();  Customizing grouping It is possible to group the listeners. To specify the grouping, use the following code:\nvar apiCopListener = new ConsoleApiCopListener(); apiCopListener.Grouping = ApiCopListenerGrouping.Rule;  The following grouping options are available:\n   Grouping name Description     Cop Sort by the name of the class in which the cop is registered.   Rule Sort by the rule name.   Tag Sort by tag, which is dependent on the rule implementation. It is recommended though to use the final class name as tag.    Creating custom listeners Catel provides several listeners out of the box. To create custom listeners, the only requirement is to implement the IApiCopListener. To make it easier to create custom listeners (such as an HTML listener), Catel provides the following base classes which can also be used as a base for custom listeners:\n ApiCopListenerBase Gives most flexibility, but is also more work to implement  TextApiCopListenerBase Is fully prepared for all text-based listeners (such as console, text file, etc), and only requires the implementation of the WriteLine method    "},{"uri":"https://docs.catelproject.com/vnext/catel-core/messaging/messaging-via-attributes/","title":"Messaging via attributes","tags":[],"description":"","content":" The message mediator is a great way to communicate between instances in an application. It does however require to manually subscribe to and unsubscribe from classes. This issue can be bypassed using the attribute based approach. This is an alternative for registering a method in the message mediator and not be obliged to use Register\u0026lt;T\u0026gt; method.\nSubscribing and unsubscribing  When attributes are using inside a class, it is required to call the MessageMediatorHelper.SubscripeRecipient. To unsubscribe an object, it is required to call MessageMediatorHelper.UnsubscribeRecipient.\nThere are two options to decorate methods with the attribute. Either with or without tag.\nSubscribing without a tag In this case, the mediator will send the message to all the methods that has subscribe using the attribute to receive the message and not one especially. The code below broadcasts a message without any tag. This is just regular behavior of the message mediator.\n/// \u0026lt;summary\u0026gt; /// Method to invoke when the command is executed. /// \u0026lt;/summary\u0026gt; private void OnCmdExecute() { var dependencyResolver = this.GetDependencyResolver(); var mediator = dependencyResolver.Resolve\u0026lt;IMessageMediator\u0026gt;(); mediator.SendMessage(\u0026quot;Test Value\u0026quot;); }  If a class, for example a view model, is interested in these messages, the only thing that needs to be done is to decorate a method with the MessageRecipient attribute as shown below:\n/// \u0026lt;summary\u0026gt; /// Shows the message. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;value\u0026quot;\u0026gt;The value.\u0026lt;/param\u0026gt; [MessageRecipient] private void ShowMessage(string value) { var dependencyResolver = this.GetDependencyResolver(); var messageService = dependencyResolver.Resolve\u0026lt;IMessageService\u0026gt;(); messageService.Show(value); }  Subscribing with a tag  A tag can be used to specify some sort of grouping for messages. The MessageRecipient attribute also supports this as shown in the code below. First lets take a look how to send a message and specify a tag.\n/// \u0026lt;summary\u0026gt; /// Method to invoke when the command is executed. /// \u0026lt;/summary\u0026gt; private void OnCmdExecute() { var dependencyResolver = this.GetDependencyResolver(); var mediator = dependencyResolver.Resolve\u0026lt;IMessageMediator\u0026gt;(); mediator.SendMessage(\u0026quot;Test Value\u0026quot;, \u0026quot;myTag\u0026quot;); }  The message is now sent with the tag. The attribute has to be used as shown below:\n/// \u0026lt;summary\u0026gt; /// Shows the message. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;value\u0026quot;\u0026gt;The value.\u0026lt;/param\u0026gt; [MessageRecipient(Tag = \u0026quot;myTag\u0026quot;)] private void ShowMessage(string value) { var dependencyResolver = this.GetDependencyResolver(); var messageService = dependencyResolver.Resolve\u0026lt;IMessageService\u0026gt;(); messageService.Show(value); }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/data-handling/modelbase/","title":"ModelBase","tags":[],"description":"","content":" The ModelBase class is a generic base class that can be used for all your data classes.\n Fully serializable It is now really easy to store objects on disk or serialize them into memory, either binary or in XML. The data object supports this out of the box, and automatically handles the (de)serialization. Support property changed notifications The class supports the INotifyPropertyChanging and INotifyPropertyChanged interfaces so this class can easily be used in applications to reflect changes to the user. Backwards compatibility When serializing your objects to binary, it is hard to maintain the right versions. When you add a new property to a binary class, or change a namespace, the object cannot be loaded any longer. The data object base takes care of this issue and supports backwards compatibility. Backup \u0026amp; revert The class implements the IEditableObject interface which makes it possible to create a state of the object. Then all properties can be edited, and finally, the changes can be applied or cancelled.  Using the class Using the class is extremely simple. Just declare a new class that derives from ModelBase and you are ready to go:\n/// \u0026lt;summary\u0026gt; /// MyObject class which fully supports serialization, /// property changed notifications, backwards compatibility and error checking. /// \u0026lt;/summary\u0026gt; [Serializable] public class MyObject : ModelBase\u0026lt;MyObject\u0026gt; { /// \u0026lt;summary\u0026gt; /// Initializes a new object from scratch. /// \u0026lt;/summary\u0026gt; public MyObject() { } /// \u0026lt;summary\u0026gt; /// Initializes a new object based on \u0026lt;see cref=\u0026quot;SerializationInfo\u0026quot;/\u0026gt;. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;info\u0026quot;\u0026gt;\u0026lt;see cref=\u0026quot;SerializationInfo\u0026quot;/\u0026gt; // that contains the information.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;context\u0026quot;\u0026gt;\u0026lt;see cref=\u0026quot;StreamingContext\u0026quot;/\u0026gt;.\u0026lt;/param\u0026gt; protected MyObject(SerializationInfo info, StreamingContext context) : base(info, context) { } }  As you can see in the code above, the MyObject class derives from ModelBase and provides an empty constructor, but also a constructor that is used for binary deserialization. The code above might look complex, but it is created using the model code snippet, and you only have to type the name of the class.\nDefining properties Defining properties for the class is very easy, and works the same like dependency properties. The advantages of this way of defining properties are:\n Properties defined like this are automatically included during serialization; no need to specify complex data contracts; You can specify a default value for a property which will be used when the class is constructed or the property is not found during deserialization (in case this property is added to an existing class); The PropertyData object can be used to retrieve property values so the compiler checks for errors; You can directly subscribe to change notifications, and all properties automatically support INotifyPropertyChanged out of the box.  Below is the code that defines a new property Name of type string:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the name. /// \u0026lt;/summary\u0026gt; public string Name { get { return GetValue\u0026lt;string\u0026gt;(NameProperty); } set { SetValue(NameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Name property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData NameProperty = RegisterProperty(\u0026quot;Name\u0026quot;, typeof(string), string.Empty);  A registered property can be excluded from serialization if wanted. When the object is deserialized, the default value will be used for the property in that case.\nDefault values for reference types In lots of cases, a default value for reference types is required in the property definitions. However, and you might have noticed this behavior in for example dependency properties, using an instance as default value can result in unexpected behavior.\nBelow is an example of a \u0026ldquo;regular\u0026rdquo; property registration using a default value for a collection property:\npublic static readonly PropertyData NameProperty = RegisterProperty(\u0026quot;PersonCollection\u0026quot;, typeof(Collection\u0026lt;Person\u0026gt;), new Collection\u0026lt;Person\u0026gt;());  However, instead of creating a new collection for each new object with this property, only one collection will be created that will be used by all classes that have this property registered. One solution is to pass null as default value and create the collection in the constructor. A better solution is to use the override of RegisterProperty with the callback parameters:\npublic static readonly PropertyData NameProperty = RegisterProperty(\u0026quot;PersonCollection\u0026quot;, typeof(Collection\u0026lt;Person\u0026gt;), () =\u0026gt; new Collection\u0026lt;Person\u0026gt;());  This way, every time a new value is needed, the callback will be invoked to create the default value and you will have a true default value for reference types.\nFunctionality provided out of the box The ModelBase provides a lot of functionality out of the box. A few points I want to mention are:\nINotifyPropertyChanged\nAll properties registered using the RegisterProperty method automatically take care of change notifications.\nIEditableObject\nThe data object can automatically create an internal backup and restore it, if required, using the IEditableObject interface.\nSerialization\nAs told many times before, using the [SavableModelBase](/vnext/catel-core/data-handling/savablemodelbase/), you can simply save your file to a stream (file on disk, stream in memory, etc.).\nKeep in mind that this class is not suitable for database communication, there are much better ways to handle this (ORM mappers such as Entity Framework, NHibernate, LLBLGen Pro, etc.).\n"},{"uri":"https://docs.catelproject.com/vnext/faq/problem-solving/","title":"Problem solving","tags":[],"description":"","content":" As with every framework or toolkit, developers run into problems. This can be bugs or abuse of the API. Catel has several ways for developers to solve the problems themselves before contacting the team with the possible issue.\nEnabling the log We take logging very serious in Catel. This means that a lot of information about the internals can be be seen in the output window. To enable logging in Catel, use the following code in your application startup code:\n#if DEBUG Catel.Logging.LogManager.AddDebugListener(); #endif  Now you can see all the log messages in the output window.\nEnabling stepping through the code It\u0026rsquo;s possible to step through the Catel code to see what is happening in the internals of Catel. This gives you great insights in Catel and can help you solve the problems you are encountering. See the stepping through the code documentation.\nApiCop Catel provides a feature called ApiCop. This will give you information about the most cases where the API of Catel is abused or not used in the right way. The ApiCop feature will create an advisory report at the end of an application with tips on how to improve the feature usage in Catel. Below is an example report:\n**************************************************************** ApiCop (r) results of 'DataWindowTest.WPF' v1.0.0.0 recorded on 2014-02-19 10:06 To ignore rules, call ApiCopManager.IgnoredRules.Add([rulename]); For more information about ApiCop, visit the website: https://catelproject.atlassian.net/wiki/display/CTL/ApiCop **************************************************************** ================================================================ DATAWINDOWTEST.VIEWS.AVIEW ================================================================ Cop TargetType: Catel.Windows.Controls.MVVMProviders.Logic.UserControlLogic Rule: UserControlLogic.InfoBarMessageControl (Error) For more information about this rule, visit https://catelproject.atlassian.net/wiki/display/CTL/Performance+considerations [DataWindowTest.Views.AView] Feature used '0' of '2' times, consider turning it off by default ---------------------------------------------------------------- Cop TargetType: Catel.Windows.Controls.MVVMProviders.Logic.UserControlLogic Rule: UserControlLogic.CreateWarningAndErrorValidator (Error) For more information about this rule, visit https://catelproject.atlassian.net/wiki/display/CTL/Performance+considerations [DataWindowTest.Views.AView] Feature used '0' of '2' times, consider turning it off by default ---------------------------------------------------------------- ================================================================ DATAWINDOWTEST.VIEWS.BVIEW ================================================================ Cop TargetType: Catel.Windows.Controls.MVVMProviders.Logic.UserControlLogic Rule: UserControlLogic.InfoBarMessageControl (Error) For more information about this rule, visit https://catelproject.atlassian.net/wiki/display/CTL/Performance+considerations [DataWindowTest.Views.BView] Feature used '0' of '2' times, consider turning it off by default ---------------------------------------------------------------- Cop TargetType: Catel.Windows.Controls.MVVMProviders.Logic.UserControlLogic Rule: UserControlLogic.CreateWarningAndErrorValidator (Error) For more information about this rule, visit https://catelproject.atlassian.net/wiki/display/CTL/Performance+considerations [DataWindowTest.Views.BView] Feature used '0' of '2' times, consider turning it off by default ---------------------------------------------------------------- **************************************************************** End of ApiCop (r) results, generation took '00:00:00.137' ****************************************************************  For more information, see the ApiCop documentation.\n "},{"uri":"https://docs.catelproject.com/vnext/getting-started/wpf/serializing-data-from-to-disk/","title":"Serializing data from/to disk","tags":[],"description":"","content":" In this step we will create services that will serialize the models from/to disk. Services are a great way to abstract functionality that can be used in every part of the application. This guide will also register the service in the ServiceLocator so it can be injected in view models.\nCreating the service definition The first thing to do is to create the Services folder to group the services. Below is a screenshot of how to solution will look after creating the folders:\nThen add a new interface to the Interfaces folder named IFamilyService. This will manage the families that are avaiable. Below is the interface defined:\nnamespace WPF.GettingStarted.Services { using WPF.GettingStarted.Models; public interface IFamilyService { IEnumerable\u0026lt;Family\u0026gt; LoadFamilies(); void SaveFamilies(IEnumerable\u0026lt;Family\u0026gt; families); } }  Creating the service implementation Below is the implementation of the service which will actually take care of saving and loading of the families:\nnamespace WPF.GettingStarted.Services { using System.Collections.Generic; using System.IO; using Catel.Collections; using Catel.Data; using WPF.GettingStarted.Models; public class FamilyService : IFamilyService { private readonly string _path; private readonly IXmlSerializer _xmlSerializer; public FamilyService(IXmlSerializer xmlSerializer) { Argument.IsNotNull(() =\u0026gt; xmlSerializer); _xmlSerializer = xmlSerializer; string directory = Catel.IO.Path.GetApplicationDataDirectory(\u0026quot;CatenaLogic\u0026quot;, \u0026quot;WPF.GettingStarted\u0026quot;); _path = Path.Combine(directory, \u0026quot;family.xml\u0026quot;); } public IEnumerable\u0026lt;Family\u0026gt; LoadFamilies() { if (!File.Exists(_path)) { return new Family[] { }; } using (var fileStream = File.Open(_path, FileMode.Open)) { var settings = _xmlSerializer.Deserialize\u0026lt;Settings\u0026gt;(fileStream); return settings.Families; } } public void SaveFamilies(IEnumerable\u0026lt;Family\u0026gt; families) { var settings = new Settings(); settings.Families.ReplaceRange(families); using (var fileStream = File.Open(_path, FileMode.Create)) { _xmlSerializer.Serialize(settings, fileStream); } } } }  Registering the service in the ServiceLocator Now we have created the service, it is time to register it in the ServiceLocator. In the App.xaml.cs, add the following code:\nvar serviceLocator = ServiceLocator.Default; serviceLocator.RegisterType\u0026lt;IFamilyService, FamilyService\u0026gt;();  Adding the service usage to the MainWindowViewModel Now the service is registered, it can be used anywhere in the application. A great place to load and save the families is in the MainWindowViewModel which contains all the logic of the main application window. Injecting the service via dependency injection To get an instance of the service in the view model, change the constructor to the following definition.\nprivate readonly IFamilyService _familyService; /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;MainWindowViewModel\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; public MainWindowViewModel(IFamilyService familyService) { Argument.IsNotNull(() =\u0026gt; familyService); _familyService = familyService; }  As you can see in the code above, a new field is created to store the dependency IFamilyService. Then the constructor ensures that the argument is not null and stores it in the field.\nCreating the Families property on the MainWindowViewModel The next thing we need is a Families property on the MainWindowViewModel to store the families in we load from disk. Below is the property definition for that:\n/// \u0026lt;summary\u0026gt; /// Gets the families. /// \u0026lt;/summary\u0026gt; public ObservableCollection\u0026lt;Family\u0026gt; Families { get { return GetValue\u0026lt;ObservableCollection\u0026lt;Family\u0026gt;\u0026gt;(FamiliesProperty); } private set { SetValue(FamiliesProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Families property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FamiliesProperty = RegisterProperty(\u0026quot;Families\u0026quot;, typeof(ObservableCollection\u0026lt;Family\u0026gt;), null);  Loading the families at startup Now we have the IFamilyService and the Families property, it is time to combine these two. To do this, we need to override the InitializeAsync method on the view model which is automatically called as soon as the view is loaded by Catel:\nprotected override async Task InitializeAsync() { var families = _familyService.LoadFamilies(); Families = new ObservableCollection\u0026lt;Family\u0026gt;(families); }  Saving the families at shutdown To save the families at shutdown, override the CloseAsync method on the view model which is automatically called as soon as the view is closed by Catel:\nprotected override async Task CloseAsync() { _familyService.SaveFamilies(Families); }  After running the application once, a new file will be stored in the following directory:\nC:\\Users\\[yourusername]\\AppData\\Roaming\\CatenaLogic\\WPF.GettingStarted\nUp next Creating the view models\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/serializing-members-using-tostring-parse/","title":"Serializing members using ToString / Parse","tags":[],"description":"","content":"Sometimes types (classes or structs) don\u0026rsquo;t implement a proper serialization mechanism. If they support proper ToString(IFormatProvider) and Parse(string, IFormatProvider) methods, there is no need to create a custom SerializerModifier to serialize these types. To let the serializers take care of this automatically, at least one of the following options must be true:\n The member is decorated using the SerializeUsingParseAndToString attribute The container class has a SerializerModifier that returns true in the ShouldSerializeMemberUsingParse method  Note that decorating a member that does not implement proper *ToString(IFormatProvider)* and *Parse(string, IFormatProvider)* methods is useless, the serialization engine will ignore these types  For example, the class below is an excellent usage example of when to use this technique:\n [Serializable, StructLayout(LayoutKind.Sequential, Pack = 1)] public struct Vector { public double X; public double Y; public double Z; public Vector(double x, double y, double z) { X = x; Y = y; Z = z; } public string ToString(IFormatProvider formatProvider) { return $\u0026quot;{X.ToString(formatProvider)} {Y.ToString(formatProvider)} {Z.ToString(formatProvider)}\u0026quot;; } public static Vector Parse(string value, IFormatProvider formatProvider) { var splitted = value.Split(new[] { \u0026quot; \u0026quot; }, StringSplitOptions.RemoveEmptyEntries); var x = double.Parse(splitted[0], formatProvider); var y = double.Parse(splitted[1], formatProvider); var z = double.Parse(splitted[2], formatProvider); var vector = new Vector(x, y, z); return vector; } }  "},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/","title":"Setup, deployment &amp; projects","tags":[],"description":"","content":" Getting prerelease (beta) versions via NuGet \u0026amp; MyGet   Stepping through the code   Compiling from source   Code snippets \u0026amp; templates   Update guides   "},{"uri":"https://docs.catelproject.com/vnext/introduction/platform-support/","title":"Support for multiple platforms","tags":[],"description":"","content":" Catel is available on a lot of platforms.\nXaml  WPF 4.5 WPF 4.6 WPF 4.7 UWP 10.0  Android  Android 4.0+ (Xamarin)  iOS  iOS 6.0+ (Xamarin)  Fundamental differences There are some fundamental differences between platforms (such as Xaml and Android). The table below explains the differences so it is easy to understand for a developer what to use when. Note that all services are defined by interfaces and can be used on all the platforms in the same manner. The platform-specific implementations are hidden as much as possible to keep the view models very re-usable.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/serialization/supported-serializers/","title":"Supported serializers","tags":[],"description":"","content":" Binary   Json   Xml   "},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/code-snippets-templates/using-the-project-templates/","title":"Using the project templates","tags":[],"description":"","content":" There are several project templates available for Catel. The easiest way is to follow these steps.\nUsing the project templates Create a new project. Make sure that at least .NET Framework 4.0 is selected as target framework. The templates can be found under the Catel folder as shown in the image below:\nAs soon as the project is created, the only thing left to do is add references to the Catel libraries. You can either do this manually or use NuGet.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/validation/validation-via-special-model-validators/","title":"Validation via special model validators","tags":[],"description":"","content":" By default, Catel registers the AttributeValidatorProvider as the IValidatorProvider. This way the ModelBase and all the classes that derive from it can easily add a custom validator by using the ValidateModelAttribute.\nNote that it is still possible to register a custom *IValidatorProvider* to customize this behavior. It is even possible to set the *Validator* property of the *ModelBase* on a specific instance of a model  Implementing the validator The first thing that needs to be done is to write a custom implementation of the IValidator interface. You can either implement all the members yourself or derive from *ValidatorBase *as is shown below:\npublic class PersonValidator : ValidatorBase\u0026lt;PersonModel\u0026gt; { protected override void ValidateFields(PersonModel instance, List\u0026lt;IFieldValidationResult\u0026gt; validationResults) { if (string.IsNullOrWhiteSpace(instance.FirstName)) { validationResults.Add(FieldValidationResult.CreateError(PersonModel.FirstNameProperty, \u0026quot;First name is required\u0026quot;)); } if (string.IsNullOrWhiteSpace(instance.LastName)) { validationResults.Add(FieldValidationResult.CreateError(PersonModel.FirstNameProperty, \u0026quot;First name is required\u0026quot;)); } } protected override void ValidateBusinessRules(PersonModel instance, List\u0026lt;IBusinessRuleValidationResult\u0026gt; validationResults) { // No business rules validations yet } }  Decorating a model with the attribute\nOnce a validator is available, the only thing that needs to be done is to decorate the model with the ValidateModelAttribute:\n[ValidateModel(typeof(PersonValidator))] public class PersonModel : ModelBase { public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string), string.Empty); public string LastName { get { return GetValue\u0026lt;string\u0026gt;(LastNameProperty); } set { SetValue(LastNameProperty, value); } } public static readonly PropertyData LastNameProperty = RegisterProperty(\u0026quot;LastName\u0026quot;, typeof(string), string.Empty); }  The custom validator will now automatically be called.\n"},{"uri":"https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-ios/","title":"Caveats in iOS","tags":[],"description":"","content":"Below are all caveats in iOS.\nKnow caveats? Feel free to add them!\n"},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/code-snippets-templates/","title":"Code snippets &amp; templates","tags":[],"description":"","content":" The latest code snippets and templates are available on the official website. When downloaded, follow the steps below to install them.\nInstalling the code snippets Extract the zip file to the following directory: %MyDocuments%\\Visual Studio 2xxx\\Code Snippets\nInstalling the item and project templates C#\nExtract the zip\\C#\\ItemTemplates to the following directory: %MyDocuments%\\Visual Studio 2xxx\\Templates\\ItemTemplates\\Visual C#\n*Extract the *zip\\C#\\ProjectTemplates to the following directory: %MyDocuments%\\Visual Studio 2xxx\\Templates\\ProjectTemplates\\Visual C#**\n** **\nIt's possible that you need to restart Visual Studio for it to recognize the templates  "},{"uri":"https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-view-models/","title":"Creating the view models","tags":[],"description":"","content":" In this step we will create the view models. Since this is a very simple application, just a few view models are required. A view model in essence is nothing more than a class that derives from the ViewModelBase class\nThe *vm* code snippet is available to create view models. There is also an on-line item template available for Catel view models  Creating the PersonViewModel Below is the class definition of the PersonViewModel. This view model will be used to show the details of a Person model.\nnamespace WPF.GettingStarted.ViewModels { using Catel.MVVM; public class PersonViewModel : ViewModelBase { } }  Enabling model injection In hierarchy views, it is important to manage the state of views and view models based on the actual context where the view (thus view model) is located. Catel does this by allowing model injection. The view models will only be created when the model is available within the context of the view.\npublic class PersonViewModel : ViewModelBase { public PersonViewModel(Person person) { Argument.IsNotNull(() =\u0026gt; person); Person = person; } /// \u0026lt;summary\u0026gt; /// Gets or sets the person. /// \u0026lt;/summary\u0026gt; [Model] public Person Person { get { return GetValue\u0026lt;Person\u0026gt;(PersonProperty); } set { SetValue(PersonProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Person property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData PersonProperty = RegisterProperty(\u0026quot;Person\u0026quot;, typeof(Person), null); }  Note that the `Person` property is decorated with the `Model` attribute. This automatically makes sure that if a view model is saved, the `IEditableObject.EndEdit` is called. When the view model is canceled, the `IEditableObject.CancelEdit` is called and all changes on the model will be reverted.  Exposing properties of a model One very powerful feature of Catel is that it can automatically map properties from a model to a view model. This way the user does not have to write repetitive code to map the properties from the model to the view model at startup and map the properties from view model to model when the view model is closed. Catel will take care of this all automatically.\n/// \u0026lt;summary\u0026gt; /// Gets or sets the first name. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Person\u0026quot;)] public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FirstName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string), null); /// \u0026lt;summary\u0026gt; /// Gets or sets the last name. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Person\u0026quot;)] public string LastName { get { return GetValue\u0026lt;string\u0026gt;(LastNameProperty); } set { SetValue(LastNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the LastName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData LastNameProperty = RegisterProperty(\u0026quot;LastName\u0026quot;, typeof(string), null);  Note that the properties are decorated with the *ViewModelToModel* attribute which enables the automatic mappings feature in Catel.  Creating the FamilyViewModel The FamilyViewModel must be set up the same way as the PersonViewModel above.\nnamespace WPF.GettingStarted.ViewModels { using System.Collections.ObjectModel; using Catel; using Catel.Data; using Catel.MVVM; using WPF.GettingStarted.Models; public class FamilyViewModel : ViewModelBase { public FamilyViewModel(Family family) { Argument.IsNotNull(() =\u0026gt; family); Family = family; } /// \u0026lt;summary\u0026gt; /// Gets the family. /// \u0026lt;/summary\u0026gt; [Model] public Family Family { get { return GetValue\u0026lt;Family\u0026gt;(FamilyProperty); } private set { SetValue(FamilyProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Family property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FamilyProperty = RegisterProperty(\u0026quot;Family\u0026quot;, typeof(Family), null); /// \u0026lt;summary\u0026gt; /// Gets the family members. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Family\u0026quot;)] public ObservableCollection\u0026lt;Person\u0026gt; Persons { get { return GetValue\u0026lt;ObservableCollection\u0026lt;Person\u0026gt;\u0026gt;(PersonsProperty); } private set { SetValue(PersonsProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Persons property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData PersonsProperty = RegisterProperty(\u0026quot;Persons\u0026quot;, typeof(ObservableCollection\u0026lt;Person\u0026gt;), null); /// \u0026lt;summary\u0026gt; /// Gets or sets the family name. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Family\u0026quot;)] public string FamilyName { get { return GetValue\u0026lt;string\u0026gt;(FamilyNameProperty); } set { SetValue(FamilyNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FamilyName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FamilyNameProperty = RegisterProperty(\u0026quot;FamilyName\u0026quot;, typeof(string)); } }  Up next Creating the views (user controls)\n"},{"uri":"https://docs.catelproject.com/vnext/introduction/mvvm/creating-view-models-with-catel/","title":"Creating view models with Catel","tags":[],"description":"","content":" The View Models in Catel are very easy to write, and give the end-user a great flexibility in how to approach the Models. This part of the article will explain the classes that make it possible to easily create View Models.\nThe ViewModelBase class is the most important class of all in the MVVM Framework of Catel. Of course, it can\u0026rsquo;t do anything useful without the other classes, but all the View Models that are created using Catel derive of this class. ViewModelBase is based on the ModelBase class that ships with Catel. Thanks to the existence of that class, the MVVM framework was set up very quickly (although “very quickly” is relative). Below is a class diagram that shows the class tree:\nThe class diagram above shows how many default interfaces of the .NET Framework are supported in the ModelBase class. Since most of these interfaces are used by WPF as well, the ViewModelBase class itself can take huge advantage of the implementation of ModelBase.\nBecause ViewModelBase derives from ModelBase, you can declare properties exactly the same way. Even better, you can simply use ModelBase (or the extended SavableModelBase) to create (and save) your Models, and use ViewModelBase as the base for all the View Models.\nCreating a view model To declare a View Model, use the following code snippet:\n vm - defines a new view model   When using the vm code snippet, this is the result:\n/// \u0026lt;summary\u0026gt; /// $name$ view model. /// \u0026lt;/summary\u0026gt; public class $name$ViewModel : ViewModelBase { #region Fields #endregion #region Constructors /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;$name$ViewModel\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; public $name$ViewModel () { } #endregion #region Properties /// \u0026lt;summary\u0026gt; /// Gets the title of the view model. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;The title.\u0026lt;/value\u0026gt; public override string Title { get { return \u0026quot;View model title\u0026quot;; } } // TODO: Register models with the vmpropmodel codesnippet // TODO: Register view model properties with the vmprop or vmpropviewmodeltomodel codesnippets #endregion #region Commands // TODO: Register commands with the vmcommand or vmcommandwithcanexecute codesnippets #endregion #region Methods #endregion }  Declaring properties Note that declaring properties works exactly the same as declaring properties for the ModelBase\nThere are several code snippets available to create View Model properties:\n vmprop - Defines a simple View Model property. vmpropmodel - Defines a View Model property with ModelAttribute. The property is also made private by default. vmpropviewmodeltomodel - Defines a View Model property with ViewModelToModelAttribute.  When using the vmprop code snippet, this is the result:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the name. /// \u0026lt;/summary\u0026gt; public string Name { get { return GetValue\u0026lt;string\u0026gt;(NameProperty); } set { SetValue(NameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Name property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData NameProperty = RegisterProperty(\u0026quot;Name\u0026quot;, typeof(string));  In the View, it is now possible to bind to the Name property of the View Model, as long as DataContext is set to an instance of the View Model.\nDeclaring commands There are several code snippets available to create View Model commands:\n vmcommand - Defines a command that is always executable. vmcommandwithcanexecute - Defines a command that implements a CanExecute method to determine whether the command can be invoked on the View Model in its current state.  When using the vmcommandwithcanexecute code snippet, this is the result:\n/// \u0026lt;summary\u0026gt; /// Gets the Add command. /// \u0026lt;/summary\u0026gt; public Command\u0026lt;object, object\u0026gt; Add { get; private set; } // TODO: Move code below to constructor Add = new Command\u0026lt;object, object\u0026gt;(OnAddExecute, OnAddCanExecute); // TODO: Move code above to constructor /// \u0026lt;summary\u0026gt; /// Method to check whether the Add command can be executed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;parameter\u0026quot;\u0026gt;The parameter of the command.\u0026lt;/param\u0026gt; private bool OnAddCanExecute(object parameter) { return true; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the Add command is executed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;parameter\u0026quot;\u0026gt;The parameter of the command.\u0026lt;/param\u0026gt; private void OnAddExecute(object parameter) { // TODO: Handle command logic here }  The only thing left to do now is to move the creation of the command to the constructor (as the comments already instructs you to).\nIn the View, it is now possible to bind any Command property (such as the Command property of a Button) to the Add property of the View Model, as long as DataContext is set to an instance of the View Model.\nAdding validation Because the ViewModelBase class derives from ModelBase, it provides the same power of validation that the ModelBase class has to offer. ModelBase (and thus ViewModelBase) offers the following types of validation:\n Field warnings Business warnings Field errors Business errors  ViewModelBase uses smart validation. This means that if the object is already validated, the object is not validated again to make sure that the View Models don\u0026rsquo;t hit too much on the performance. Only when a property on the View Model changes, validation will be invoked. Of course, if required, it is still possible to force validation when the View Model must be validated, even when no properties have changed.\nTo implement field or business rule validation, you only have to override ValidateFields and/or the ValidateBusinessRules method:\n/// \u0026lt;summary\u0026gt; /// Validates the field values of this object. Override this method to enable /// validation of field values. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results, add additional results to this list.\u0026lt;/param\u0026gt; protected override void ValidateFields(List\u0026lt;FieldValidationResult\u0026gt; validationResults) { if (!string.IsNullOrEmpty(FirstName)) { validationResults.Add(FieldValidationResult.CreateError(FirstNameProperty, \u0026quot;First name cannot be empty\u0026quot;)); } } /// \u0026lt;summary\u0026gt; /// Validates the field values of this object. Override this method to enable /// validation of field values. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results, add additional results to this list.\u0026lt;/param\u0026gt; protected override void ValidateBusinessRules(List\u0026lt;BusinessRuleValidationResult\u0026gt; validationResults) { if (SomeBusinessErrorOccurs) { validationResults.Add(BusinessRuleValidationResult.CreateError(\u0026quot;A business error occurred\u0026quot;)); } }  Note that it is also possible to re-use validation in a model using *ModelToViewModel* mappings or even external validation such as *FluentValidation*  There are also other ways to add validation to a data object:\n Validation via data annotations - attributes such as the RequiredAttribute Validation via IValidator - custom validation such as FluentValidation  The great thing is that Catel will gather all validation results from all different mappings and combine these into the ValidationContext. This context can be used to query all sorts of validation info about an object.\nInteraction with models One of the most important reasons why a View Model is created is because it serves as the glue between a View and the Model. The communication between the View and the View Model is fully taken care of by WPF in the form of Bindings. The problem is that most of the time, a View Model is used to show a subset of a Model (which is, for example, a database entity).\nMost MVVM frameworks (actually, I haven\u0026rsquo;t seen anyone not requiring manual updating) require manual updating, which brings us back to the stone age (remember the WinForms time setting the controls at startup, and reading the values at the end?). Catel solves this issue by providing convenience attributes that take care of this dumb getting/setting story between the View Model and the Model. Catel fully supports getting/setting the values from/to the Model, but believe me: you will love the attributes that are described next.\nModelAttribute To be able to map values from/to a Model, it is important to know the actual Model. So, to let the View Model know what property represents the Model, ModelAttribute can be used like shown below:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the person. /// \u0026lt;/summary\u0026gt; [Model] public Person Person { get { return GetValue\u0026lt;Person\u0026gt;(PersonProperty); } private set { SetValue(PersonProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Person property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData PersonProperty = RegisterProperty(\u0026quot;Person\u0026quot;, typeof(Person));  A Model setter is normally written as private (you normally don\u0026rsquo;t want a UI to be able to change a Model), but the getter is public because you might want to read info from it.\nNote that you should use the *vmpropmodel* code snippet to create Model properties  Models in Catel are handled as very, very special objects. This means that as soon as a Model is set, Catel tries to call the IEditableObject.BeginEdit method. Then, as soon as the Model is changed without being saved, or if the View Model is canceled, the Model is correctly canceled via IEditableObject.CancelEdit. If the Model is saved, the active Models will be committed via IEditableObject.EndEdit. I will leave the rest of the magic out of this article, but if you have any questions about it, don\u0026rsquo;t hesitate to contact us!\nViewModelToModelAttribute Now that we know how to declare a property as a Model, it is time to learn how we can communicate with it. Normally, you would have to watch the Model to make sure it is synchronized correctly when the Model is updated. With Catel, this is not necessary any longer. Simply use ViewModelToModelAttribute, and you will get the following advantages:\n Models are automatically being watched for changes, thus if a mapped property changes, the View Model is updated accordingly; When a View Model is changed, this property is automatically mapped to the Model; When the Model changes, the View Model is initialized automatically with the values of the new Model; When a Model has an error or warning (business or field), the warnings are mapped to the View Model so you can “re-use” the validation of the Model inside your View Model.  So, you get all of this for free? No, you will have to decorate your property with ViewModelToModelAttribute, like shown below:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the first name. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Person\u0026quot;)] public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FirstName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string));  The code example is the easiest usage of the attribute that is available. It only provides the name of the Model property. This is required because it is possible (but not likely) to have multiple Models. But what if the property on your Model has a different name than your View Model? No problem, use the overload of the attribute as shown below:\n[ViewModelToModel(\u0026quot;Person\u0026quot;, \u0026quot;RealFirstName\u0026quot;)] public string FirstName ///... (remaining code left out for the sake of simplicity)  The code above will map the FirstName property of the View Model to the RealFirstName property of the Person model.\nExposeAttribute The ViewModelToModelAttribute is a great way to map properties between the model and the view model. However, sometimes the mappings are not required for manual coding and should only be exposed from inside the view model to the view. The ExposeAttribute is great way to simplify this process. The code below is the same as declaring a model property named Person and 3 additional properties using the ViewModelToModelAttribute:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the person. /// \u0026lt;/summary\u0026gt; [Model] [Expose(\u0026quot;FirstName\u0026quot;)] [Expose(\u0026quot;MiddleName\u0026quot;)] [Expose(\u0026quot;LastName\u0026quot;)] private Person Person { get { return GetValue\u0026lt;Person\u0026gt;(PersonProperty); } set { SetValue(PersonProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Person property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData PersonProperty = RegisterProperty(\u0026quot;Person\u0026quot;, typeof(Person));  Interaction with other view models Now that we\u0026rsquo;ve seen how easy it is to communicate between the View Model and the Model, you want more, right? I know how it is: “You let \u0026lsquo;em have one finger, they take your whole hand”. No worries, you can have my right hand, as long as I can keep my left one. Anyway, the developers of Catel are prepared for this. So, let\u0026rsquo;s talk about the interaction with other View Models.\nSay, you have a multiple document interface (MDI as it was called in the old days). If you are following MVVM principles, every document (or tab) has its own View Model. Then, you want to be aware of updates of a single type of View Model. Say, for example, that there is a View Model representing a family called FamilyViewModel. This View Model is probably interested in changes in the PersonViewModel.\nViewModelManager Let\u0026rsquo;s start with the basics. As we have learned earlier in this article, all View Models created with the help of Catel derive from the ViewModelBase class. One of the things that this class does is that it registers itself with the ViewModelManager class when it is being created, and it unregisters itself again when it is closed. So, simply said, ViewModelManager is a class that holds a reference to all existing View Models at the moment.\nMessageMediator Catel also offers a solution to the message mediator pattern in the form of the MessageMediator class. This is all described in the next section \u0026ldquo;Message mediator\u0026rdquo;.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/ensuring-integrity/","title":"Ensuring integrity of the ServiceLocator","tags":[],"description":"","content":" Starting with Catel 3.6, a very useful feature has been added to the ServiceLocator and TypeFactory. This features is called \u0026ldquo;integrity checker\u0026rdquo; and will ensure you with useful information about type registration paths. This protection mechanism is very useful in complex applications. When people start building services, sometimes they accidentally inject other services that via injection to other services cause a stack overflow. Debugging and determining which type is causing the issue can be very time-consuming. To make the example a bit more simple, below are a few classes which demonstrate a common issue in enterprises.\npublic class X { public X(Y y) { } } public class Y { public Y(Z z) { } } public class Z { public Z(X x) { } }  Note how a round-trip of dependencies is created which will result in a StackOverflowException somewhere in your code. Below is a graphical example what happens. Note that the dotted line is showing the circular dependency causing the StackOverflowException.\nTypeRequestInfo The first step for the integrity checker is to make sure that it knows what types are being requested from the ServiceLocator (which will be instantiated by the TypeFactory if required). This class contains all the information about a type being created by the TypeFactory:\n Type Tag (optional, can be used to differentiate different instances of the same type registration)  TypeRequestPath Now we have detailed information about the types being constructed, it is very important to keep track of the types which are being created by the TypeFactory. During the construction of a type, the TypeFactory will request the ServiceLocator for a type, which will ask the TypeFactory to construct the type again. Each time the TypeFactory starts constructing a type (and currently has a TypeRequestPath), it will create a new instance of the TypeRequestInfo and add it to the TypeRequestPath. The diagram below shows how the TypeRequestPath will evolve.\nOnce the TypeRequestPath will contain a duplicate instance of a TypeRequestInfo, it will become invalid (which means there is a circular type dependency).\nNote that this is a very simple example, but normally a type will have several services injected which can have dependencies on their own as well which can cause a very complex type request path  Checking the integrity of the type request To resolve and construct a type, a lot of communication will happen between the TypeFactory and the ServiceLocator. This flow is show in the diagram below.\nAs you can see, there is a lot of communication between the ServiceLocator and TypeFactory. In the TypeRequestPath example we already saw how the path will become invalid when it contains a duplicate instance of the TypeRequestInfo. The TypeRequestPath will then throw a CircularDependencyException with all the necessary information to solve the issue:\nNow you will find the issue in no-time and save yourself a lot of your valuable time!\n"},{"uri":"https://docs.catelproject.com/vnext/getting-started/","title":"Getting started","tags":[],"description":"","content":" Quick introduction for developers   Getting started with WPF   Getting started with Xamarin.Forms   "},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/integration-with-external-loggers/","title":"Integration with external logging","tags":[],"description":"","content":" Log4net   NLog   "},{"uri":"https://docs.catelproject.com/vnext/introduction/introduction-data-objects/","title":"Introduction to data objects","tags":[],"description":"","content":" It is very important to understand the data objects in Catel because they form the base pillar of all components used by the MVVM framework.\nThe ObservableObject class Very basic class implementing the System.ComponentModel.INotifyPropertyChanging and T:System.ComponentModel.INotifyPropertyChanged interfaces as well as Catels Catel.Data.IAdvancedNotifyPropertyChanging and Catels Catel.Data.IAdvancedNotifyPropertyChanged.\nThe ModelBase class The ModelBase(previously known as the DataObjectBase) class is a generic base class that can be used for all your data classes. This comes fully supporting serialization, property changed notifications, backwards compatibility and error checking.\nCreating your first data object First of all, it is very important to realize that you shouldn\u0026rsquo;t bore yourself with writing all the code below yourself. Catel contains lots of code snippets that allow you to create data objects very easily in a short amount of time.\nThis example shows the simplest way to declare a data object using the ModelBase class. By using a code snippet, the class is created in just 10 seconds.\nCode snippets\n model - Declares a data object based on the ModelBase class  Steps\n Create a new class file called FirstModel.cs. Inside the namespace, use the model codesnippet and fill in the name of the class, in this case FirstModel.  Code\n/// \u0026lt;summary\u0026gt; /// FirstModel class which fully supports serialization, property changed notifications, /// backwards compatibility and error checking. /// \u0026lt;/summary\u0026gt; [Serializable] public class FirstModel : ModelBase { #region Fields #endregion #region Constructors /// \u0026lt;summary\u0026gt; /// Initializes a new object from scratch. /// \u0026lt;/summary\u0026gt; public FirstModel() { } /// \u0026lt;summary\u0026gt; /// Initializes a new object based on \u0026lt;see cref=\u0026quot;SerializationInfo\u0026quot;/\u0026gt;. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;info\u0026quot;\u0026gt;\u0026lt;see cref=\u0026quot;SerializationInfo\u0026quot;/\u0026gt; that contains the information. /// \u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;context\u0026quot;\u0026gt;\u0026lt;see cref=\u0026quot;StreamingContext\u0026quot;/\u0026gt;.\u0026lt;/param\u0026gt; protected FirstModel(SerializationInfo info, StreamingContext context) : base(info, context) { } #endregion #region Properties // TODO: Define your custom properties here using the propdata code snippet #endregion #region Methods /// \u0026lt;summary\u0026gt; /// Validates the field values of this object. Override this method to enable /// validation of field values. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results, add additional results to this list.\u0026lt;/param\u0026gt; protected override void ValidateFields(List\u0026lt;FieldValidationResult\u0026gt; validationResults) { } /// \u0026lt;summary\u0026gt; /// Validates the field values of this object. Override this method to enable /// validation of field values. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results, add additional results to this list.\u0026lt;/param\u0026gt; protected override void ValidateBusinessRules(List\u0026lt;BusinessRuleValidationResult\u0026gt; validationResults) { } #endregion }  Declaring properties The next step to learn on the ModelBase class is how to declare properties. There are several types of properties, and they will all be handled in this part of the documentation.\nThe ModelBase class uses a dependency property a-like notation of properties.\nSimple properties This example shows how to declare the simplest property. In this example, a string property with a default value will be declared with the use of a code snippet.\nCode snippets\n modelprop - Declares a simple property on a model  Steps\n Open FirstModel.cs created in the previous step. In the Properties region, use the code snippet modelprop, and use the following values:     Code snippet item Value     description Gets or sets the simple property   type string   name SimpleProperty   defaultvalue \u0026ldquo;Simple property\u0026rdquo;    Code\n/// \u0026lt;summary\u0026gt; /// Gets or sets the simple property. /// \u0026lt;/summary\u0026gt; public string SimpleProperty { get { return GetValue\u0026lt;string\u0026gt;(SimplePropertyProperty); } set { SetValue(SimplePropertyProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the SimpleProperty property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyDataSimplePropertyProperty = RegisterProperty(\u0026quot;SimpleProperty\u0026quot;, typeof(string), \u0026quot;Simple property\u0026quot;);  Properties with property change callback Code snippets\n modelpropchanged - Declares a simple property on a model with a property changed callback  Steps\n Open FirstModel.cs created in the previous step. In the Properties region, use the code snippet modelpropchanged, and use the following values:     Code snippet item Value     description Gets or sets the callback property   type string   name CallbackProperty   defaultvalue \u0026ldquo;Callback property\u0026rdquo;    Code\n/// \u0026lt;summary\u0026gt; /// Gets or sets the callback property. /// \u0026lt;/summary\u0026gt; public string CallbackProperty { get { return GetValue\u0026lt;string\u0026gt;(CallbackPropertyProperty); } set { SetValue(CallbackPropertyProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the CallbackProperty property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyDataCallbackPropertyProperty = RegisterProperty(\u0026quot;CallbackProperty\u0026quot;, typeof(string), \u0026quot;Callback property\u0026quot;, (sender, e) =\u0026gt; ((FirstDataObject)sender).OnCallbackPropertyChanged()); /// \u0026lt;summary\u0026gt; /// Called when the CallbackProperty property has changed. /// \u0026lt;/summary\u0026gt; private void OnCallbackPropertyChanged() { // TODO: Implement logic }  Adding validation It is very easy to add validation to a class (both the ModelBase and ViewModelBase). There are several ways, but this getting started guide will handle only the most simple one.\nTo enable validation, you must override at least one of the following methods:\n/// \u0026lt;summary\u0026gt; /// Validates the field values of this object. Override this method to enable /// validation of field values. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results, add additional results to this list.\u0026lt;/param\u0026gt; protected override void ValidateFields(List\u0026lt;FieldValidationResult\u0026gt; validationResults) { if (string.IsNullOrEmpty(FirstName)) { validationResults.Add(FieldValidationResult.CreateError(FirstNameProperty, \u0026quot;First name cannot be empty\u0026quot;)); } } /// \u0026lt;summary\u0026gt; /// Validates the field values of this object. Override this method to enable /// validation of field values. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results, add additional results to this list.\u0026lt;/param\u0026gt; protected override void ValidateBusinessRules(List\u0026lt;BusinessRuleValidationResult\u0026gt; validationResults) { if (SomeBusinessErrorOccurs) { validationResults.Add(BusinessRuleValidationResult.CreateError(\u0026quot;A business error occurred\u0026quot;)); } }  After the validation is implemented into the object, the validation will occur every time a property on the object changes. It is also possible to manually validate by calling the Validate method.\nThere are also other ways to add validation to a data object:\n Validation via data annotations - attributes such as the RequiredAttribute Validation via IValidator - custom validation such as FluentValidation  The great thing is that Catel will gather all validation results from all different mappings and combine these into the ValidationContext. This context can be used to query all sorts of validation info about an object.\nNote that this is just an introduction, more information about validation can be found in other parts of the documentation  Saving objects Saving and loading objects out of the box has never been so easy. SavableModelBase can automatically save/load objects in several ways, such as memory, file in different modes (binary and XML). This example shows that making your objects savable is very easy and does not take any time!\nCode snippets\n model - Declare a model based on the ModelBase class modelprop - Declare a simple property on a model  Steps\n Create a new class file called Person.cs. Inside the namespace, use the model codesnippet and fill in the name of the class, in this case Person. Change the base class from ModelBase to SavableModelBase. In the Properties region, use the code snippet modelprop, and use the following values:     Code snippet item Value     description Gets or sets the name   type string   name Name   defaultvalue \u0026ldquo;MyName\u0026rdquo;    Code\n/// \u0026lt;summary\u0026gt; /// Person class which fully supports serialization, property changed notifications, /// backwards compatibility and error checking. /// \u0026lt;/summary\u0026gt; [Serializable] public class Person : SavableModelBase\u0026lt;Person\u0026gt; { #region Fields #endregion #region Constructors /// \u0026lt;summary\u0026gt; /// Initializes a new object from scratch. /// \u0026lt;/summary\u0026gt; public Person() { } /// \u0026lt;summary\u0026gt; /// Initializes a new object based on \u0026lt;see cref=\u0026quot;SerializationInfo\u0026quot;/\u0026gt;. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;info\u0026quot;\u0026gt;\u0026lt;see /// cref=\u0026quot;SerializationInfo\u0026quot;/\u0026gt; that contains the information. /// \u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;context\u0026quot;\u0026gt;\u0026lt;see // cref=\u0026quot;StreamingContext\u0026quot;/\u0026gt;.\u0026lt;/param\u0026gt; protected Person(SerializationInfo info, StreamingContext context) : base(info, context) { } #endregion #region Properties /// \u0026lt;summary\u0026gt; /// Gets or sets the name. /// \u0026lt;/summary\u0026gt; public string Name { get { return GetValue\u0026lt;string\u0026gt;(NameProperty); } set { SetValue(NameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Name property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData NameProperty = RegisterProperty(\u0026quot;Name\u0026quot;, typeof(string), \u0026quot;MyName\u0026quot;); #endregion #region Methods #endregion }  Loading an object Loading an object is really simple once the class has been created. It is important to use the static method on the class:\nvar person = Person.Load(@\u0026quot;c:\\person.dob\u0026quot;);  Saving an object To save an object, an instance is required. Then simply call the Save method.\nvar person = new Person(); person.Name = \u0026quot;John Doe\u0026quot;; person.Save(@\u0026quot;c:\\person.dob\u0026quot;);  "},{"uri":"https://docs.catelproject.com/vnext/faq/performance-considerations/","title":"Performance considerations","tags":[],"description":"","content":" While developing software, it is very important to keep an eye on the performance. Catel itself does perform very well, but there are some caveats that you should be aware of. If you have the feeling that the application is laggy or slow, or if you want to make sure to squeeze the best performance out of Catel, consider taking a closer look at the checklist below.\nUse the [ApiCop feature](/vnext/catel-core/apicop/) to get a detailed advisory report on your software  General Disable the call to LogManager.AddDebugListener The DebugListener is a very useful class while developing an application. It throws all the logging of Catel to the output window of Visual Studio which allows you to view exactly what happens behind the scenes. However, writing all these logs to the output window is very expensive and might cause an application to perform badly.\nTherefore, it is important to disable any call to LogManager.AddDebugListener when releasing an application or while performance testing.\nBest way to deal with this is to wrap it inside the DEBUG define:\n#if DEBUG LogManager.AddDebugListener(); #endif  Preloading assemblies into the AppDomain Preloading assemblies might result in a slower startup time, but will not cause slow downs for reflection or assembly loading during the actual application execution. To preload assemblies using Catel, simply call this extension method:\n** **\nWPF application\nIn App.xaml.cs, add the following code\nvar directory = typeof(MainWindow).Assembly.GetDirectory(); AppDomain.CurrentDomain.PreloadAssemblies(directory);  ASP.NET application\nIn global.asax, add the following code:\nvar directory = Server.MapPath(\u0026quot;~/bin\u0026quot;); AppDomain.Current.PreloadAssemblies(directory);  Warming up the serializers To improve performance for serialization, warm up the serializers.\nMVVM Set SkipSearchingForInfoBarMessageControl on UserControl to true By default, Catel assumes that an InfoBarMessageControl is located on any window. However, it might be that this control is not located on a window that contains an instance of the UserControl class. This might decrease the performance, especially when lots of user controls are used in a hierarchical way. The cause is that the UserControlLogic searches for an InfoBarMessageControl to register the view model to.\n If no *InfoBarMessageControl* is located on a container, make sure to set *SkipSearchingForInfoBarMessageControl* to true.\n// Use when not using styles and transitions Catel.Windows.Controls.UserControl.DefaultTransferStylesAndTransitionsToViewModelGridValue = false; // Use when not using any validation controls Catel.Windows.Controls.UserControl.DefaultSkipSearchingForInfoBarMessageControlValue = true; Catel.Windows.Controls.UserControl.DefaultCreateWarningAndErrorValidatorForViewModelValue = false;  Use the FastObservableCollection The FastObservableCollection does not raise events for every item, but only invokes events for the complete range of items added to or removed from the collection.\nWhen modifying a large collection of items, it is not required to raise change events for each added / removed value. Therefore the FastObservableCollection will disable change notifications until the full collection modification is done and then raise the change events just once.\nSpecify throttling on the ViewModelBase The ViewModelBase allows the specify the throttling of the property change notifications. In normal situations it is best to directly raise property change notifications. However, when a lot of properties change a lot within a very short timeframe, it might be interesting to enable throttling. By using throttling, the change notifications are not directly sent to the UI but instead added to a dictionary. Then each time the ThottlingRate is reached, the change notifications are sent in batches to the view. If the same property has changed several times in a specific time frame, it will only be raised once which might give a performance boost in very specific situations.\nBy default, throttling is disabled but can be enabled by setting the ThrottlingRate property:\nThrottlingRate = new TimeSpan(0, 0, 0, 0, 200);  The *AdvancedDemo* example contains a demo that shows the impact of throttling  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/setting-up-using-configuration/","title":"Setting up the ServiceLocator using configuration","tags":[],"description":"","content":" The ServiceLocator in Catel can be set up from configuration file.\n/**/ Importing IoC configuration section Configuring a service locator from the default configuration Configuring a service locator from a named configuration\nImporting IoC configuration section The first step to setup the service locator from the configuration file is import the custom section type Catel.IoC.IoCConfigurationSection from Catel.Core. The following example shows how to import this configuration section and make it available for the configuration file as ioc:\n\u0026lt;configuration\u0026gt; \u0026lt;configSections\u0026gt; \u0026lt;sectionGroup name=\u0026quot;catel\u0026quot;\u0026gt; \u0026lt;section name=\u0026quot;ioc\u0026quot; type=\u0026quot;Catel.IoC.IoCConfigurationSection, Catel.Core\u0026quot; /\u0026gt; \u0026lt;/sectionGroup\u0026gt; \u0026lt;/configSections\u0026gt; ... \u0026lt;/configuration\u0026gt;  In the example above we also create a section group named catel to group all Catel related configuration sections.  Configuring a service locator from the default configuration It\u0026rsquo;s possible add more than one service locator configuration to the configuration file but you must specify an unique name. If a name of a service locator configuration is not specified then the name default is assigned. By default such configuration supports dependency injection.\n\u0026lt;configuration\u0026gt; \u0026lt;configSections\u0026gt; \u0026lt;sectionGroup name=\u0026quot;catel\u0026quot;\u0026gt; \u0026lt;section name=\u0026quot;ioc\u0026quot; type=\u0026quot;Catel.IoC.IoCConfigurationSection, Catel.Core\u0026quot; /\u0026gt; \u0026lt;/sectionGroup\u0026gt; \u0026lt;/configSections\u0026gt; \u0026lt;catel\u0026gt; \u0026lt;ioc\u0026gt; \u0026lt;serviceLocatorConfigurations\u0026gt; \u0026lt;serviceLocatorConfiguration [name=\u0026quot;default\u0026quot;]\u0026gt; \u0026lt;register interfaceType=\u0026quot;Catel.MVVM.Services.IUIVisualizerService\u0026quot; implementationType=\u0026quot;Catel.MVVM.Services.UIVisualizerService\u0026quot; /\u0026gt; \u0026lt;register interfaceType=\u0026quot;Catel.MVVM.Services.IProcessService\u0026quot; implementationType=\u0026quot;Catel.MVVM.Services.ProcessService\u0026quot; /\u0026gt; \u0026lt;/serviceLocatorConfiguration\u0026gt; \u0026lt;/serviceLocatorConfigurations\u0026gt; \u0026lt;/ioc\u0026gt; \u0026lt;/catel\u0026gt; \u0026lt;/configuration\u0026gt;   To configure a service locator from the default service locator configuration use the following code:\n var serviceLocator = ServiceLocator.Default; Configuration configuration = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None); var ioc = configuration.GetSection\u0026lt;IoCConfigurationSection\u0026gt;(\u0026quot;ioc\u0026quot;, \u0026quot;catel\u0026quot;); ioc.DefaultServiceLocatorConfiguration.Configure(serviceLocator);   Configuring a service locator from a named configuration The following configuration file is a full example on how write more than one service locator configuration:\n\u0026lt;configuration\u0026gt; \u0026lt;configSections\u0026gt; \u0026lt;sectionGroup name=\u0026quot;catel\u0026quot;\u0026gt; \u0026lt;section name=\u0026quot;ioc\u0026quot; type=\u0026quot;Catel.IoC.IoCConfigurationSection, Catel.Core\u0026quot; /\u0026gt; \u0026lt;/sectionGroup\u0026gt; \u0026lt;/configSections\u0026gt; \u0026lt;catel\u0026gt; \u0026lt;ioc\u0026gt; \u0026lt;serviceLocatorConfigurations\u0026gt; \u0026lt;serviceLocatorConfiguration\u0026gt; \u0026lt;register interfaceType=\u0026quot;Catel.MVVM.Services.IUIVisualizerService\u0026quot; implementationType=\u0026quot;Catel.MVVM.Services.UIVisualizerService\u0026quot; /\u0026gt; \u0026lt;register interfaceType=\u0026quot;Catel.MVVM.Services.IProcessService\u0026quot; implementationType=\u0026quot;Catel.MVVM.Services.ProcessService\u0026quot; /\u0026gt; \u0026lt;/serviceLocatorConfiguration\u0026gt; \u0026lt;serviceLocatorConfiguration name=\u0026quot;test\u0026quot; supportDependencyInjection=\u0026quot;false\u0026quot;\u0026gt; \u0026lt;register interfaceType=\u0026quot;Catel.MVVM.Services.IUIVisualizerService\u0026quot; implementationType=\u0026quot;Catel.MVVM.Services.Test.UIVisualizerService\u0026quot; registrationType=\u0026quot;Transient\u0026quot;/\u0026gt; \u0026lt;register interfaceType=\u0026quot;Catel.MVVM.Services.IProcessService\u0026quot; implementationType=\u0026quot;Catel.MVVM.Services.Test.ProcessService\u0026quot; tag=\u0026quot;test\u0026quot;/\u0026gt; \u0026lt;/serviceLocatorConfiguration\u0026gt; \u0026lt;/serviceLocatorConfigurations\u0026gt; \u0026lt;/ioc\u0026gt; \u0026lt;/catel\u0026gt; \u0026lt;/configuration\u0026gt;  To configure a service locator from a named configuration use the following code:\nvar serviceLocator = ServiceLocator.Default; Configuration configuration = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None); var ioc = configuration.GetSection\u0026lt;IoCConfigurationSection\u0026gt;(\u0026quot;ioc\u0026quot;, \u0026quot;catel\u0026quot;); ioc.GetServiceLocatorConfiguration(\u0026quot;test\u0026quot;).Configure(serviceLocator);  You should also note the options setup if the container in order to support dependency injection and the registration type (a.k.a instantiation style) and the tag for each registration.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/taking-full-control-of-serialization/","title":"Taking full control of serialization","tags":[],"description":"","content":" It\u0026rsquo;s possible that full control is needed (either for performance or custom serialization formats). To ensure the best performance possible, this is implemented with a special interface for each serialization engine. If one of the engines detects such a special interface, it will skip all the plumbing and directly call the interface with the right context.\nBinary serialization Custom binary serialization is not (yet) supported  Xml serialization To gain the best performance possible using the xml serializer, a model should implement the ICustomXmlSerializable interface.\npublic class CustomXmlSerializationModel : ModelBase, ICustomXmlSerializable { public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string), null); void ICustomXmlSerializable.Serialize(XElement xmlElement) { xmlElement.Add(new XElement(\u0026quot;FirstName\u0026quot;) { Value = FirstName }); } void ICustomXmlSerializable.Deserialize(XElement xmlElement) { FirstName = xmlElement.Element(\u0026quot;FirstName\u0026quot;).Value; } }  Json serialization To gain the best performance possible using the json serializer, a model should implement the ICustomJsonSerializable interface.\npublic class CustomJsonSerializationModel : ModelBase, ICustomJsonSerializable { public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string), null); void ICustomJsonSerializable.Serialize(JsonWriter jsonWriter) { jsonWriter.WriteStartObject(); jsonWriter.WritePropertyName(\u0026quot;FirstName\u0026quot;); jsonWriter.WriteValue(FirstName); jsonWriter.WriteEndObject(); } void ICustomJsonSerializable.Deserialize(JsonReader jsonReader) { // Note: this is probably not the fastest way to deserialize, but it's used to show the possibilities of the engine var jsonObject = JObject.Load(jsonReader); var jsonProperties = jsonObject.Properties().ToDictionary(x =\u0026gt; x.Name, x =\u0026gt; x); FirstName = (string)jsonProperties[\u0026quot;FirstName\u0026quot;].Value; } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/data-handling/validatablemodelbase/","title":"ValidatableModelBase","tags":[],"description":"","content":"The ValidatableModelBase class extends the [ModelBase](/vnext/catel-core/data-handling/modelbase/) class with functionality to validate the model. The class implements the IDataErrorInfo interface so it is possible to validate the data object and check the errors. This way, no custom validation code needs to be written outside the data class.\nMore documentation should be written in the future  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/validation/validation-via-ivalidator/","title":"Validation via IValidator","tags":[],"description":"","content":" The ViewModelBase derives from ModelBase, thus all information here also applies to the ViewModelBase  The validation in Catel is extremely flexible, but sometimes it is just not enough or you are forced to use external validators. For such cases, Catel provides the IValidatorProvider and IValidator interfaces. These allow very flexible injection or external validators into data objects and view models of Catel.\nImplementing the IValidatorProvider The IValidatorProvider is responsible to return the right IValidator for a specific type. There is a convenience implementation named ValidatorProviderBase which only requires the implementation of one single method. Below is an example of an implementation of the IValidatorProvider.\npublic class ValidatorProvider : ValidatorProviderBase { /// \u0026lt;summary\u0026gt; /// Gets a validator for the specified target type. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;targetType\u0026quot;\u0026gt;The target type.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt; /// The \u0026lt;see cref=\u0026quot;T:Catel.Data.IValidator\u0026quot;/\u0026gt; for the specified type or \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt; if no validator is available for the specified type. /// \u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026quot;T:System.ArgumentNullException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;targetType\u0026quot;/\u0026gt; is \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;.\u0026lt;/exception\u0026gt; public override IValidator GetValidator(Type targetType) { if (targetType == typeof(ValidationInIValidatorViewModel)) { return new Validator(); } // No validator available for other types return null; } }  Implementing the IValidator The IValidator exposes lots of methods to gain the as much freedom as possible. However, most of the methods that are exposed by the interface are hardly used. Therefore there is a convenience base class named ValidatorBase. To create a basic validator, derive from the class and override the methods required for validation.\npublic class Validator : ValidatorBase\u0026lt;TargetClass\u0026gt; { /// \u0026lt;summary\u0026gt; /// Validates the fields of the specified instance. The results must be added to the list of validation /// results. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;instance\u0026quot;\u0026gt;The instance to validate.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results.\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026quot;T:System.ArgumentNullException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;instance\u0026quot;/\u0026gt; is \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;.\u0026lt;/exception\u0026gt; /// \u0026lt;exception cref=\u0026quot;T:System.ArgumentNullException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;validationResults\u0026quot;/\u0026gt; is \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;.\u0026lt;/exception\u0026gt; public override void ValidateFields(TargetClass instance, List\u0026lt;IFieldValidationResult\u0026gt; validationResults) { if (string.IsNullOrEmpty(instance.FirstName)) { validationResults.Add(FieldValidationResult.CreateError(TargetClass.FirstNameProperty, \u0026quot;First name cannot be empty\u0026quot;)); } if (string.IsNullOrEmpty(instance.LastName)) { validationResults.Add(FieldValidationResult.CreateError(TargetClass.LastNameProperty, \u0026quot;Last name cannot be empty\u0026quot;)); } } /// \u0026lt;summary\u0026gt; /// Validates the business rules of the specified instance. The results must be added to the list of validation /// results. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;instance\u0026quot;\u0026gt;The instance to validate.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results.\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026quot;T:System.ArgumentNullException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;instance\u0026quot;/\u0026gt; is \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;.\u0026lt;/exception\u0026gt; /// \u0026lt;exception cref=\u0026quot;T:System.ArgumentNullException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;validationResults\u0026quot;/\u0026gt; is \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;.\u0026lt;/exception\u0026gt; public override void ValidateBusinessRules(TargetClass instance, List\u0026lt;IBusinessRuleValidationResult\u0026gt; validationResults) { // No business rules (yet) } }  Setting the validator in ModelBase To register an IValidator instance on a ModelBase, use the following code:\nvar modelValidation = myModel as IModelValidation; if (modelValidation != null) { modelValidation .Validator = new MyValidator(); }  If an IValidatorProvider instance is available, the following code can be used to allow a more generic approach. This code assumes that the IValidatorProvider is registered in the ServiceLocator.\nvar validatorProvider = ServiceLocator.Instance.ResolveType\u0026lt;IValidatorProvider\u0026gt;(); myObject.Validator = validatorProvider.GetValidator(myObject.GetType());  If the IValidatorProvider returns null (which is allowed), no custom validator will be used.\nSetting the validator in ViewModelBase The ViewModelBase has it\u0026rsquo;s own ServiceLocator. The easiest way to support a validator is to register an IValidatorProvider instance in the ServiceLocator:\nServiceLocator.Instance.RegisterType\u0026lt;IValidatorProvider, MyValidatorProvider\u0026gt;();  The ViewModelBase will automatically retrieve the right IValidator for the view model. If no IValidatorProvider is registered in the ServiceLocator, no validator will be set automatically. It is also possible to set the Validator property manually, but it is recommended to use an IValidatorProvider and register it.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/anotar-catel-fody/","title":"Anotar.Catel.Fody","tags":[],"description":"","content":" Logging is a very important part of an application. It provides detailed information about the application workflow, even when an application is already deployed to several clients. That’s the reason that logging is a first class citizen in the Catel framework.\nIn general, logging works by defining an ILog instance on a class:\nprivate static readonly ILog Log = LogManager.GetCurrentClassLogger();  Then in any method, logging can be added like this:\nLog.Info(“This is a logging with a format ‘{0}’”, “test”);  Writing the Log definition can be boring and repetitive. Luckily Simon Cropp came up with a solution for that, namely Anotar.Catel.Fody. With the Anotar implementation, a reference will be added to the solution. Then after compilation the assembly will be removed and all calls to the LogTo class will be replaced by actual calls to the Catel logging classes.\nHow to use Anotar Using Anotar is really easy, just call the static methods on the LogTo class as you can see below:\nLogTo.Info(\u0026quot;This is a logging with a format ‘{0}’\u0026quot;, “test”);  Note that it is no longer required to define the Log field, it will be added automatically by Anotar.\nBesides that it is really easy to use, another benefit is a very small performance improvement. The GetCurrentClassLogger uses reflection to determine the current class. This is a very slight hit on performance the first time a class is used (only once, the field is static). Anotar directly replaces the call by an implementation like this:\nprivate static readonly ILog Log = LogManager.GetLogger(typeof(MyClass));  Additional options Disabling method names and line numbers By default Anotar also logs the method and line number:\n03:58:11:858 =\u0026gt; [DEBUG] [AnotarDemo.Program] Method: 'Void Main(String[])'. Line: ~19. this is a test  If you don\u0026rsquo;t want such output, add this attribute on assembly level:\n[assembly: LogMinimalMessage]  Then the output will look like this:\n03:59:36:344 =\u0026gt; [DEBUG] [AnotarDemo1.Program] this is a test  Logging exceptions automatically It is possible to automatically log exceptions inside a method. To accomplish this, decorate the method with the LogTo[LogLevel]OnException attribute:\n[LogToDebugOnException] public static void ExceptionalMethod() { throw new Exception(\u0026quot;This will be logged automatically\u0026quot;); }  Then the output will be as follows:\n04:01:48:331 =\u0026gt; [DEBUG] [AnotarDemo.Program] Exception occurred in 'Void ExceptionalMethod()'. | [Exception] System.Exception: This will be logged automatically at AnotarDemo.Program.ExceptionalMethod() in c:\\Source\\AnotarDemo\\AnotarDemo\\Program.cs:line 27  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/data-handling/comparablemodelbase/","title":"ComparableModelBase","tags":[],"description":"","content":"The ComparableModelBase class extends the [ModelBase](/vnext/catel-core/data-handling/modelbase/) class with default equality comparer members. This logic has been moved to a separate class to improve the out-of-the-box performance of the ModelBase class.\nMore documentation should be written in the future  "},{"uri":"https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-user-controls/","title":"Creating the views (user controls)","tags":[],"description":"","content":" In this step we will create the views for the application. There are several views that will be created and both user controls and windows will be handled in this part of the guide. Catel makes it very easy to create views as user controls with their own view models. In the previous step we already created the view models.\nPerson view To create a new view, right-click the Views folder in the solution =\u0026gt; Add =\u0026gt; New item\u0026hellip; =\u0026gt; On-line =\u0026gt; and search for Catel as you can see in the screen below:\nGive the new view the name PersonView. The view will be added to the Views folder.\nCatel will automatically link the `PersonViewModel` and `PersonView` together by naming convention  Now we only need to modify the view itself, the code-behind can stay untouched. Since xaml isn\u0026rsquo;t very interesting for this guide, simply copy/paste the xaml below and set it as content of the view:\n\u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;0\u0026quot; Grid.Column=\u0026quot;0\u0026quot; Content=\u0026quot;First name\u0026quot; /\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;0\u0026quot; Grid.Column=\u0026quot;1\u0026quot; Content=\u0026quot;{Binding FirstName}\u0026quot; /\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;1\u0026quot; Grid.Column=\u0026quot;0\u0026quot; Content=\u0026quot;Last name\u0026quot; /\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;1\u0026quot; Grid.Column=\u0026quot;1\u0026quot; Content=\u0026quot;{Binding LastName}\u0026quot; /\u0026gt; \u0026lt;/Grid\u0026gt;  Family view The FamilyView must be created exactly the same way as the PersonView. Use the following xaml as content:\n\u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;0\u0026quot; Grid.Column=\u0026quot;0\u0026quot; Content=\u0026quot;Family name\u0026quot; /\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;0\u0026quot; Grid.Column=\u0026quot;1\u0026quot; Content=\u0026quot;{Binding FamilyName}\u0026quot; /\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;1\u0026quot; Grid.ColumnSpan=\u0026quot;2\u0026quot; Content=\u0026quot;Persons\u0026quot; /\u0026gt; \u0026lt;ItemsControl Grid.Row=\u0026quot;2\u0026quot; Grid.ColumnSpan=\u0026quot;2\u0026quot; ItemsSource=\u0026quot;{Binding Persons}\u0026quot;\u0026gt; \u0026lt;ItemsControl.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;views:PersonView DataContext=\u0026quot;{Binding}\u0026quot; /\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ItemsControl.ItemTemplate\u0026gt; \u0026lt;/ItemsControl\u0026gt; \u0026lt;/Grid\u0026gt;  Since this view uses the PersonView, it must be defined as a namespace at the top of the file:\nxmlns:views=\u0026quot;clr-namespace:WPF.GettingStarted.Views\u0026quot;  The thing that is important to notice in the FamilyView is how it uses the PersonView and injects the Person models into the PersonView data context.\nUp next Creating the views (windows)\n"},{"uri":"https://docs.catelproject.com/vnext/examples/","title":"Examples","tags":[],"description":"","content":"We will write documentation about examples here.\n"},{"uri":"https://docs.catelproject.com/vnext/introduction/mvvm/","title":"Introduction to MVVM","tags":[],"description":"","content":" Different interpretations of MVVM   Validation in model or view model?   Introduction to MVVM and models   Creating view models with Catel   Introduction to services   Introduction to the nested user controls problem   "},{"uri":"https://docs.catelproject.com/vnext/introduction/mvvm/introduction-to-services/","title":"Introduction to services","tags":[],"description":"","content":" Services are very important in MVVM. They define a way to interact with the user without using fixed controls such as MessageBox or SaveFileDialog. The interfaces defined in Catel only define generic functionality of what to expect from a specific service. Using services is a great way to abstract away all specific functionality from a view model into a service that can be mocked during unit testing and can be used by other view models as well.\nServiceLocator The key behind services is the ServiceLocator. The ServiceLocator is the IoC (Inversion of Control) container that Catel provides. This is a container that contains all registrations and service instances available throughout the application. Retrieving services from the default ServiceLocator in Catel is very simple:\nvar dependencyResolver = this.GetDependencyResolver(); var messageService = dependencyResolver.Resolve\u0026lt;IMessageService\u0026gt;();  It is also possible to get services injected into the constructor, which is the recommended approach\nDependency injection A slightly better way to manage dependencies is to use dependency injection. The reason is that to instantiate a class, you always have to provide all the dependencies. This way, all dependencies are always known to the caller making it a bit complicated and encouraging high coupling. Using dependency injection however makes it a bit easier to control than having to know what services are being used by a component (such as a view model).\nCatel fully supports dependency on view models. This means that a view model can have a constructor with several services. Catel will automatically inject the services via the constructor. An example is below:\npublic class PersonViewModel : ViewModelBase { private readonly IMessageService _messageService; private readonly IPleaseWaitService _pleaseWaitService; public PersonViewModel(IMessageService messageService, IPleaseWaitService pleaseWaitService) { _messageService = messageService; _pleaseWaitService = pleaseWaitService; } }  Overview of services The services below are available in Catel:\nName\nDescription\nIAccelerometerService\nAllows a developer to access the accelerometer of a Windows Phone device.\nICameraService\nAllows a developer to use the PhotoCamera class in an MVVM manner.\nICompassService\nAllows a developer to access the compass of a Windows Phone device.\nIGyroscopeService\nAllows a developer to access the compass of a Windows Phone device.\nILocationService\nAllows a developer to use GPS devices inside a view model.\nIMessageService\nAllows a developer to show message boxes from a view model.\nINavigationService\nAllows a developer to navigate to other pages inside an application using view models only.\nIOpenFileService\nAllows a developer to let the user choose a file from inside a view model.\nIPleaseWaitService\nAllows a developer to show a please wait message (a.k.a. busy indicator) from a view model.\nIProcessService\nAllows a developer to run processes from inside a view model.\nISaveFileService\nAllows a developer to let the user choose a file from inside a view model.\nIUIVisualizerService\nAllows a developer to show (modal) windows or dialogs without actually referencing a specific view.\nIVibrateService\nAllows a developer to start and stop vibration of the device via a service.\nNote that this section is not always fully up-to-date, Catel might provide more services than listed here\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/replacing-default-components/","title":"Replacing the default components","tags":[],"description":"","content":" By default, Catel provides very fast and functional implementations of the component interfaces. It is possible though that one needs to use a different container than the specified ones.\nNote that when any component is replaced, it must be registered with the other instances that are already running. Catel cannot do this automatically because it is not aware how other (customized) components interact or require registration.  Replacing default components Starting with Catel 3.9, it is very easy to customize the components. This can be achieved by customizing the factory methods that are available on the IoCConfiguration class.\nNote that the customization of the IoCConfiguration is the **first **** thing that must be done at application start up  To replace any component, first create a custom implementation of the specific component, for example the IServiceLocator. Then update the factory and call UpdateDefaultComponents:\nCatel.IoC.IoCFactory.CreateServiceLocatorFunc = () =\u0026gt; new MyCustomServiceLocator(); Catel.IoC.IoCFactory.CreateTypeFactoryFunc = () =\u0026gt; new MyCustomTypeFactory(); Catel.IoC.IoCConfiguration.UpdateDefaultComponents();  At this moment, Catel will fully replace the components (in this case the IServiceLocator and ITypeFactory), but will keep using the default implementation of the IDependencyResolver.\nCreating IoC components in code It is best to respect the customization of the IoC components in the code. Therefore it is wise to always use the IoCFactory to create a ServiceLocator when a new instance is needed:\nvar serviceLocator = IoCFactory.CreateServiceLocator();  Catel will automatically create the right IDependencyResolver and ITypeFactory and register them in the newly created IServiceLocator.\n"},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/update-guides/","title":"Update guides","tags":[],"description":"","content":" Catel 4.0   Catel 4.1   Catel 5.0   Catel 5.4   "},{"uri":"https://docs.catelproject.com/vnext/catel-core/validation/using-validation-context/","title":"Using the validation context","tags":[],"description":"","content":" The *ViewModelBase* derives from *ModelBase*, thus all information here also applies to the *ViewModelBase*  Sometimes detailed information about validation is required. This is possible in Catel thanks to the ValidationContext class. The ValidationContext serves as the container for all validation results that are gathered via the available validation methods. The ValidationContext has lots of methods that all return lists of either IFieldValidationResult or IBusinessRuleValidationResult.\nThe examples below are shown a starter examples, but you can gather every type of validation result by using the ValidationContext. To retrieve the validation context of an object, use the following code:\nvar modelValidation = new MyViewModel() as IModelValidation; var validationContext = modelValidation.ValidationContext;  Getting the number of or warnings and errors  To retrieve the total number of warnings and errors, use the following code:\nint count = validationContext.GetValidationCount();  Getting all the field errors To retrieve all the field errors, use the following code:\nvar fieldErrors = validationContext.GetFieldErrors();  Getting all the field errors of a specific property  To retrieve all the field errors of a specific property, use the following code:\nvar fieldErrors = validationContext.GetFieldErrors(\u0026quot;MyProperty\u0026quot;);  Getting all the business rule warnings To retrieve all the business rule warnings:\nvar businessRuleWarnings = validationContext.GetBusinessRuleWarnings();  Getting all the business rule errors with a specific tag To retrieve all the business rule errors with a specific tag, use the following code:\nvar businessRuleErrors = validationContext.GetBusinessRuleErrors(\u0026quot;myTag\u0026quot;);  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/","title":"Catel.Core","tags":[],"description":"","content":" ApiCop   Argument checking   Caching   Configuration   Data handling   Exception handling   IoC (ServiceLocator and TypeFactory)   Logging   Messaging   Multilingual / Localization   Parallel invocation and tasks   Pooling   Preventing memory leaks   Reflection   Scoping   Serialization   Validation   "},{"uri":"https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-windows/","title":"Creating the views (windows)","tags":[],"description":"","content":" In this step we will create the windows for the application. In the previous step we already created the user controls. Windows are a great way to show in an edit-context. Catel provides great edit-windows in the form of the DataWindow. This is a window that automatically adds *OK* and *Cancel* buttons (but of course allows customization of the buttons and behavior).\nPerson window It is very important that the window derives from one of the Catel windows. This is required to make the binding system work (same as `UserControl`). Make sure that the window definition in the xaml is either `catel:Window` or `catel:DataWindow`  To add a new DataWindow, right-click the *Views* folder in the solution =\u0026gt; *Add* =\u0026gt; *New item\u0026hellip;* =\u0026gt; *On-line* =\u0026gt; and search for Catel as you can see in the screen below:\nGive the new view the name PersonWindow. The view will be added to the *Views* folder.\nNote that we can use the `PersonViewModel` for both the `PersonView` (user control) and `PersonWindow`. Both views represent the same models and view models, just a different context. To make sure that the `IUIVisualizerService` knows what view to pick first, register the `PersonWindow` in the `IUIVisualizerService` at application startup: ``` var uiVisualizerService = serviceLocator.ResolveType(); uiVisualizerService.Register(typeof(PersonViewModel), typeof(PersonWindow)); ```  The template will also create a constructor to inject a view model into the window. Please make sure that the constructor takes a view model of the type PersonViewModel instead of the generated PersonWindowModel. Then replace the content of the view with the xaml below:\n\u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;0\u0026quot; Grid.Column=\u0026quot;0\u0026quot; Content=\u0026quot;First name\u0026quot; /\u0026gt; \u0026lt;TextBox Grid.Row=\u0026quot;0\u0026quot; Grid.Column=\u0026quot;1\u0026quot; Text=\u0026quot;{Binding FirstName, ValidatesOnDataErrors=True, NotifyOnValidationError=True}\u0026quot; /\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;1\u0026quot; Grid.Column=\u0026quot;0\u0026quot; Content=\u0026quot;Last name\u0026quot; /\u0026gt; \u0026lt;TextBox Grid.Row=\u0026quot;1\u0026quot; Grid.Column=\u0026quot;1\u0026quot; Text=\u0026quot;{Binding LastName, ValidatesOnDataErrors=True, NotifyOnValidationError=True}\u0026quot; /\u0026gt; \u0026lt;/Grid\u0026gt;  Family window The FamilyWindow is a bit different because we want additional logic in this window. We want to create add / edit / remove buttons for the family members. Therefore we need to create a separate view model which contains this logic. Creating the FamilyWindowViewModel Since the FamilyWindowViewModel will look a lot like the FamilyViewModel, just copy/paste the FamilyViewModel and rename the copy to FamilyWindowViewModel.\nNote that the `FamilyWindowViewModel` needs additional logic, but that will be handled in the next part of this getting started guide  Creating the FamilyWindow Once the FamilyWindowViewModel is created, the FamilyWindow must be created exactly the same way as the PersonWindow. Again make sure to use the right view model (FamilyWindowViewModel) in the constructor of the window in the code-behind. Then use the following xaml:\n\u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;0\u0026quot; Grid.Column=\u0026quot;1\u0026quot; Content=\u0026quot;Family name\u0026quot; /\u0026gt; \u0026lt;TextBox Grid.Row=\u0026quot;0\u0026quot; Grid.Column=\u0026quot;1\u0026quot; Text=\u0026quot;{Binding FamilyName, NotifyOnValidationError=True, ValidatesOnDataErrors=True}\u0026quot; /\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;1\u0026quot; Grid.ColumnSpan=\u0026quot;2\u0026quot; Content=\u0026quot;Persons\u0026quot; /\u0026gt; \u0026lt;Grid Grid.Row=\u0026quot;2\u0026quot; Grid.ColumnSpan=\u0026quot;2\u0026quot;\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;ListBox Grid.Column=\u0026quot;0\u0026quot; ItemsSource=\u0026quot;{Binding Persons}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedPerson}\u0026quot;\u0026gt; \u0026lt;ListBox.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;views:PersonView DataContext=\u0026quot;{Binding}\u0026quot; /\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListBox.ItemTemplate\u0026gt; \u0026lt;/ListBox\u0026gt; \u0026lt;StackPanel Grid.Column=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;Button Command=\u0026quot;{Binding AddPerson}\u0026quot; Content=\u0026quot;Add...\u0026quot; /\u0026gt; \u0026lt;Button Command=\u0026quot;{Binding EditPerson}\u0026quot; Content=\u0026quot;Edit...\u0026quot; /\u0026gt; \u0026lt;Button Command=\u0026quot;{Binding RemovePerson}\u0026quot; Content=\u0026quot;Remove\u0026quot; /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt;  Up next Hooking up everything together\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/validation/getting-summary-of-validation-results/","title":"Getting a summary of validation results","tags":[],"description":"","content":" Sometimes you just need to get a summary of all warnings and errors of an object. All validation is gathered in the IValidationContext and available on that class. However, there are some convenience classes that allow a developer to create a summary based on a specific tag. This convenience class is IValidationSummary, which gathers the right information from an instance of IValidationContext.\nCreating a summary of all validations  To retrieve a summary of all validations from a IValidationContext, use the following code:\nvar validationSummary = validationContext.GetValidationSummary();  Creating a summary of all validations with a specific tag To retrieve a summary of all validations with a specific tag from a IValidationContext, use the following code:\nvar validationSummary = validationContext.GetValidationSummary(\u0026quot;tag\u0026quot;);  "},{"uri":"https://docs.catelproject.com/vnext/introduction/mvvm/introduction-to-nested-user-controls-problem/","title":"Introduction to the nested user controls problem","tags":[],"description":"","content":"One of the issues most users of MVVM face is that “nested user controls” problem. The problem is that most (actually all that we’ve seen) MVVM Frameworks only support one view model for a window (or if you’re lucky, a user control). However, the “nested user controls” problem raises lots of questions:\n What if the requirements are to build a dynamic UI where the nested user controls are loaded dynamically when they are required? What about validation in nested user controls? When should the nested user control view models be saved?  Most MVVM developers just answer: “Put all the properties of the nested user controls on the main view model”. Say that again? Are you kidding me? That’s not a real world solution for a real world problem. So, we as developers of Catel offer you a real world solution for the “nested user controls” problem in the form of the UserControl.\nThe real power of the UserControl class lays in the fact that it is able to construct view models dynamically based on its data context. So, the only thing the developers have to take care of is to set the right data context. Below is a graphical presentation of the “nested user controls” problem:\nAs the images above show, the method that Catel uses to solve the problem is much more professional. Below are a few reasons:\n Separation of concerns (each control has a view model only containing the information for itself, not for children); User controls are built so they can be re-used. Without the user controls to be able to have their own view models, how should one actually use user controls with MVVM?  The idea behind the user control is pretty complex, especially because XAML frameworks aren\u0026rsquo;t very good at runtime data context type changing. However, with a few workarounds (very well described in the source code of UserControl), it is possible to dynamically construct view models. The user control constructs the view model with or without a constructor as described earlier in this article. When the view model is constructed, the user control tries to find a (logical or visual) parent that implements the IViewModelContainer interface. Thanks to this interface, a view model can subscribe itself to a parent view model and the validation chain is created as shown below:\nAs the image above shows, all children in the chain are validated, and when the last child is validated, the view model reports the result of its children and itself back to its parent. This way, it is still possible to disable a command when one of the nested user control view models has an error.\nSaving a chain of nested view models works exactly the same as the validation. First, the view model saves all children, then itself and finally reports back its result to the parent.\nNow, let’s go to some “real-life” example. I don’t want to make it too complex, but not too easy as well, but don’t want to put the focus on the content of the data, but on the user control and view model creation. Therefore, I have chosen for the data model below:\nThe image shows that we have a house. In that house, we have multiple rooms. In each room, there can be several tables with chairs and beds. This shows a “complex” UI tree with lots of different user controls (each object has its own representation and thus user control). Now our goal is to create user controls that can be used in the window that shows the full house, but also in “sub-parts” and we want to be fully independent of the HouseWindowViewModel (which is the only view model that would be created in a regular MVVM Framework).\nThe example below shows only the Room control and the corresponding view model. The full source code of this article is provided in the source code repository of Catel, so the whole example is available if you are interested or need a more complete example.\nFirst, we start with a simple model. For the model, we use the ModelBase class. By using the provided code snippets, this model is setup within a minute:\n/// \u0026lt;summary\u0026gt; /// Bed class which fully supports serialization, property changed notifications, /// backwards compatibility and error checking. /// \u0026lt;/summary\u0026gt; [Serializable] public class Room : ModelBase\u0026lt;Room\u0026gt; { #region Constructor \u0026amp; destructor /// \u0026lt;summary\u0026gt; /// Initializes a new object from scratch. /// \u0026lt;/summary\u0026gt; public Room() : this(NameProperty.GetDefaultValue\u0026lt;string\u0026gt;()) { } /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;Room\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;name\u0026quot;\u0026gt;The name.\u0026lt;/param\u0026gt; public Room(string name) { // Create collections Tables = new ObservableCollection\u0026lt;Table\u0026gt;(); Beds = new ObservableCollection\u0026lt;Bed\u0026gt;(); // Store values Name = name; } /// \u0026lt;summary\u0026gt; /// Initializes a new object based on \u0026lt;see cref=\u0026quot;SerializationInfo\u0026quot;/\u0026gt;. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;info\u0026quot;\u0026gt;\u0026lt;see cref=\u0026quot;SerializationInfo\u0026quot;/\u0026gt; that contains the information.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;context\u0026quot;\u0026gt;\u0026lt;see cref=\u0026quot;StreamingContext\u0026quot;/\u0026gt;.\u0026lt;/param\u0026gt; protected Room(SerializationInfo info, StreamingContext context) : base(info, context) { } #endregion #region Properties /// \u0026lt;summary\u0026gt; /// Gets or sets the name. /// \u0026lt;/summary\u0026gt; public string Name { get { return GetValue\u0026lt;string\u0026gt;(NameProperty); } set { SetValue(NameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Name property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData NameProperty = RegisterProperty(\u0026quot;Name\u0026quot;, typeof(string), \u0026quot;Room\u0026quot;); /// \u0026lt;summary\u0026gt; /// Gets or sets the table collection. /// \u0026lt;/summary\u0026gt; public ObservableCollection\u0026lt;Table\u0026gt; Tables { get { return GetValue\u0026lt;ObservableCollection\u0026lt;Table\u0026gt;\u0026gt;(TablesProperty); } set { SetValue(TablesProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Tables property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData TablesProperty = RegisterProperty(\u0026quot;Tables\u0026quot;, typeof(ObservableCollection\u0026lt;Table\u0026gt;)); /// \u0026lt;summary\u0026gt; /// Gets or sets the bed collection. /// \u0026lt;/summary\u0026gt; public ObservableCollection\u0026lt;Bed\u0026gt; Beds { get { return GetValue\u0026lt;ObservableCollection\u0026lt;Bed\u0026gt;\u0026gt;(BedsProperty); } set { SetValue(BedsProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Beds property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData BedsProperty = RegisterProperty(\u0026quot;Beds\u0026quot;, typeof(ObservableCollection\u0026lt;Bed\u0026gt;)); #endregion }  Next, we are going to create the view model. Again, by the use of code snippets explained earlier in this article, the view model is set up within a few minutes:\n/// \u0026lt;summary\u0026gt; /// Room view model. /// \u0026lt;/summary\u0026gt; public class RoomViewModel : ViewModelBase { #region Variables private int _bedIndex = 1; private int _tableIndex = 1; #endregion #region Constructor \u0026amp; destructor /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;RoomViewModel\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; public RoomViewModel(Models.Room room) { // Store values Room = room; // Create commands AddTable = new Command(OnAddTableExecuted); AddBed = new Command(OnAddBedExecuted); } #endregion #region Properties /// \u0026lt;summary\u0026gt; /// Gets the title of the view model. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;The title.\u0026lt;/value\u0026gt; public override string Title { get { return \u0026quot;Room\u0026quot;; } } #region Models /// \u0026lt;summary\u0026gt; /// Gets or sets the room. /// \u0026lt;/summary\u0026gt; [Model] public Models.Room Room { get { return GetValue\u0026lt;Models.Room\u0026gt;(RoomProperty); } private set { SetValue(RoomProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Room property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData RoomProperty = RegisterProperty(\u0026quot;Room\u0026quot;, typeof(Models.Room)); #endregion #region View model /// \u0026lt;summary\u0026gt; /// Gets or sets the name. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Room\u0026quot;)] public string Name { get { return GetValue\u0026lt;string\u0026gt;(NameProperty); } set { SetValue(NameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Name property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData NameProperty = RegisterProperty(\u0026quot;Name\u0026quot;, typeof(string)); /// \u0026lt;summary\u0026gt; /// Gets or sets the table collection. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Room\u0026quot;)] public ObservableCollection\u0026lt;Models.Table\u0026gt; Tables { get { return GetValue\u0026lt;ObservableCollection\u0026lt;Models.Table\u0026gt;\u0026gt;(TablesProperty); } set { SetValue(TablesProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Tables property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData TablesProperty = RegisterProperty(\u0026quot;Tables\u0026quot;, typeof(ObservableCollection\u0026lt;Models.Table\u0026gt;)); /// \u0026lt;summary\u0026gt; /// Gets or sets the bed collection. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Room\u0026quot;)] public ObservableCollection\u0026lt;Models.Bed\u0026gt; Beds { get { return GetValue\u0026lt;ObservableCollection\u0026lt;Models.Bed\u0026gt;\u0026gt;(BedsProperty); } set { SetValue(BedsProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Beds property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData BedsProperty = RegisterProperty(\u0026quot;Beds\u0026quot;, typeof(ObservableCollection\u0026lt;Models.Bed\u0026gt;)); #endregion #endregion #region Commands /// \u0026lt;summary\u0026gt; /// Gets the AddTable command. /// \u0026lt;/summary\u0026gt; public Command AddTable { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the AddTable command is executed. /// \u0026lt;/summary\u0026gt; private void OnAddTableExecuted() { Tables.Add(new Models.Table(string.Format(\u0026quot;Table {0}\u0026quot;, _tableIndex++))); } /// \u0026lt;summary\u0026gt; /// Gets the AddBed command. /// \u0026lt;/summary\u0026gt; public Command AddBed { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the AddBed command is executed. /// \u0026lt;/summary\u0026gt; private void OnAddBedExecuted() { Beds.Add(new Models.Bed(string.Format(\u0026quot;Bed {0}\u0026quot;, _bedIndex++))); } #endregion }  As you can see, the view model can only be constructed by passing a Room model object. It is very important to be aware of this construction. The reason that there is no empty constructor is because there is no support for views that do not represent a Room model.\nIn the view model, the properties of the Room model are mapped by the use of the Model attribute and the ViewModelToModel attribute. Last but not least, commands are defined to be able to add new tables and beds to the Room model.\nAnother way to add a new user control is to use the item templates\nNow the model and the view model are fully set up, the last thing to do is to create the actual view. To accomplish this, add a new WPF user control to the project. First thing to do is to implement the code-behind, since that is the easiest to do:\n\u0026lt;summary\u0026gt; /// Interaction logic for Room.xaml /// \u0026lt;/summary\u0026gt; public partial class Room : UserControl { /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;Room\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; public Room() { // Initialize component InitializeComponent(); } }  The only thing we changed from the default user control template is that the user control now derives from Catel.Windows.Controls.UserControl control instead of the default System.Windows.Controls.UserControl control. This is it for the code-behind, let’s move up to the view.\nThe last thing to do now is the actual xaml view. For the sake of simplicity, the actual content is left out (it’s just a grid with a textbox and itemscontrols for the children):\n\u0026lt;catel:UserControl x:Class=\u0026quot;Catel.Articles._03___MVVM.Examples.NestedUserControls.Room\u0026quot; xmlns=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026quot; xmlns:x=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot; xmlns:NestedUserControls=\u0026quot;clr-namespace:Catel.Articles._03___MVVM.Examples.NestedUserControls\u0026quot;\u0026gt; \u0026lt;!-- For the sake of simplicity, the content is left out --\u0026gt; \u0026lt;/catel:UserControl\u0026gt;  A few things are very important to notice in the xaml code shown above. The first thing to notice is that (like the code-behind), the base class is now catel:UserControl instead of UserControl.\nThat’s all that can be learned about solving the “nested user control” problem. We have set up the model, view model and finally the view. Now, let’s take a look at how it looks in a screenshot (and notice the construction time of the view model, they are really constructed on-demand):\nThe red border is the control that we just created. It shows the name of the room, the view model construction time and the child objects (inside expanders).\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/data-handling/savablemodelbase/","title":"SavableModelBase","tags":[],"description":"","content":"The SavableModelBase class extends the [ModelBase](/vnext/catel-core/data-handling/modelbase/) class with functionality to save the model to a persistence store.\nNote that the `SavableModelBase` is just a convenience implementation. The `ModelBase` can be serialized by any `ISerializer` implementation as well.  More documentation should be written in the future  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/","title":"Catel.MVVM","tags":[],"description":"","content":"The last few years, MVVM has become the number one pattern to write applications using WPF and other XAML related platforms. The actual pattern is very simple, but there are some flaws and questions lots of MVVM users have, such as:\n How to show modal dialogs or message boxes inside a View-Model? How to run processes inside a View-Model? How to let the user select a file inside a View-Model?  In my opinion, this is where the good frameworks separate themselves from the bad ones. For example, people actually calling MessageBox.Show inside a View-Model are using the pattern wrong. If you are one of the developers that directly call a MessageBox inside a View-Model, ask yourself this: who is going to click the button during a unit test?\nBefore we actually started developing Catel, we did lots of investigations to make sure that the MVVM pattern was really useful in Line of Business (LoB) applications and does not miss the finishing touch. Thanks to this investigation and research, we created a solid MVVM framework which solves all the known problems of the MVVM pattern.\nThis part of the documentation explains all about the MVVM framework included with Catel. The MVVM framework that ships with Catel has the following characteristics and features:\n Very easy to use, a view model is created within 10 minutes Direct pass-through of view model properties to Models Validation mapping from model to view model and back Solves the nested user controls problem   Auditing   Behaviors \u0026amp; triggers   Bindings   Commands \u0026amp; events   Converters   Designers   Locators \u0026amp; naming conventions   Services   View models   Views   "},{"uri":"https://docs.catelproject.com/vnext/catel-core/data-handling/childawaremodelbase/","title":"ChildAwareModelBase","tags":[],"description":"","content":"The ChildAwareModelBase class extends the [ModelBase](/vnext/catel-core/data-handling/modelbase/) class with functionality to get change notifications of child objects of the model. The class uses the ChangeNotificationWrapper to subscribe to all child objects using weak events.\nMore documentation should be written in the future  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/validation/deferring-validation/","title":"Deferring validation","tags":[],"description":"","content":" The opinions about validation differ from person to person. Some people think it is best practice to immediately show the errors to the users. Others want to defer it to the moment where the user clicks the Save or OK button. Catel supports both \u0026ldquo;best practices\u0026rdquo;.\nSuspending validation for a batch of changes Sometimes you need to change a batch of properties and don\u0026rsquo;t want validation to be called after every property change. This can be accomplished by using the following code inside a ModelBase class:\nSuspendValidation = true; // change several properties here SuspendValidation = false; // Now force validation Validate(true);  Deferring validation in view models Below is a table of properties that can be used to affect the validation deferring.\n   Property Validate immediately Defer to a later moment     DeferValidationUntilFirstSaveCall false true   ValidateModelsOnInitialization true false    If the DeferValidationUntilFirstSaveCall property, is used, it must be set as first property in the view model because the validation kicks in immediately when properties change.  "},{"uri":"https://docs.catelproject.com/vnext/getting-started/wpf/hooking-up-everything-together/","title":"Hooking up everything together","tags":[],"description":"","content":" In this step we will hook everything together and add additional logic to the remaining view models.\nHooking up the view models We now have most of the application ready. However we need some logic in the view models to hook up everything together.\nAdding additional logic to FamilyWindowViewModel The first thing we are going to do is to finalize the FamilyWindowViewModel we created in the previous step. To do this, we are going to add a few properties and commands to the view model.\nAdding additional dependencies being injected Since we will be using additional services inside the FamilyWindowViewModel, it is important to add them as dependency via the constructor. The updated constructor will look like this:\npublic FamilyWindowViewModel(Family family, IUIVisualizerService uiVisualizerService, IMessageService messageService) { Argument.IsNotNull(() =\u0026gt; family); Argument.IsNotNull(() =\u0026gt; uiVisualizerService); Argument.IsNotNull(() =\u0026gt; messageService); Family = family; _uiVisualizerService = uiVisualizerService; _messageService = messageService; }  Don't forget to create the right backing fields `_uiVisualizerService` and `_messageService`  Adding the properties We need a property representing the currently selected person in edit mode of a family. Below is the property definition which needs to be added to the view model:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the selected person. /// \u0026lt;/summary\u0026gt; public Person SelectedPerson { get { return GetValue\u0026lt;Person\u0026gt;(SelectedPersonProperty); } set { SetValue(SelectedPersonProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the SelectedPerson property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData SelectedPersonProperty = RegisterProperty(\u0026quot;SelectedPerson\u0026quot;, typeof(Person), null);  Adding the commands Note that we recommend that you use the *vmtaskcommand* and *vmtaskcommandwithcanexecute* code snippets available [here](http://www.catelproject.com/download/general-files/)  Below is the code which comes in two parts.\n1. Add this code to the constructor:\nAddPerson = new TaskCommand(OnAddPersonExecuteAsync); EditPerson = new TaskCommand(OnEditPersonExecuteAsync, OnEditPersonCanExecute); RemovePerson = new TaskCommand(OnRemovePersonExecuteAsync, OnRemovePersonCanExecute);   You must import Catel.IoC namespace since it contains ViewModelBase\u0026rsquo;s GetTypeFactory() extension method used below.\nusing Catel.IoC;  Add this code to the view model itself:\n /// \u0026lt;summary\u0026gt; /// Gets the AddPerson command. /// \u0026lt;/summary\u0026gt; public TaskCommand AddPerson { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the AddPerson command is executed. /// \u0026lt;/summary\u0026gt; private async Task OnAddPersonExecuteAsync() { var person = new Person(); person.LastName = FamilyName; // Note that we use the type factory here because it will automatically take care of any dependencies // that the PersonViewModel will add in the future var typeFactory = this.GetTypeFactory(); var personViewModel = typeFactory.CreateInstanceWithParametersAndAutoCompletion\u0026lt;PersonViewModel\u0026gt;(person); if (await _uiVisualizerService.ShowDialogAsync(personViewModel) ?? false) { Persons.Add(person); } } /// \u0026lt;summary\u0026gt; /// Gets the EditPerson command. /// \u0026lt;/summary\u0026gt; public TaskCommand EditPerson { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to check whether the EditPerson command can be executed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if the command can be executed; otherwise \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;\u0026lt;/returns\u0026gt; private bool OnEditPersonCanExecute() { return SelectedPerson != null; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the EditPerson command is executed. /// \u0026lt;/summary\u0026gt; private async Task OnEditPersonExecuteAsync() { // Note that we use the type factory here because it will automatically take care of any dependencies // that the PersonViewModel will add in the future var typeFactory = this.GetTypeFactory(); var personViewModel = typeFactory.CreateInstanceWithParametersAndAutoCompletion\u0026lt;PersonViewModel\u0026gt;(SelectedPerson); await _uiVisualizerService.ShowDialogAsync(personViewModel); } /// \u0026lt;summary\u0026gt; /// Gets the RemovePerson command. /// \u0026lt;/summary\u0026gt; public TaskCommand RemovePerson { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to check whether the RemovePerson command can be executed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if the command can be executed; otherwise \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;\u0026lt;/returns\u0026gt; private bool OnRemovePersonCanExecute() { return SelectedPerson != null; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the RemovePerson command is executed. /// \u0026lt;/summary\u0026gt; private async Task OnRemovePersonExecuteAsync() { if (await _messageService.ShowAsync(string.Format(\u0026quot;Are you sure you want to delete the person '{0}'?\u0026quot;, SelectedPerson), \u0026quot;Are you sure?\u0026quot;, MessageButton.YesNo, MessageImage.Question) == MessageResult.Yes) { Persons.Remove(SelectedPerson); SelectedPerson = null; } }   Adding additional logic to the MainWindowViewModel The same edit functionality we added to the FamilyWindowViewModel must be added to the MainWindowViewModel. The difference is that instead of adding / editing / removing persons, the MainWindowViewModel will do this for families.\nAdding additional dependencies being injected We will again need additional dependencies. Below is the updated constructor for the MainWindowViewModel:\npublic MainWindowViewModel(IFamilyService familyService, IUIVisualizerService uiVisualizerService, IMessageService messageService) { Argument.IsNotNull(() =\u0026gt; familyService); Argument.IsNotNull(() =\u0026gt; uiVisualizerService); Argument.IsNotNull(() =\u0026gt; messageService); _familyService = familyService; _uiVisualizerService = uiVisualizerService; _messageService = messageService; }  Adding the properties We will again need a property to handle the selected family:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the selected family. /// \u0026lt;/summary\u0026gt; public Family SelectedFamily { get { return GetValue\u0026lt;Family\u0026gt;(SelectedFamilyProperty); } set { SetValue(SelectedFamilyProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the SelectedFamily property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData SelectedFamilyProperty = RegisterProperty(\u0026quot;SelectedFamily\u0026quot;, typeof(Family), null);  Adding the commands Last but not least, we will also add the commands to the MainWindowViewModel to handle the logic.\n1. Add this code to the constructor:\nAddFamily = new TaskCommand(OnAddFamilyExecuteAsync); EditFamily = new TaskCommand(OnEditFamilyExecuteAsync, OnEditFamilyCanExecute); RemoveFamily = new TaskCommand(OnRemoveFamilyExecuteAsync, OnRemoveFamilyCanExecute);   Add this code to the view model itself:\n/// \u0026lt;summary\u0026gt; /// Gets the AddFamily command. /// \u0026lt;/summary\u0026gt; public TaskCommand AddFamily { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the AddFamily command is executed. /// \u0026lt;/summary\u0026gt; private async Task OnAddFamilyExecuteAsync() { var family = new Family(); // Note that we use the type factory here because it will automatically take care of any dependencies // that the FamilyWindowViewModel will add in the future var typeFactory = this.GetTypeFactory(); var familyWindowViewModel = typeFactory.CreateInstanceWithParametersAndAutoCompletion\u0026lt;FamilyWindowViewModel\u0026gt;(family); if (await _uiVisualizerService.ShowDialogAsync(familyWindowViewModel) ?? false) { Families.Add(family); } } /// \u0026lt;summary\u0026gt; /// Gets the EditFamily command. /// \u0026lt;/summary\u0026gt; public TaskCommand EditFamily { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to check whether the EditFamily command can be executed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if the command can be executed; otherwise \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;\u0026lt;/returns\u0026gt; private bool OnEditFamilyCanExecute() { return SelectedFamily != null; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the EditFamily command is executed. /// \u0026lt;/summary\u0026gt; private async Task OnEditFamilyExecuteAsync() { // Note that we use the type factory here because it will automatically take care of any dependencies // that the PersonViewModel will add in the future var typeFactory = this.GetTypeFactory(); var familyWindowViewModel = typeFactory.CreateInstanceWithParametersAndAutoCompletion\u0026lt;FamilyWindowViewModel\u0026gt;(SelectedFamily); await _uiVisualizerService.ShowDialogAsync(familyWindowViewModel); } /// \u0026lt;summary\u0026gt; /// Gets the RemoveFamily command. /// \u0026lt;/summary\u0026gt; public TaskCommand RemoveFamily { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to check whether the RemoveFamily command can be executed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if the command can be executed; otherwise \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;\u0026lt;/returns\u0026gt; private bool OnRemoveFamilyCanExecute() { return SelectedFamily != null; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the RemoveFamily command is executed. /// \u0026lt;/summary\u0026gt; private async Task OnRemoveFamilyExecuteAsync() { if (await _messageService.ShowAsync(string.Format(\u0026quot;Are you sure you want to delete the family '{0}'?\u0026quot;, SelectedFamily), \u0026quot;Are you sure?\u0026quot;, MessageButton.YesNo, MessageImage.Question) == MessageResult.Yes) { Families.Remove(SelectedFamily); SelectedFamily = null; } }   Hooking up the views We now have all the views ready, but we don\u0026rsquo;t see anything yet. The reason for this is that we haven\u0026rsquo;t modified the MainWindow view yet. To do so, replace the xaml content with the xaml below:\n \u0026lt;Grid\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;100\u0026quot; /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;ListBox Grid.Column=\u0026quot;0\u0026quot; ItemsSource=\u0026quot;{Binding Families}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedFamily}\u0026quot;\u0026gt; \u0026lt;ListBox.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;views:FamilyView DataContext=\u0026quot;{Binding}\u0026quot; /\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListBox.ItemTemplate\u0026gt; \u0026lt;/ListBox\u0026gt; \u0026lt;StackPanel Grid.Column=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;Button Command=\u0026quot;{Binding AddFamily}\u0026quot; Content=\u0026quot;Add...\u0026quot; /\u0026gt; \u0026lt;Button Command=\u0026quot;{Binding EditFamily}\u0026quot; Content=\u0026quot;Edit...\u0026quot; /\u0026gt; \u0026lt;Button Command=\u0026quot;{Binding RemoveFamily}\u0026quot; Content=\u0026quot;Remove\u0026quot; /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/Grid\u0026gt;  Now run the application and you should see your fully functional family management application.\nUp next Finalizing the application\n"},{"uri":"https://docs.catelproject.com/vnext/catel-fody/","title":"Catel.Fody","tags":[],"description":"","content":" Catel.Fody is an addin for Fody (see https://github.com/Fody/Fody), which is an extensible tool for weaving .net assemblies. This addin will rewrite simple properties to the dependency-property alike properties that are used inside Catel.\nIt will rewrite all properties on the ObservableObject, ModelBase and ViewModelBase. So, a property that is written as this:\npublic string FirstName { get; set; }  will be weaved into:\nModelBase \u0026amp; ViewModelBase\npublic string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string));  ObservableObject\nprivate string _firstName; public string FirstName { get { return _firstName; } set { _firstName = value; RaisePropertyChanged(nameof(FirstName)); } }  Computed properties\nIf a readonly computed property like this one exists:\npublic string FullName { get { return string.Format(\u0026quot;{0} {1}\u0026quot;, FirstName, LastName).Trim(); } }  the OnPropertyChanged method will be also weaved into\nprotected override void OnPropertyChanged(AdvancedPropertyChangedEventArgs e) { base.OnPropertyChanged(e); if (e.PropertyName.Equals(\u0026quot;FirstName\u0026quot;)) { base.RaisePropertyChanged(\u0026quot;FullName\u0026quot;); } if (e.PropertyName.Equals(\u0026quot;LastName\u0026quot;)) { base.RaisePropertyChanged(\u0026quot;FullName\u0026quot;); } }  Enabling Catel.Fody To enable Catel.Fody to weave assemblies, you need to perform the following steps:\n Install the Catel.Fody NuGet package Update FodyWeavers.xml and make sure it contains    Note that the FodyWeavers.xml should be updated automatically when\n Disabling weaving for specific types or properties To disable the weaving of types or properties of a type, decorate it with the NoWeaving attribute as shown in the example below:\n[NoWeaving] public class MyClass : ModelBase { ... }  Configuring Catel.Fody Though we recommend to leave the default settings (great for most people), it is possible to configure the weaver. Below is a list of options that can be configured.\nTo configure an option, modify FodyWeavers.xml by adding the property and value to the Catel element. For example, the example below will disable argument and logging weaving:\n\u0026lt;Catel WeaveArguments=\u0026quot;false\u0026quot; WeaveLogging=\u0026quot;false\u0026quot; /\u0026gt;  WeaveProperties Weave all regular properties on classes that inherit (directly or indirectly) from Catel.Data.ModelBase into Catel properties.\n Default value is true\n WeaveExposedProperties Weave all Catel properties decorated with both the Catel.MVVM.Model attribute and Fody.Expose attribute as automatic mappings,\n Default value is true\n WeaveArguments Weave all Argument check attributes into actual argument checks.\n Default value is true\n WeaveLogging Weave all calls to LogManager.GetCurrentClassLogger() into LogManager.GetLogger(typeof(classname)).\n Default value is true\n GenerateXmlSchemas Generate xml schemas for all classes that inherit (directly or indirectly) from Catel.Data.ModelBase.\n Default value is false\n Weaving properties It is possible to automatically weave a simple property into a Catel property (ModelBase or ViewModelBase) or a property with automatic change notifications (ObservableObject).\nThe following property definition:\npublic string Name { get; set; }  will be weaved into:\nModelBase \u0026amp; ViewModelBase\npublic string Name { get { return GetValue\u0026lt;string\u0026gt;(NameProperty); } set { SetValue(NameProperty, value); } } public static readonly PropertyData NameProperty = RegisterProperty(\u0026quot;Name\u0026quot;, typeof(string));  ObservableObject\nprivate string _name; public string Name { get { return _name; } set { _name = value; RaisePropertyChanged(nameof(Name)); } }  Support for computed properties If a computed property like this one exists:\npublic string FullName { get { return string.Format(\u0026quot;{0} {1}\u0026quot;, FirstName, LastName).Trim(); } }  the OnPropertyChanged method will be also weaved into\nprotected override void OnPropertyChanged(AdvancedPropertyChangedEventArgs e) { base.OnPropertyChanged(e); if (e.PropertyName.Equals(\u0026quot;FirstName\u0026quot;)) { base.RaisePropertyChanged(\u0026quot;FullName\u0026quot;); } if (e.PropertyName.Equals(\u0026quot;LastName\u0026quot;)) { base.RaisePropertyChanged(\u0026quot;FullName\u0026quot;); } }  In order to avoid this behavior, you can use the NoWeaving attribute on the computed property, just like this:\n[NoWeaving] public string FullName { get { return string.Format(\u0026quot;{0} {1}\u0026quot;, FirstName, LastName).Trim(); } }  In the background, Catel.Fody will handle the following workflow:\n Find all types in the assembly deriving from ObservableObject, ModelBase and ViewModelBase Check if the type has an automatic property backing field (only those properties are weaved) Add the PropertyData field for the property Instantiate the PropertyData field in the static constructor of the type Replace the content of the getter and setter with the appropriate calls to GetValue and SetValue Note that this feature is automatically disabled for classes that already override the OnPropertyChanged method. It is too complex to determine where the logic should be added so the end-developer is responsible for implementing this feature when overriding OnPropertyChanged   Automatically excluded properties By default, Catel.Fody ignores the following properties and types by default because they shouldn\u0026rsquo;t be weaved:\n All properties of type ICommand Properties without an automatically generated backing field (thus properties with a custom implementation)  Specifying default values for weaved properties By default, Catel uses null as default values for reference types. For value types, it will use default(T). To specify the default value of a weaved property, use the DefaultValue attribute as shown in the example below:\npublic class Person : ModelBase { [DefaultValue(\u0026quot;Geert\u0026quot;)] public string FirstName { get; set; } public string LastName { get; set; } }  This will be weaved into:\npublic class Person : ModelBase { public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string), \u0026quot;Geert\u0026quot;); public string LastName { get { return GetValue\u0026lt;string\u0026gt;(LastNameProperty); } set { SetValue(LastNameProperty, value); } } public static readonly PropertyData LastNameProperty = RegisterProperty(\u0026quot;LastName\u0026quot;, typeof(string), null); }  How to get automatic change notifications The Fody plugin for Catel automatically searches for the On[PropertyName]Changed methods. If a method is found, it will automatically be called when the property has changed. For example, the OnNameChanged is automatically called when the Name property is changed in the example below:\npublic string Name { get; set; } private void OnNameChanged() { // this method is automatically called when the Name property changes }  Excluding properties from backup By default, properties generated by Catel.Fody are included in the backup mechanism of Catel models. To control the IncludeInBackup feature of Catel, one can use the ExcludeFromBackup attribute on properties:\n[ExcludeFromBackup] public string Name { get; set; }  will be weaved into:\npublic string Name { get { return GetValue\u0026lt;string\u0026gt;(NameProperty); } set { SetValue(NameProperty, value); } } public static readonly PropertyData NameProperty = RegisterProperty(\u0026quot;Name\u0026quot;, typeof(string), includeInBackup: false);  Weaving argument checks With the Catel.Fody plugin, it is possible to automatically weave a method implementation with its own argument check operations declared via attributes.\nAutomatic performance improvements The latest version of Catel.Fody automatically converts all expression argument checks to faster calls. For example, the code below:\nArgument.IsNotNull(() =\u0026gt; myString);  Will automatically be weaved into this:\nArgument.IsNotNull(\u0026quot;myString\u0026quot;, myString);  This is much faster because the expression doesn\u0026rsquo;t have to be parsed at runtime. This is a very noticeable performance boost if the expression check is used more than 50 times per second.\nWhen using the latest version of Catel.Fody, the team recommends using expressions above the regular argument checks (with name and value specified separately) because it will result in cleaner code. With this feature, there is no longer a performance penalty for using the expressions version  Argument checking via attributes The following method definition:\npublic void DoSomething([NotNullOrEmpty] string myString. [NotNull] object myObject) { }  Will be weaved into:\npublic void DoSomething(string myString, object myObject) { Argument.IsNotNullOrEmpty(\u0026quot;myString\u0026quot;, myString); Argument.IsNotNull(\u0026quot;myObject\u0026quot;, myObject); }  In the background, Catel.Fody will handle the following workflow:\n Find all types in the assembly Find all method of each type Find all annotated method parameter of each method Insert as first instructions of the method body the calls to Argument check corresponding methods.  Available argument check Catel.Fody attributes  NotNull =\u0026gt; Argument.IsNotNull NotNullOrEmptyArray =\u0026gt; Argument.IsNotNullOrEmptyArray NotNullOrEmpty =\u0026gt; Argument.IsNotNullOrEmpty NotNullOrWhitespace =\u0026gt; Argument.IsNotNullOrWhitespace Match =\u0026gt; Argument.IsMatch NotMatch =\u0026gt; Argument.IsNotMatch NotOutOfRange =\u0026gt; Argument.IsNotOutOfRange Maximum =\u0026gt; Argument.IsMaximum Minimal =\u0026gt; Argument.IsMinimal OfType =\u0026gt; Argument.IsOfType ImplementsInterface =\u0026gt; Argument.ImplementsInterface InheritsFrom =\u0026gt; Argument.InheritsFrom  Exposing properties on view models The way to expose properties of a model to the view model in Catel is the ViewModelToModelAttribute. The goal of these attributes is to easily map properties from a model to the view model so as much of the plumbing (setting/getting properties, rechecking validation, etc) is done automatically for the developer.\nUsing the ViewModelToModelAttribute, this is the syntax to map properties automatically:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the person. /// \u0026lt;/summary\u0026gt; [Model] public Person Person { get { return GetValue\u0026lt;Person\u0026gt;(PersonProperty); } private set { SetValue(PersonProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Person property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData PersonProperty = RegisterProperty(\u0026quot;Person\u0026quot;, typeof(Person)); /// \u0026lt;summary\u0026gt; /// Gets or sets the first name. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Person\u0026quot;)] public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FirstName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string));  However, if you only define the FirstName property just to protect your model, then why should you define the whole property? This is where the ExposeAttribute property comes in very handy. This attribute internally registers a new dynamic property on the view model, and then uses the same technique as the ViewModelToModelAttribute.\nBelow is the new way you can easily expose properties of a model and protect other properties of the model from the view:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the person. /// \u0026lt;/summary\u0026gt; [Model] [Expose(\u0026quot;FirstName\u0026quot;)] [Expose(\u0026quot;MiddleName\u0026quot;)] [Expose(\u0026quot;LastName\u0026quot;)] private Person Person { get { return GetValue\u0026lt;Person\u0026gt;(PersonProperty); } set { SetValue(PersonProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Person property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData PersonProperty = RegisterProperty(\u0026quot;Person\u0026quot;, typeof(Person));  This is a very cool feature that allows you to protect your model without having to re-define all the properties on the view model. Also, the validation in the model is automatically synchronized with the view model when you use this attribute.\nIn combination with the automatic property weaving, this could be written as clean as the code below:\n[Model] [Expose(\u0026quot;FirstName\u0026quot;)] [Expose(\u0026quot;MiddleName\u0026quot;)] [Expose(\u0026quot;LastName\u0026quot;)] private Person Person { get; set; }  XmlSchema generation to start of metadata\nThe .NET framework supports XmlSchema attributes to allow static members to define a custom schema method required for WCF serialization. Unfortunately this cannot be implemented in Catel itself because it would required too much reflection and the method is static. Therefore this feature included in Catel.Fody.\nStarting with Catel.Fody 2.0, this feature is disabled by default. To enabled it, use the following option in FodyWeavers.xml:\n\u0026lt;Catel GenerateXmlSchemas=\u0026quot;true\u0026quot; /\u0026gt;  When the XmlSchemaProvider is available on the target platform where Catel is used, the changes will be made to classes deriving from ModelBase:\n1. Decorate the class with XmlSchemaProvider attribute:\n[XmlSchemaProvider(\u0026quot;GetXmlSchemaForCatelFodyTestAssemblyInheritedClass\u0026quot;)] public class InheritedClass : BaseClass { // rest of the class definition }  2. Implement the class specific GetXmlSchema method:\n[CompilerGenerated] public static XmlQualifiedName GetXmlSchemaForCatelFodyTestAssemblyInheritedClass(XmlSchemaSet xmlSchemaSet) { Type type = typeof(InheritedClass); return XmlSchemaManager.GetXmlSchema(type, xmlSchemaSet); }  "},{"uri":"https://docs.catelproject.com/vnext/getting-started/wpf/finalizing-the-application/","title":"Finalizing the application","tags":[],"description":"","content":" The application we have created so far is fully functional, but misses a bit of the \u0026ldquo;magic\u0026rdquo;. Below are some additional steps that might make your application more appealing and more user friendly. Of course you can go as far as you want by creating custom animations and such, but this guide focuses purely on making the basics more appealing.\nAdding validation Adding validation with Catel is extremely easy. There are two flavors to pick from, but they work exactly the same (since both the models and view models internally derive from ValidatableModelBase). To add validation to the Person model, use this code:\nprotected override void ValidateFields(List\u0026lt;IFieldValidationResult\u0026gt; validationResults) { if (string.IsNullOrWhiteSpace(FirstName)) { validationResults.Add(FieldValidationResult.CreateError(FirstNameProperty, \u0026quot;The first name is required\u0026quot;)); } if (string.IsNullOrWhiteSpace(LastName)) { validationResults.Add(FieldValidationResult.CreateError(LastNameProperty, \u0026quot;The last name is required\u0026quot;)); } }  The validation for the Family model is very easy as well:\nprotected override void ValidateFields(List\u0026lt;IFieldValidationResult\u0026gt; validationResults) { if (string.IsNullOrWhiteSpace(FamilyName)) { validationResults.Add(FieldValidationResult.CreateError(FamilyNameProperty, \u0026quot;The family name is required\u0026quot;)); } }  Note that this validation code can be used in both the model and/or the view models  Adding behaviors to enable double-click on the list boxes The user must manually click the Edit buttons in the editable views to edit a specific model. To make it easier for the user, we can enable double click to command behaviors. To do so, navigate to the MainWindow and add this to the ListBox definition:\n\u0026lt;ListBox x:Name=\u0026quot;listBox\u0026quot; ItemsSource=\u0026quot;{Binding Families}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedFamily}\u0026quot;\u0026gt; \u0026lt;ListBox.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:DoubleClickToCommand Command=\u0026quot;{Binding ElementName=listBox, Path=DataContext.EditFamily}\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;views:FamilyView DataContext=\u0026quot;{Binding}\u0026quot; /\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListBox.ItemTemplate\u0026gt; \u0026lt;/ListBox\u0026gt;  The same goes for the FamilyWindow:\n\u0026lt;ListBox x:Name=\u0026quot;listBox\u0026quot; ItemsSource=\u0026quot;{Binding Persons}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedPerson}\u0026quot;\u0026gt; \u0026lt;ListBox.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:DoubleClickToCommand Command=\u0026quot;{Binding ElementName=listBox, Path=DataContext.EditPerson}\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;views:PersonView DataContext=\u0026quot;{Binding}\u0026quot; /\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListBox.ItemTemplate\u0026gt; \u0026lt;/ListBox\u0026gt;  Note that the `xmlns:i=\"http://schemas.microsoft.com/expression/2010/interactivity\"` must be added in order for the code above to compile  Adding search functionality to the main window A functionality that is needed in a lot of applications is search functionality. To implement this we will need to modify the MainWindowViewModel. Below are the steps required to implement search functionality.\nAdding additional properties to the view model Lets start by adding the additional properties required to implement searching in the MainWindowViewModel:\n/// \u0026lt;summary\u0026gt; /// Gets the filtered families. /// \u0026lt;/summary\u0026gt; public ObservableCollection\u0026lt;Family\u0026gt; FilteredFamilies { get { return GetValue\u0026lt;ObservableCollection\u0026lt;Family\u0026gt;\u0026gt;(FilteredFamiliesProperty); } private set { SetValue(FilteredFamiliesProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FilteredFamilies property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FilteredFamiliesProperty = RegisterProperty(\u0026quot;FilteredFamilies\u0026quot;, typeof(ObservableCollection\u0026lt;Family\u0026gt;)); /// \u0026lt;summary\u0026gt; /// Gets or sets the search filter. /// \u0026lt;/summary\u0026gt; public string SearchFilter { get { return GetValue\u0026lt;string\u0026gt;(SearchFilterProperty); } set { SetValue(SearchFilterProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the SearchFilter property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData SearchFilterProperty = RegisterProperty(\u0026quot;SearchFilter\u0026quot;, typeof(string), null, (sender, e) =\u0026gt; ((MainWindowViewModel)sender).UpdateSearchFilter());  Note that this property contains an additional change callback function which will be called when the property has changed.  Add the following import to the view model. You will needed because native ObservableCollection class does not support ReplaceRange()\nusing Catel.Collections;  Add this method to the view model:\n/// \u0026lt;summary\u0026gt; /// Updates the filtered items. /// \u0026lt;/summary\u0026gt; private void UpdateSearchFilter() { if (FilteredFamilies == null) { FilteredFamilies = new ObservableCollection\u0026lt;Family\u0026gt;(); } if (string.IsNullOrWhiteSpace(SearchFilter)) { FilteredFamilies.ReplaceRange(Families); } else { var lowerSearchFilter = SearchFilter.ToLower(); FilteredFamilies.ReplaceRange(from family in Families where !string.IsNullOrWhiteSpace(family.FamilyName) \u0026amp;\u0026amp; family.FamilyName.ToLower().Contains(lowerSearchFilter) select family); } }  Then, add this code to the OnAddFamilyExecute function:\nprivate async Task OnAddFamilyExecuteAsync() { var family = new Family(); // Note that we use the type factory here because it will automatically take care of any dependencies // that the FamilyWindowViewModel will add in the future var typeFactory = this.GetTypeFactory(); var familyWindowViewModel = typeFactory.CreateInstanceWithParametersAndAutoCompletion\u0026lt;FamilyWindowViewModel\u0026gt;(family); if (await _uiVisualizerService.ShowDialog(familyWindowViewModel) ?? false) { Families.Add(family); UpdateSearchFilter(); } }  Last but not least, add this to the InitializeAsync method after the Families is set from the IFamilyService\nprotected override async Task InitializeAsync() { var families = _familyService.LoadFamilies(); Families = new ObservableCollection\u0026lt;Family\u0026gt;(families); UpdateSearchFilter(); }  Adding the search functionality to the view Replace the xaml of the main window by the following content:\n \u0026lt;Grid\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;RowDefinition Height=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;100\u0026quot; /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Grid Grid.Row=\u0026quot;0\u0026quot; Grid.ColumnSpan=\u0026quot;2\u0026quot;\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;Auto\u0026quot; /\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Label Grid.Row=\u0026quot;0\u0026quot; Grid.Column=\u0026quot;0\u0026quot; Content=\u0026quot;Filter:\u0026quot; /\u0026gt; \u0026lt;TextBox Grid.Row=\u0026quot;0\u0026quot; Grid.Column=\u0026quot;1\u0026quot; Text=\u0026quot;{Binding SearchFilter}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:UpdateBindingOnTextChanged UpdateDelay=\u0026quot;500\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/TextBox\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;ListBox Grid.Row=\u0026quot;1\u0026quot; Grid.Column=\u0026quot;0\u0026quot; x:Name=\u0026quot;listBox\u0026quot; ItemsSource=\u0026quot;{Binding FilteredFamilies}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedFamily}\u0026quot;\u0026gt; \u0026lt;ListBox.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:DoubleClickToCommand Command=\u0026quot;{Binding ElementName=listBox, Path=DataContext.EditFamily}\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;views:FamilyView DataContext=\u0026quot;{Binding}\u0026quot; /\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListBox.ItemTemplate\u0026gt; \u0026lt;/ListBox\u0026gt; \u0026lt;StackPanel Grid.Row=\u0026quot;1\u0026quot; Grid.Column=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;Button Command=\u0026quot;{Binding AddFamily}\u0026quot; Content=\u0026quot;Add...\u0026quot; /\u0026gt; \u0026lt;Button Command=\u0026quot;{Binding EditFamily}\u0026quot; Content=\u0026quot;Edit...\u0026quot; /\u0026gt; \u0026lt;Button Command=\u0026quot;{Binding RemoveFamily}\u0026quot; Content=\u0026quot;Remove\u0026quot; /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/Grid\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/data-handling/using-modelbase-as-base-for-entities/","title":"Using ModelBase as base for entities","tags":[],"description":"","content":" It is possible to use the ModelBase as base class when using EF or any other OR mapper.\nSetting up ModelBase as base class There are a few caveats when using the ModelBase as base class for your entities. One of them is that IsDirty is always true because the properties from the persistence store are set after the constructor. This guide will explain how to work past that problem.\n Create a class named EntityBase with the following code:\npublic class EntityBase : ModelBase { protected EntityBase() { } protected EntityBase(SerializationInfo info, StreamingContext context) : base(info, context) { } internal void ClearDirtyFlag() { IsDirty = false; } }  Derive from EntityBase instead of ModelBase so the layer that loads the data can clear the IsDirty flag.\n When loading the data from the database and setting the initial values, use this code:\nvar company = new DTO.Company() { Address = domainEntity.Address, City = domainEntity.City, CompanyID = domainEntity.CompanyID, CompanyName = domainEntity.CompanyName, PostalCode = domainEntity.PostalCode, PostalCodeAndCity = domainEntity.PostalCodeAndCity }; company.ClearDirtyFlag(); return company;   Note the ClearDirtyFlag call, which is very important to make the IsDirty property behave correctly.\n Check the IsDirty of the model, not the view model when checking whether the model is dirty inside a view model.  Ignoring default Catel properties in models It is possible to ignore the default Catel properties in the models for EF code-first. To accomplish this, use the following code:\nprotected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Types().Configure(c =\u0026gt; c.Ignore(\u0026quot;IsDirty\u0026quot;)); modelBuilder.Types().Configure(c =\u0026gt; c.Ignore(\u0026quot;IsReadOnly\u0026quot;)); base.OnModelCreating(modelBuilder); }  Or, if you only want to do this for classes inheriting Modelbase, use the following code:\nprotected override void OnModelCreating(DbModelBuilder modelBuilder) { modelBuilder.Types().Where(t =\u0026gt; t.IsSubclassOf(typeof(ModelBase))).Configure(c =\u0026gt; c.Ignore(\u0026quot;IsDirty\u0026quot;)); modelBuilder.Types().Where(t =\u0026gt; t.IsSubclassOf(typeof(ModelBase))).Configure(c =\u0026gt; c.Ignore(\u0026quot;IsReadOnly\u0026quot;)); base.OnModelCreating(modelBuilder); }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/data-handling/advanced-property-change-notifications/","title":"Advanced property change notifications","tags":[],"description":"","content":" Sometimes the old value is needed in case of property change event. However, the INotifyPropertyChanged interface does not provide any of this. To support this behavior, a new version of the PropertyChangedEventArgs is created called AdvancedPropertyChangedEventArgs. This class derives from PropertyChangedEventArgs so the interfaces are not broken, but it does add additional functionality to the software system.\nGetting old value automatically When using the ModelBase or ViewModelBase classes, the old and new value of a property are automatically provided on a property change. There are two ways to get more information about a property change event.\nGetting more information from the inside The easiest way to get more information on the inside is to override the OnPropertyChanged method. It automatically provides an instance of the AdvancedPropertyChangedEventArgs:\nprotected override void OnPropertyChanged(AdvancedPropertyChangedEventArgs e) { }  Getting mode information from the outside Getting the information from outside the objects is a bit more work. This is because the PropertyChanged event still provides a value of the PropertyChangedEventArgs class. Therefore, it is required to cast the value:\nprivate void OnObjectPropertyChanged(PropertyChangedEventArgs e) { var advancedArgs = e as AdvancedPropertyChangedEventArgs; if (advancedArgs != null) { // a value of AdvancedPropertyChangedEventArgs is now available } }  Providing old value manually When using the dependency property a-like property registration, the old and new value are automatically provided by the classes. However, when using the ObservableObject, the old and new value are not automatically provided. Therefore, it is possible to provide these values manually:\nprivate string _firstName; public string FirstName { get { return _firstName; } set { var oldValue = _firstName; _firstName = value; RaisePropertyChanged(() =\u0026gt; FirstName, oldValue, value); } }  When the values are not provided, the old and new value are set to null.\nSome sidenotes As you might have noticed, the AdvancedPropertyChangedEventArgs also provide the IsOldValueMeaningful and the IsNewValueMeaningful. These are introduced because it is not always possible to determine the old or new value (for example, when the property name is string.Empty, there is no old value or new value). Therefore, the OldValue and NewValue properties are null, but doesn\u0026rsquo;t mean that those are the actual old and new values.\nIt is always required to check whether the values are meaningful before actually handing them:\nprotected override void OnPropertyChanged(AdvancedPropertyChangedEventArgs e) { if (e.IsOldValueMeaningful) { // Handle old value } if (e.IsNewValueMeaningful) { // Handle new value } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-resharper/","title":"Catel.ReSharper","tags":[],"description":"","content":" Catel.ReSharper is a ReSharper plugin that helps with development in the following fields:\n Make classes to inherits from ModelBase or ViewModelBase Convert automatic properties to Catel properties Expose view model properties as view model ones Check for arguments using the Argument class  Basically convert this:\n/// \u0026lt;summary\u0026gt; /// The person model. /// \u0026lt;/summary\u0026gt; public class Person { #region Public Properties /// \u0026lt;summary\u0026gt; /// Gets or sets the first name. /// \u0026lt;/summary\u0026gt; public string FirstName { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the last name. /// \u0026lt;/summary\u0026gt; public string LastName { get; set; } /// \u0026lt;summary\u0026gt; /// Gets or sets the age. /// \u0026lt;/summary\u0026gt; public int Age { get; set; } #endregion }  into this:\n/// \u0026lt;summary\u0026gt; /// The person model. /// \u0026lt;/summary\u0026gt; public class Person : ModelBase { #region Static Fields /// \u0026lt;summary\u0026gt;Register the FirstName property so it is known in the class.\u0026lt;/summary\u0026gt; public static readonly PropertyData FirstNameProperty = RegisterProperty\u0026lt;Person, string\u0026gt;(model =\u0026gt; model.FirstName); /// \u0026lt;summary\u0026gt;Register the LastName property so it is known in the class.\u0026lt;/summary\u0026gt; public static readonly PropertyData LastNameProperty = RegisterProperty\u0026lt;Person, string\u0026gt;(model =\u0026gt; model.LastName, default(string), (s, e) =\u0026gt; s.OnLastNameChanged()); /// \u0026lt;summary\u0026gt;Register the Age property so it is known in the class.\u0026lt;/summary\u0026gt; public static readonly PropertyData AgeProperty = RegisterProperty\u0026lt;Person, int\u0026gt;(model =\u0026gt; model.Age, default(int), (s, e) =\u0026gt; s.OnAgeChanged(e)); #endregion #region Public Properties /// \u0026lt;summary\u0026gt; /// Gets or sets the first name. /// \u0026lt;/summary\u0026gt; public string FirstName { get { return this.GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { this.SetValue(FirstNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Gets or sets the last name. /// \u0026lt;/summary\u0026gt; public string LastName { get { return this.GetValue\u0026lt;string\u0026gt;(LastNameProperty); } set { this.SetValue(LastNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Gets or sets the age. /// \u0026lt;/summary\u0026gt; public int Age { get { return this.GetValue\u0026lt;int\u0026gt;(AgeProperty); } set { this.SetValue(AgeProperty, value); } } #endregion #region Methods /// \u0026lt;summary\u0026gt; /// Occurs when the value of the Age property is changed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;e\u0026quot;\u0026gt; /// The event argument /// \u0026lt;/param\u0026gt; private void OnAgeChanged(AdvancedPropertyChangedEventArgs e) { throw new NotImplementedException(); } /// \u0026lt;summary\u0026gt; /// Occurs when the value of the LastName property is changed. /// \u0026lt;/summary\u0026gt; private void OnLastNameChanged() { throw new NotImplementedException(); } #endregion }  with pleasure!\nChecking arguments of a method If you are not using the Argument class, you are definitely missing something! It allows you to check for a method input and make sure it is valid. So, instead of writing this:\npublic void DoSomething(string myInput) { if (string.IsNullOrWhitespace(myInput) { Log.Error(\u0026quot;Argument 'myInput' cannot be null or whitespace\u0026quot;); throw new ArgumentException(\u0026quot;Argument 'myInput' cannot be null or whitespace\u0026quot;, \u0026quot;myInput\u0026quot;); } // custom logic }  You can write this:\npublic void DoSomething(string myInput) { Argument.IsNotNullOrWhitespace(() =\u0026gt; myInput); // custom logic }  However, when you are writing lots of code, then even this piece of code can be too much. Thanks to the* Catel.Resharper* plugin, it is possible to select the argument (in this case myInput), hit ALT + Enter and generate the code.\nConverting regular properties into Catel properties to start of metadata\nCatel is extremely powerful, but sometimes the property definitions are lots of work to write down. The code snippets already make your life much easier, but with the Catel.Resharper plugin it might be even easier. You can simply write this code:\npublic class Person : ModelBase { public string FirstName { get; set; } public string MiddleName { get; set; } public string LastName { get; set; } }  Then hit ALT + Enter and turn properties into Catel properties, which will result in this class:\npublic class Person : ModelBase { /// \u0026lt;summary\u0026gt; /// Gets or sets the first name. /// \u0026lt;/summary\u0026gt; public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FirstName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FirstNameProperty = RegisterProperty\u0026lt;Person, string\u0026gt;(model =\u0026gt; model.FirstName); /// \u0026lt;summary\u0026gt; /// Gets or sets the middle name. /// \u0026lt;/summary\u0026gt; public string MiddleName { get { return GetValue\u0026lt;string\u0026gt;(MiddleNameProperty); } set { SetValue(MiddleNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the MiddleName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData MiddleNameProperty = RegisterProperty\u0026lt;Person, string\u0026gt;(model =\u0026gt; model.MiddleName); /// \u0026lt;summary\u0026gt; /// Gets or sets the last name. /// \u0026lt;/summary\u0026gt; public string LastName { get { return GetValue\u0026lt;string\u0026gt;(LastNameProperty); } set { SetValue(LastNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the LastName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData LastNameProperty = RegisterProperty\u0026lt;Person, string\u0026gt;(model =\u0026gt; model.LastName); }  "},{"uri":"https://docs.catelproject.com/vnext/tips-tricks/","title":"Tips &amp; tricks","tags":[],"description":"","content":" Core   MVVM   "},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-4.0/","title":"Catel 4.0","tags":[],"description":"","content":" This guide describes how to update your code to be fully compatible with Catel 4.0.\nRenaming classes Some classes in Catel have been renamed.\n Catel.Environment =\u0026gt; CatelEnvironment IDependencyPropertySelector =\u0026gt; IViewPropertySelector  Renaming namespaces Some namespaces in Catel have been changed to match the functionality. For example, all services are now in Catel.Service instead of Catel.MVVM.Services because they can be used without MVVM.\nBelow is a list of changed namespaces:\n Catel.MVVM.Services =\u0026gt; Catel.Services Catel.Windows.Data.Converters =\u0026gt; Catel.MVVM.Converters\n Catel.Windows.Controls.MVVMProviders.Logic =\u0026gt; Catel.MVVM.Providers\n  Some interfaces were moved (but not all classes in the namespace):\n Catel.Windows =\u0026gt; Catel.MVVM.Views  Simplied ModelBase external interfacing The ModelBase class exposed a lot of properties for validation such as HasErrors, HasFieldErrors, HasBusinessRuleErrors, etc. These all these properties are now explicitly implemented into interfaces to make models using ModelBase cleaner to use for end-developers. Below is a list of properties that are now implemented as explicit interface implementations:\nMember name\nExplicit interface implementation\nMember type\nBusinessRuleErrorCount\nIModelValidation.BusinessRuleErrorCount\nproperty\nBusinessRuleWarningCount\nIModelValidation.BusinessRuleWarningCount\nproperty\nDeserialized\nIModelSerialization.Deserialized\nevent\nErrorsChanged\nINotifyDataErrorInfo.ErrorsChanged\nevent\nFieldErrorCount\nIModelValidation.FieldErrorCount\nproperty\nFieldWarningCount\nIModelValidation.FieldWarningCount\nproperty\nHasErrors\nINotifyDataErrorInfo.HasErrors\nproperty\nHasWarnings\nINotifyDataWarningInfo.HasWarnings\nproperty\nValidationContext\nIModelValidation.ValidationContext\nproperty\nValidator\nIModelValidation.Validator\nproperty\nWarningsChanged\nINotifyDataWarningInfo.WarningsChanged\nevent\nRenamed LoadTabItemsBehavior The LoadTabItemsBehavior has been refactored with new names. The old names will be removed in v5, but will error in v4. Below are the renames:\n Single =\u0026gt; LazyLoading SingleUnloadOthers =\u0026gt; LazyLoadingUnloadOthers AllOnStartup =\u0026gt; EagerLoading  AllOnFirstUse =\u0026gt; EagerLoadingOnFirstUse   Add additional members to custom IView implementations To support Xamarin, the IView interface has been extended with new members. Make sure to implement the new members.\nUsing FastViewPropertySelector by default for major performance improvement When not using the ViewToViewModel attributes, it is not required to subscribe to all dependency properties in the UserControlLogic. Starting from Catel 4.0, Catel uses the FastViewPropertySelector by default which subscribes to no properties by default. This is a breaking change for users using the ViewToViewModel attribute.\nTo get back the behavior, there are 2 ways:\nManually add interesting properties (recommended) It is best to let Catel only subscribe to the properties that it should (for the best performance). To do so, use the IViewPropertySelector.AddPropertyToSubscribe method to add properties:\nvar serviceLocator = ServiceLocator.Default; var viewPropertySelector = serviceLocator.ResolveType\u0026lt;IViewPropertySelector\u0026gt;(); viewPropertySelector.AddPropertyToSubscribe(\u0026quot;MyProperty\u0026quot;, typeof(MyView));  In most cases, the only reason to subscribe to property changes is because of the *ViewToViewModel *attribute. If that is the case, it is best to use the extension method AutoDetectViewPropertiesToSubscribe in the static constructor of the view:\nstatic MyView() { typeof(MyView).AutoDetectViewPropertiesToSubscribe(); }  Register the ViewPropertySelector The default implementation of the ViewPropertySelector subscribes to all properties by default. By registering it in the ServiceLocator will ensure Catel subscribes to all dependency properties:\nvar serviceLocator = ServiceLocator.Default; serviceLocator.RegisterType\u0026lt;IViewPropertySelector, ViewPropertySelector\u0026gt;();  Full support for asynchronous (async/await) IViewModel The IViewModel interface now returns tasks instead of direct values to support async/await.\nUpdating Initialize method public override void Initialize() { base.Initialize(); }  Must be changed in:\npublic override async Task Initialize() { await base.Initialize(); }  Updating Save method public override bool Save() { return base.Save(); }  Must be changed in:\npublic override async Task\u0026lt;bool?\u0026gt; Save() { return await base.Save(); }  Updating Close method public override void Close() { base.Close(); }  Must be changed in:\npublic override async Task Close() { await base.Close(); }  IMessageService The use of await or Task.ContinueWith to await the result is now necessary or use the code below:\nif (await messageService.ShowInfo(\u0026quot;message\u0026quot;, other parameters...) == MessageBoxResult.Yes) { // Handle yes here }  IUIVisualizerService The use of *await* or *Task.ContinueWith* to await the result is now necessary or use the code below:\nawait uiVisualizerService.ShowDialog\u0026lt;MyViewModel\u0026gt;(); // Window is closed here thanks to the await keyword  Optimizing views (especially 3rd party) Catel 4.0 introduces a much simpler way to use Catel on 3rd party controls. This means that the following changes have been applied and might be breaking:\n Removed GetViewModelType() from view base classes. Instead use the IViewModelLocator to ensure Catel can find the view models. Note that it is possible to manually register a custom view with a view model in case the view / view model don\u0026rsquo;t match any naming convention. Removed GetViewModelInstance() from view base classes. Customize the IViewModelFactory instead. Removed ValidateData, DiscardChanges and ApplyChanges from all views except DataWindow Merged ViewLoaded and Loaded events on IViewModelContainer and IView interfaces Renamed *ViewLoading* and *ViewUnloading *events on *IViewModelContainer *to Loading and Unloading Renamed *IViewLoadedManager *to IViewLoadManager  Removed IServiceLocator.RemoveInstance methods The IServiceLocator.Remove[x] methods are removed. Use the RemoveType methods instead.\nChanged CompositeCommand The composite command will always allow execution, even when commands don\u0026rsquo;t allow it. Therefore the *AllowPartialExecution *is now set to *false *by default.\nIf there is a requirement to allow partial invocation, set this property to true.\nAdded time to all log calls The time parameter has been added to all log calls. This is a breaking change for all classes implementing ILogListener.\nBehavior changes To improve multiple platforms support, all parameters of the following methods on BehaviorBase have been removed:\nOnAssociatedObjectLoaded(object sender, EventArgs e) =\u0026gt; OnAssociatedObjectLoaded() OnAssociatedObjectUnloaded(object sender, EventArgs e) =\u0026gt; OnAssociatedObjectUnloaded()    "},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-4.1/","title":"Catel 4.1","tags":[],"description":"","content":" This guide describes how to update your code to be fully compatible with Catel 4.1.\nThis guide assumes that you are coming from Catel 4.0. If not, please read that guide first.  IUIVisualizerService We have reverted the change to force you to use async code on the IUIVisualizerService. There are now 2 options:\n Synchronous:\nvar result = uiVisualizerService.ShowDialog\u0026lt;MyViewModel\u0026gt;(); // Window is closed here (synchronous behavior)  Asynchronous:\nvar result = await uiVisualizerService.ShowDialogAsync\u0026lt;MyViewModel\u0026gt;(); // Window is closed here thanks to the await keyword    "},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-5.0/","title":"Catel 5.0","tags":[],"description":"","content":" This guide describes how to update your code to be fully compatible with Catel 5.0.\nCatel v5 contains a lot of breaking changes, not all of them cause compiler errors but change core behavior. It's important to check out the guide below **before** updating to Catel v5.  This guide assumes that you are coming from Catel 4.5. If not, please read that guide first.  Encountered issues while upgrading to this version? Add them here to help out others!\nPlatform support changes Added support for the following platforms:\n .NET 4.7  Removed support for the following platforms:\n .NET 4.0 Silverlight 5 Windows Phone 8.0 (Silverlight) Windows Phone 8.1 (Silverlight) Windows Phone 8.1 (Runtime) Windows 8.1 (Runtime)  Moved extensions The following extensions have been moved to a new repository:\n Catel.Extensions.Controls (moved to Orc.Controls \u0026amp; Orchestra) Catel.Extensions.DynamicObjects (moved to Orc.DynamicObjects) Catel.Extensions.EntityFramework (moved to Orc.EntityFramework) Catel.Extensions.FluentValidation (moved to Orc.FluentValidation) Catel.Extensions.Memento (moved to Orc.Memento) Catel.Extensions.Prism5 (moved to Orc.Prism) Catel.Extensions.Prism6 (moved to Orc.Prism)  Removed extensions The following extensions have been removed:\n Catel.Extensions.CSLA Catel.Extensions.Data Catel.Extensions.Interception Catel.Extensions.MVC4 Catel.Extensions.MVC5 Catel.Extensions.Prism4 Catel.Extensions.Wcf.Server  Catel.Fody Note that if you are using Catel.Fody, you *must* update to at least 2.17 to support Catel 5.  Catel.Core CommandLineHelper CommandLineHelper has been removed. Use Orc.CommandLine instead.\nDynamicEventListener DynamicEventListener has been removed. Use WeakEventListener instead.\nModelBase The ModelBase has been greatly simplified to decrease the memory print and improve performance. The class is split up into separate classes:\n ModelBase =\u0026gt; takes care of basic serialization and property bag registrations ValidatableModelBase =\u0026gt; adds validation ChildAwareModelBase =\u0026gt; contains the child event subscriptions logic (which is very costly) SavableModelBase =\u0026gt; adds Save and Load methods ComparableModelBase =\u0026gt; contains the equality comparer members. This means the ModelBase itself does no longer support equality checks based on the property values  Catel.MVVM XAML namespace changes The xaml namespace has changed from http://catel.codeplex.com to http://schemas.catelproject.com\nCountCollapsedConverter CountCollapsedConverter has been removed. Use CollectionToVisibilityConverter instead.\nEffectsHelper EffectsHelper has been removed. No replacement is available.\nViewModelBase The ViewModelBase has been simplified. It now derives from ValidatingModelBase (so still supports validation). The following features / members have been removed:\n HasDirtyModels has been removed Validation summaries (use the ValidationContext instead)  VisualTargetPresentationSource VisualTargetPresentationSource has been removed. No replacement is available.\n"},{"uri":"https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-5.4/","title":"Catel 5.4","tags":[],"description":"","content":" This guide describes how to update your code to be fully compatible with Catel 5.4.\nThis guide assumes that you are coming from Catel 5.x. If not, please read that guide first.  Encountered issues while upgrading to this version? Add them here to help out others!\nUpdated converters The behavior of converters have been changed for some converters. The converter parameter will now also serve as an \u0026ldquo;inverter\u0026rdquo;. For example, the BooleanToCollapsingVisibilityConverter now behaves like this:\n // Show the text box when `IsEnabled` is `true` \u0026lt;TextBox Visibility=\u0026quot;{catel:BooleanToCollapsingVisibilityConverter IsEnabled}\u0026quot; /\u0026gt; \u0026lt;TextBox Visibility=\u0026quot;{catel:BooleanToCollapsingVisibilityConverter IsEnabled, ConverterParameter=False}\u0026quot; /\u0026gt; // Show the text box when `IsEnabled` is `false` \u0026lt;TextBox Visibility=\u0026quot;{catel:BooleanToCollapsingVisibilityConverter IsEnabled, ConverterParameter=True}\u0026quot; /\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/focus-first-control/","title":"","tags":[],"description":"","content":" FocusFirstControl The Focus behavior is very powerful, but sometimes you just need to focus the first control on a window or control. This can be done by using the FocusFirstControl behavior instead. This behavior will focus the first control on a window or control and has only one property: FocusParentFirst.\nAdd the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  Focus when the control is loaded The easiest and default method is to focus the first control. The parent is also focused by default (just in case if it doesn\u0026rsquo;t have any focus):\n\u0026lt;Window ...\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:FocusFirstControl /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/Window\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/focus-on-key-press/","title":"","tags":[],"description":"","content":" FocusOnKeyPress Sometimes you need to handle a key press and then set the focus on an element.\n1) Add the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  2) Use the following definition:\n\u0026lt;TextBox x:Name=\u0026quot;textBox\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:FocusOnKeyPress Key=\u0026quot;F\u0026quot; Modifiers=\u0026quot;Ctrl\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/ListBox\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xamarin-android/activities-pages/","title":"Activities (pages)","tags":[],"description":"","content":" The user controls in Android are called fragments. This means that if a user control must be created, it must derive from the Fragment class. Catel provides a base implementation of this class to ensure full compatibility with the MVVM framework that ships with Catel.\nCreating the view model The view model can be created (or added as a linked file from another project) just like any platform using Catel (they are all equal on all platforms).\nCreating the view Make sure that a Views folder exists in the project so the views and view models can automatically be hooked together by Catel. Then create a new class to the views folder, in this case MainActivity:\n[Activity(MainLauncher = true)] public class MainActivity : Catel.Android.App.Activity { protected override void OnCreate(Bundle bundle) { base.OnCreate(bundle); // Set our view from the \u0026quot;main\u0026quot; layout resource SetContentView(Resource.Layout.Page_Main); } }  Note that the class derives from *Catel.Android.App.Activity*  Designing the view To create the actual user interface of the fragment, add a new xaml file to the Resources/layout folder, in your case Page\\_Main (but you can name it whatever you want). Then use the following source:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; android:orientation=\u0026quot;vertical\u0026quot; android:layout_width=\u0026quot;fill_parent\u0026quot; android:layout_height=\u0026quot;fill_parent\u0026quot;\u0026gt; \u0026lt;Button android:id=\u0026quot;@+id/MyButton\u0026quot; android:layout_width=\u0026quot;fill_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:text=\u0026quot;@string/Hello\u0026quot; /\u0026gt; \u0026lt;/LinearLayout\u0026gt;  Setting up synchronization In Android it is required to manually synchronize the values between the view and view model. Below is the fully extended MainActivity class containing these mapping functionality:\n[Activity(MainLauncher = true)] public class MainActivity : Catel.Android.App.Activity { private Button _testButton; protected override void OnCreate(Bundle bundle) { base.OnCreate(bundle); // Set our view from the \u0026quot;main\u0026quot; layout resource SetContentView(Resource.Layout.Page_Main); // Note: at this stage the visual tree is guaranteed in Android _testButton = FindViewById\u0026lt;Button\u0026gt;(Resource.Id.MyButton); _testButton.Click += delegate { GetViewModel\u0026lt;MainViewModel\u0026gt;().RunCommand.Execute(); }; } protected override void SyncViewModel() { var vm = GetViewModel\u0026lt;MainViewModel\u0026gt;(); if (vm == null) { return; } Title = vm.Title; _testButton.Text = string.Format(\u0026quot;{0} clicks!\u0026quot;, vm.Counter); } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/apicop/","title":"ApiCop","tags":[],"description":"","content":" Introduction ApiCop is a unique feature in Catel that helps developers make sure the users are using the Api of frameworks the right way. This functionality has been evolved from experience that users want logical advice including links to documentation when and why they are not using an Api in its full potential.\nThe advantage of ApiCop is that it will only execute any code to trace the application when a debugger is attached. If no debugger is attached, the feature will be fully disabled to prevent an impact of performance when running the software without debuggers.\nUsage for end-users (developers) As an end-user (developers that use a framework that supports ApiCop), the usage is really simply. Whenever you need a report (for example, when closing an application when the debugger is attached), use the ApiCopManager to write the results. Below is an example of a WPF application in the App.xaml.cs:\nprotected override void OnExit(ExitEventArgs e) { #if DEBUG var apiCopListener = new ConsoleApiCopListener(); ApiCopManager.AddListener(apiCopListener); ApiCopManager.WriteResults(); #endif base.OnExit(e); }  The code above writes the results of the ApiCop feature to the console, which will look like this:\n**************************************************************** ApiCop (r) results of 'DataWindowTest.WPF' v1.0.0.0 recorded on 2014-02-19 10:06 To ignore rules, call ApiCopManager.IgnoredRules.Add([rulename]); For more information about ApiCop, visit the website: http://docs.catelproject.com/vnext/ApiCop.htm **************************************************************** ================================================================ DATAWINDOWTEST.VIEWS.AVIEW ================================================================ Cop TargetType: Catel.Windows.Controls.MVVMProviders.Logic.UserControlLogic Rule: UserControlLogic.InfoBarMessageControl (Error) For more information about this rule, visit ... [DataWindowTest.Views.AView] Feature used '0' of '2' times, consider turning it off by default ---------------------------------------------------------------- Cop TargetType: Catel.Windows.Controls.MVVMProviders.Logic.UserControlLogic Rule: UserControlLogic.CreateWarningAndErrorValidator (Error) For more information about this rule, visit ... [DataWindowTest.Views.AView] Feature used '0' of '2' times, consider turning it off by default ---------------------------------------------------------------- ================================================================ DATAWINDOWTEST.VIEWS.BVIEW ================================================================ Cop TargetType: Catel.Windows.Controls.MVVMProviders.Logic.UserControlLogic Rule: UserControlLogic.InfoBarMessageControl (Error) For more information about this rule, visit ... [DataWindowTest.Views.BView] Feature used '0' of '2' times, consider turning it off by default ---------------------------------------------------------------- Cop TargetType: Catel.Windows.Controls.MVVMProviders.Logic.UserControlLogic Rule: UserControlLogic.CreateWarningAndErrorValidator (Error) For more information about this rule, visit ... [DataWindowTest.Views.BView] Feature used '0' of '2' times, consider turning it off by default ---------------------------------------------------------------- **************************************************************** End of ApiCop (r) results, generation took '00:00:00.137' ****************************************************************  Architecture ApiCop provides a set of components that help developers of frameworks to aid developers during the usage of their frameworks. Below is a graphical presentation of the components.\nThe green parts are the only components that end-users will use. The blue parts are components for Api developers.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/argument-checking/","title":"Argument checking","tags":[],"description":"","content":"It is best practice to always check if the input to a method is correct. If not, an exception should be thrown. Most people do not check for exceptions correctly and lots of null reference exceptions inside a deep stacktrace are hard to solve. Catel does check the input on every method. Normally, a check would look like this:\npublic void CheckForException(object obj) { if (obj == null) { throw new ArgumentNullException(\u0026quot;obj\u0026quot;); } }  However, Catel extensively logs all behavior, thus all the checks started to look like this:\npublic void CheckForException(object obj) { if (obj == null) { Log.Debug(\u0026quot;Argument 'obj' is null in CheckForException\u0026quot;); throw new ArgumentNullException(\u0026quot;obj\u0026quot;); } }  Handling input correctly in such a case takes a lot of space and repetitive code. Therefore the Argument class is developed. This way, it is very simple to check for arguments:\npublic void CheckForException(object obj) { Argument.IsNotNull(\u0026quot;obj\u0026quot;, obj); }  Or, if a range should be checked:\npublic void CheckForException(int myInt) { Argument.IsNotOutOfRange(\u0026quot;myInt\u0026quot;, myInt, 0, 10); }  A final example is to check whether a type implements a specific interface:\npublic void CheckForException(object obj) { Argument.ImplementsInterface(\u0026quot;obj\u0026quot;, obj, typeof(INotifyPropertyChanged)); }  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/auditing/","title":"Auditing","tags":[],"description":"","content":" There are lots of lightweight MVVM frameworks out there, which work great for the basics. However, if you are writing larger enterprise applications, notifying the UI of changed properties isn\u0026rsquo;t enough. For example, did you think about Command Authentication? Or what about sensor emulation for Windows Phone 7 (that Microsoft don’t provide)?\nWhy auditing  There are many reasons why auditing should be added to an application. Most developers only add auditing to the database, but below are several reasons to add auditing to the client as well:\n Logging (what user did what on specific moments) Gather statistics (which views (view models) are used most) See what features of your software are being used by checking if anyone is actually invoking specific commands Measure performance (how long does it take to update specific properties or why is a specific view-model so slow?)  With the auditing capabilities of Catel, you can create and register custom auditors that can handled changes and events of view models. This way, you can gather a lot of statistics or any information that you want to gather about the user experience. Below is a list of events that can be handled:\n OnViewModelCreating OnViewModelCreated OnPropertyChanging OnPropertyChanged OnCommandExecuting OnViewModelSaving OnViewModelSaved OnViewModelCanceling OnViewModelCanceled OnViewModelClosing OnViewModelClosed  The developer has all the freedom to handle one or more methods in an auditor. Of course multiple auditors are possible as well.\nCreating an auditor Creating a new auditor is very simple. Create a new class, derive from AuditorBase and override the methods you are interested in. The class example tracks the event to a fake analytics framework.\n/// \u0026lt;summary\u0026gt; /// Logs all commands to a custom analytics service. /// \u0026lt;/summary\u0026gt; public class CommandAuditor : AuditorBase { private Analytics _analytics = new Analytics(); /// \u0026lt;summary\u0026gt; /// Called when a command of a view model has just been executed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;viewModel\u0026quot;\u0026gt;The view model.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;commandName\u0026quot;\u0026gt;Name of the command, which is the name of the command property.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;command\u0026quot;\u0026gt;The command that has been executed.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;commandParameter\u0026quot;\u0026gt;The command parameter.\u0026lt;/param\u0026gt; public override void OnCommandExecuted(IViewModel viewModel, string commandName, ICatelCommand command, object commandParameter) { _analytics.TrackEvent(viewModel.GetType(), \u0026quot;commandName\u0026quot;); } }  Registering an auditor  Registering a new auditor is extremely easy as you can see in the code below:\nAuditingManager.RegisterAuditor(new CommandAuditor());  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/authentication/","title":"Authentication","tags":[],"description":"","content":"The Authentication behavior is able to hide, collapse or disable UI elements based on the current user state. The behavior uses the registered IAuthenticationProvider instances to determine whether the user has access to the specified UI element.\n1) Creating an authentication provider:\n/// \u0026lt;summary\u0026gt; /// Example implementation of the \u0026lt;see cref=\u0026quot;AuthenticationProvider\u0026quot;/\u0026gt;. This class is not really implemented /// like it should, because it shouldn't be this easy to set the current role. However, for the sake of simplicity, /// this class has a simple property with the role of the user. /// \u0026lt;/summary\u0026gt; public class AuthenticationProvider : IAuthenticationProvider { /// \u0026lt;summary\u0026gt; /// Gets or sets the role the user is currently in. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;The role.\u0026lt;/value\u0026gt; public string Role { get; set; } public bool CanCommandBeExecuted(ICatelCommand command, object commandParameter) { return true; } public bool HasAccessToUIElement(FrameworkElement element, object tag, object authenticationTag) { var authenticationTagAsString = authenticationTag as string; if (authenticationTagAsString != null) { if (string.Compare(authenticationTagAsString, Role, true) == 0) { return true; } } return false; } }  2) Register the authentication provider in the ServiceLocator:\nCatel.IoC.ServiceLocator.Instance.RegisterType\u0026lt;IAuthenticationProvider, AuthenticationProvider\u0026gt;();  3) Add the following XML namespaces to your view:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  4) Add the behavior. As you can see, it is possible to provide a custom AuthenticationTag, which is passed to the IAuthenticationProvider:\n\u0026lt;TextBox\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:Authentication AuthenticationTag=\u0026quot;Administrator\u0026quot; Action=\u0026quot;Disable\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/TextBox\u0026gt;  5) Below are screenshots of the example applications:\nLogged in as administrator:\nLogged in as read-only user:\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/autocompletion/","title":"AutoCompletionBehavior","tags":[],"description":"","content":" To enable auto completion features, once can use the services and behaviors provided by Catel. There are two components required for auto completion:\n AutoCompletionService =\u0026gt; takes care of the actual filtering AutoCompletionBehavior =\u0026gt; can be attached to a TextBox to support a dropdown with recommended values  The auto completion features looks like the screenshot below:\nAutoCompletion service The default implementation automatically filters the collection specified. If there is no filter yet, it will filter the top 10 occurrences from the collection. When a filter is available, it will do the same but with the filter applied.\nAutoCompletion behavior The behavior can be used as follows:\n\u0026lt;catel:AutoCompletionBehavior PropertyName=\u0026quot;{Binding PropertyName, Mode=OneWay}\u0026quot; ItemsSource=\u0026quot;{Binding RawCollection}\u0026quot; IsEnabled=\u0026quot;{Binding EnableAutoCompletion}\u0026quot;/\u0026gt;  If the `PropertyName` is `null` or whitespace, the `ItemsSource` will be treated as collection of strings to be filtered directly  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/autoscroll/","title":"AutoScroll","tags":[],"description":"","content":"The AutoScroll behavior automatically scrolls to a specific direction when the ItemsSource of an ItemsControl changes.\n1) Add the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  2) Add behavior\n\u0026lt;ListBox ItemsSource=\u0026quot;{Binding LogEntries}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:AutoScroll ScrollDirection=\u0026quot;Bottom\u0026quot; ScrollTreshold=\u0026quot;10\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/ListBox\u0026gt;  The ScrollDirection determines the direction (Top or Bottom).\nThe ScrollTreshold allows the treshold of the real offset (to determine whether auto scroll should be enabled). For example, when the user is manually scrolling, this behavior will pause.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/batch-log-listeners/","title":"Batch log listeners","tags":[],"description":"","content":" A batch log listener is a class implementing the IBatchLogListener interface (and most probably deriving from BatchLogListenerBase). This interface adds a Flush method which allows a listener to be flushed. The advantage is that when a log listener writes to a slower persistence store, it will not have to access this expensive resource for every log event, but by batches.\nFlushing all listeners When using batch log listeners, it is very important to flush the log listeners at important events such as application unhandled exceptions or when the application exits. The reason is that otherwise important log events that are currently in the batch that hasn\u0026rsquo;t been written to the persistence store are lost.\nTo flush all flushable listeners, use the following method:\nLogManager.FlushAll();  Implementing a custom IBatchLogListener When implementing a custom batch log listener, it is very wise to derive from the BatchLogListenerBase class. This brings the following advantages:\n The BatchLogListenerBase is thread-safe The BatchLogListenerBase automatically flushes the listener every 5 seconds You only need to implement the WriteBatch which actually writes the entries to the persistence store  Below is an example batch log listener:\npublic class FileLogListener : BatchLogListenerBase { private readonly string _filePath; private readonly int _maxSizeInKiloBytes; public FileLogListener(string filePath, int maxSizeInKiloBytes) { Argument.IsNotNullOrWhitespace(() =\u0026gt; filePath); _filePath = filePath; _maxSizeInKiloBytes = maxSizeInKiloBytes; } protected override void WriteBatch(System.Collections.Generic.List\u0026lt;LogBatchEntry\u0026gt; batchEntries) { try { var fileInfo = new FileInfo(_filePath); if (fileInfo.Exists \u0026amp;\u0026amp; (fileInfo.Length / 1024 \u0026gt;= _maxSizeInKiloBytes)) { CreateCopyOfCurrentLogFile(_filePath); } using (var fileStream = new FileStream(_filePath, FileMode.Append, FileAccess.Write, FileShare.Read)) { using (var writer = new StreamWriter(fileStream)) { foreach (var batchEntry in batchEntries) { var message = FormatLogEvent(batchEntry.Log, batchEntry.Message, batchEntry.LogEvent, batchEntry.ExtraData); writer.WriteLine(message); } } } } catch (Exception) { // Swallow } } private void CreateCopyOfCurrentLogFile(string filePath) { for (int i = 1; i \u0026lt; 999; i++) { var possibleFilePath = string.Format(\u0026quot;{0}.{1:000}\u0026quot;, filePath, i); if (!File.Exists(possibleFilePath)) { File.Move(filePath, possibleFilePath); } } } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/","title":"Behaviors &amp; triggers","tags":[],"description":"","content":" Behaviors and triggers are very important to correctly separate the view from the view model. For example, to respond to an event in a view model, you cannot simply subscribe to the events in the view. The EventToCommand behavior is a great example to solve this problem.\nCatel offers lots of behaviors out of the box, so it is definitely worth taking a look at the behaviors.\nManaging interactivity classes Starting with Catel 4.0, it is possible to manage interactivity classes such as behaviors from the InteractivityManager class. This allows a developer to get notified when a behavior or trigger is loaded or unloaded.\nNote that the *InteractivityManager* is only compatible with behaviors and triggers using one of the Catel base classes  The manager contains both events and methods to retrieve information about triggers. For example, if one is interested in all the Focus triggers, one could do the following:\npublic class FocusWatcher { private static readonly ILog Log = LogManager.GetCurrentClassLogger(); private readonly IInteractivityManager _interactivityManager; public FocusWatcher(IInteractivityManager interactivityManager) { Argument.IsNotNull(() =\u0026gt; interactivityManager); _interactivityManager = interactivityManager; _interactivityManager.BehaviorLoaded += OnBehaviorLoaded; _interactivityManager.BehaviorUnloaded += OnBehaviorUnloaded; } private void OnBehaviorLoaded(object sender, BehaviorEventArgs e) { var focus = e.Behavior as Focus; if (focus != null) { Log.Info(\u0026quot;Focus behavior loaded\u0026quot;); } } private void OnBehaviorUnloaded(object sender, BehaviorEventArgs e) { var focus = e.Behavior as Focus; if (focus != null) { Log.Info(\u0026quot;Focus behavior unloaded\u0026quot;); } } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/serialization/supported-serializers/binary/","title":"Binary","tags":[],"description":"","content":"The binary serializer uses the .NET binary serializer formatters to serialize the objects.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/bindings/","title":"Bindings","tags":[],"description":"","content":" By default, all XAML technologies support binding out of the box. However other platforms (such as Xamarin.Android and Xamarin.iOS) don\u0026rsquo;t. Catel provides a binding system for these platforms, which is described in this topic.\nNote that although the binding system in Catel is very powerful, it will never be as flexible / powerful as the native XAML binding system. We do try to support as many features as possible though.  For examples, check out the following pages:\n Property bindings Command bindings  Binding system explained The binding system consists of several classes. Below is an architectural overview.\nAs the image shows, each view will have their own BindingContext. A BindingContext contains all the bindings currently available in the view and allows adding / removing bindings dynamically when required. As soon as a major change occurs (such as a new view model), a new BindingContext will be created and the old one will be cleaned up. The views in Catel will automatically take care of the BindingContext initialization and lifetime management.\nEach Binding is a mapping from source to target. It also allows the specification of a converter like available in the XAML platforms. Each Binding also contains several BindingParty objects. The default value for BindingMode is BindingMode.TwoWay.\nA BindingParty is an object that will take care of watching the source or target of the binding and inform the binding when a value has been changed. The binding parties are considered equal and contain the same logic for both the source and target of the binding.\nAll bindings must be initialized in the AddBindings method that is available on all views provided by Catel. "},{"uri":"https://docs.catelproject.com/vnext/catel-core/caching/","title":"Caching","tags":[],"description":"","content":" Caching is about improving applications performance. The most expensive performance costs of the applications are related with data retrieving, typically when this data requires to be moved across the network or loaded from disk. But some data have a slow changing behavior (a.k.a non-volatile) and doesn\u0026rsquo;t require to be re-read with the same frequency of the volatile data.\nSo, to improve your application\u0026rsquo;s performance and handling this \u0026ldquo;nonvolatile\u0026rdquo; data from a pretty clean approach, Catel comes with a CacheStorage class. Notice that the first generic parameter is the type of the key and the second the type of the value the will be stored, just like a Dictionary but CacheStorage isn\u0026rsquo;t it just a Dictionary. This class allows you to retrieve data and store it into the cache with single statement and also helps you to handle expiration policy if you need it.\nInitializing a cache storage To initialize a cache storage field into your class use the following code:\nprivate readonly CacheStorage\u0026lt;string, Person\u0026gt; _personCache = new CacheStorage\u0026lt;string, Person\u0026gt;(storeNullValues: true);  Retrieving data and storing into cache with single statement To retrieve data and store into a cache with a single statement use the following code:\nvar person = _personCache.GetFromCacheOrFetch(Id, () =\u0026gt; service.FindPersonById(Id));  When this statement is executed with the same key more than once , the value will be retrieved from the cache storage instead of the service call. The service call will be executed just the first time or if the item is removed from the cache manually or automatically due to the expiration policy.\nUsing cache expiration policies The cache expiration policies add a removal behavior to the cache storage items. A policy signals that an item is expired to make that cache storage remove the item automatically.\nA default cache expiration policy initialization code can be specified during cache storage initialization constructor:\nCacheStorage\u0026lt;string, Person\u0026gt; _personCache = new CacheStorage\u0026lt;string, Person\u0026gt;(() =\u0026gt; ExpirationPolicy.Duration(TimeSpan.FromMinutes(5)), true);  You can specify a specific expiration policy for an item when it\u0026rsquo;s storing:\n_personCache.GetFromCacheOrFetch(id, () =\u0026gt; service.GetPersonById(id), ExpirationPolicy.Duration(TimeSpan.FromMinutes(10)));  The default cache policy specified at cache storage initialization will be used if the item storing the expiration policy is not specified.\nBuild-in expiration policies Catel comes with build-in expiration policies. They are listed in the follow table:\n   Expiration policy Type Description Initialization code sample     AbsoluteExpirationPolicy Time-base The cache item will expire on the absolute expiration DateTime ExpirationPolicy.Absolute(new DateTime(21, 12, 2012))   DurationExpirationPolicy Time-base The cache item will expire using the duration TimeSpan to calculate the absolute expiration from DateTime.Now ExpirationPolicy.Duration(TimeSpan.FromMinutes(5))   SlidingExpirationPolicy Time-base The cache item will expire using the duration TimeSpan to calculate the absolute expiration from DateTime.Now, but everytime the item is requested, it is expanded again with the specified TimeSpan ExpirationPolicy.Sliding(TimeSpan.FromMinutes(5))   CustomExpirationPolicy Custom The cache item will expire using the expire function and execute the reset action if specified. The example shows how to create a sliding expiration policy with a custom expiration policy. var startDateTime = DateTime.Now;var duration = TimeSpan.FromMinutes(5);ExpirationPolicy.Custom(() =\u0026gt; DateTime.Now \u0026gt; startDateTime.Add(duration), () =\u0026gt; startDateTime = DateTime.Now);   CompositeExpirationPolicy Custom Combines several expiration policy into a single one. It can be configured to expire when any policy expires or when all policies expire. new CompositeExpirationPolicy().Add(ExpirationPolicy.Sliding(TimeSpan.FromMinutes(5))).Add(ExpirationPolicy.Custom(()=\u0026gt;...))    Implementing your own expiration cache policy\nIf the CustomExpirationPolicy is not enough, you can implement you own expiration policy to make that cache item expire triggered from a custom event. You are also able to add some code to reset the expiration policy if the item is read from the cache before it expires (just like SlidingExpirationPolicy does).\nTo implement an expiration cache policy use the following code template:\npublic class MyExpirationPolicy : ExpirationPolicy { public MyExpirationPolicy():base(true) { } public override bool IsExpired { get { // Add your custom expiration code to detect if the item expires } } public override void OnReset() { // Add your custom code to reset the policy if the item is read. } }  The base constructor has a parameter to indicate if the policy can be reset. Therefore, if you call the base constructor with false then the OnReset method will never called.  "},{"uri":"https://docs.catelproject.com/vnext/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://docs.catelproject.com/vnext/","title":"Catel Documentation","tags":[],"description":"","content":" Catel Catel is an application development platform with the focus on MVVM (WPF, Universal Windows Platform, Xamarin.Android, Xamarin.iOS and Xamarin.Forms). The goal of Catel is to provide a complete set of modular functionality for Line of Business applications written in any .NET technology, from client to server.\nCatel distinguishes itself by unique features to aid in the development of MVVM applications and server-side application development. Since Catel focuses on Line of Business applications, it provides professional support and excellent documentation which ensures a safe bet by professional companies and developers.\nMajor features Below are a few major features that are available in Catel.\nCatel.Core Catel.Core is the library you want to include in all your projects, whether you are writing a UI project or not. It contains lots of useful helper methods. The most important features are listed below:\n Argument validation (e.g. Argument.IsNotNull(() =\u0026gt; myArgument)) Caching Data (ModelBase, PropertyBag, Validation) IoC (ServiceLocator, TypeFactory) Logging (LogManager, Log, several log listeners) Messaging Reflection (same reflection API for every supported platform) Serialization (BinarySerializer, XmlSerializer and more) Weak references (WeakEventListener)  And more\u0026hellip;.\nCatel.MVVM Catel.MVVM is the library you want to include when you are writing a UI project (e.g. WPF, UWP, Xamarin) and you want to use the MVVM pattern. Catel is the only MVVM library that has context-aware view and view-model creation, which can be used to solve the nested user controls problem.\nThe most important features are listed below:\n Auditing Collections (FastObservableCollection) Commands (Command, TaskCommand, etc) Converters (tons of converters out of the box) Services  CameraService LocationService MessageService NavigationService OpenFileService PleaseWaitService SaveFileService UIVisualizerService  View models  Automatic validation Automatic mappings from model to view model  Views  DataWindow UserControl Window   Example code Models This model has automatic change notifications and validation.\npublic class Person : ValidatableModelBase { public string FirstName { get; set; } public string LastName { get; set; } protected override void ValidateFields(List\u0026lt;IFieldValidationResult\u0026gt; validationResults) { if (string.IsNullOrWhitespace(FirstName)) { validationResults.Add(FieldValidationResult.CreateError(nameof(FirstName), \u0026quot;First name is required\u0026quot;)); } if (string.IsNullOrWhitespace(LastName)) { validationResults.Add(FieldValidationResult.CreateError(nameof(LastName), \u0026quot;Last name is required\u0026quot;)); } } }  View models This is a view model with:\n Automatic injection of the DataContext Automatic mapping of properties \u0026amp; validation from model =\u0026gt; view model\npublic class PersonViewModel : ViewModelBase { public PersonViewModel(Person person) { Argument.IsNotNull(() =\u0026gt; person); Person = person; } [Model] private Person Person { get; set; } [ViewModelToModel] public string FirstName { get; set; } [ViewModelToModel] public string LastName { get; set; } }   Continue reading  Introduction   FAQ   Setup, deployment \u0026amp; projects   Getting started   Examples   Catel.Core   Catel.MVVM   Catel.Fody   Catel.ReSharper   Tips \u0026amp; tricks   footer   header   "},{"uri":"https://docs.catelproject.com/vnext/catel-core/preventing-memory-leaks/change-notification-wrapper/","title":"Change notification wrapper","tags":[],"description":"","content":" Subscribing to change notifications of objects mostly results in large statements such as the one below:\nvar itemAsPropertyChanged = obj as INotifyPropertyChanged; if (itemAsPropertyChanged != null) { itemAsPropertyChanged.PropertyChanged += OnPropertyChanged; }  However, using this code one must be aware that if not unsubscribed, there might be a potential memory leak here. In Catel, there is a solution for such cases that can raise change notifications using weak events called the ChangeNotificationWrapper. It allows the subscription of both the INotifyPropertyChanged and INotifyCollectionChanged interfaces.\nSubscribing to events of an observable object Using the code below, one can subscribe to the PropertyChanged event of an object:\nvar wrapper = new ChangeNotificationWrapper(obj); wrapper.PropertyChanged += OnPropertyChanged;  Note that it is not required to check whether the object implements INotifyPropertyChanged, the wrapper does it automatically  Subscribing to events of an observable collection Using the code below, one can subscribe to the CollectionChanged event of an object:\nvar wrapper = new ChangeNotificationWrapper(observableCollection); wrapper.CollectionChanged += OnCollectionChanged;  Note that it is not required to check whether the object implements INotifyCollectionChanged, the wrapper does it automatically  Advanced scenario with observable collections Sometimes it is required to watch both changes inside a collection, but also the items inside a collection. For example, there is a list of customers and you are also interested in changes of customers inside a collection. This is fully supported by the ChangeNotificationWrapper using the code below:\nvar wrapper = new ChangeNotificationWrapper(observableCustomerCollection); wrapper.CollectionChanged += OnCollectionChanged; wrapper.CollectionItemPropertyChanged += OnCollectionItemPropertyChanged;  All subscriptions are automatically managed by the ChangeNotificationWrapper when items are added or removed from the collection.\nUnsubscribing from events When you are no longer interested in events from the source object, there are two options:\n Just leave them coming, as soon as the objects are no longer used, they will be garbage collected  Unsubscribe using the following code:\nwrapper.UnsubscribeFromAllEvents();   "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/bindings/command-bindings/","title":"Command bindings","tags":[],"description":"","content":" Catel will automatically hook up the CanExecute of the command to the Enabled property of the element it is bound to. A command binding is always bound to an event of a specific element as shown below.\nAndroid protected override void AddBindings(BindingContext bindingContext, IViewModel viewModel) { var vm = (MainViewModel) viewModel; bindingContext.AddCommandBinding(_testButton, \u0026quot;Click\u0026quot;, vm.RunCommand); }  iOS iOS not yet documented  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/commands-events/application-wide-commands/","title":"CommandManager and command containers (Application-wide commands)","tags":[],"description":"","content":" Most commands are registered per view and available per view model. Some commands (such as commands on a Ribbon or Toolbar) are application-wide. Catel supports both types, and this part of the documentation explains how to use the ICommandManager to work with application-wide commands such as Refresh with a key bound to F5.\nCommandManager There is no generic way to specify application-wide commands in XAML platforms. To overcome this issue, Catel introduces the CommandManager. This manager allows to create commands which are hosted by the CommandManager. The commands on the command manager can be created with input gestures. Once a view model wants to hook into a specific command, it only has to register the view model command with the application-wide command.\nNote that application-wide commands by default are only available on the main window of an application. To support this on other windows, add the following code in the constructor of a window: ``` public class SomeWindow { private readonly CommandManagerWrapper _commandManagerWrapper; public SomeWindow() { InitializeComponent(); _commandManagerWrapper = new CommandManagerWrapper(this); } } ```  Creating application-wide commands To create application-wide commands, one must resolve the ICommandManager from the *DependencyResolver *and create the command:\nvar dependencyResolver = IoCConfiguration.DefaultDependencyResolver; var commandManager = dependencyResolver.Resolve\u0026lt;ICommandManager\u0026gt;(); commandManager.CreateCommand(\u0026quot;Refresh\u0026quot;, new InputGesture(Key.F5));  It is recommended to put all the command creation in a single place so they are easily manageable.  Registering a custom command When a view model wants to use application-wide specific commands, the only thing it has to do is register the command in the CommandManager.\npublic class CommandSubscribingViewModel : ViewModelBase { private readonly IMessageService _messageService; public CommandSubscribingViewModel(ICommandManager commandManager, IMessageService messageService) { Argument.IsNotNull(() =\u0026gt; commandManager); Argument.IsNotNull(() =\u0026gt; messageService); _messageService = messageService; ExampleCommand = new Command(OnExampleCommandExecute); commandManager.RegisterCommand(\u0026quot;Refresh\u0026quot;, ExampleCommand, this); } public Command ExampleCommand { get; private set; } private void OnExampleCommandExecute() { _messageService.Show(\u0026quot;Application-wide command executed\u0026quot;); } }  Using application-wide commands in xaml To make it easy to bind to application-wide commands, Catel provides the *CommandManagerBinding *markup extension. To bind to commands in xaml, use the following code:\n\u0026lt;Ribbon catel:StackGrid.ColumnSpan=\u0026quot;4\u0026quot;\u0026gt; \u0026lt;RibbonTab Header=\u0026quot;Home\u0026quot; KeyTip=\u0026quot;H\u0026quot; \u0026gt; \u0026lt;RibbonGroup Header=\u0026quot;Example commands\u0026quot;\u0026gt; \u0026lt;RibbonButton Command=\u0026quot;{catel:CommandManagerBinding Refresh}\u0026quot; LargeImageSource=\u0026quot;..\\Resources\\Images\\Refresh.png\u0026quot; Label=\u0026quot;Refresh\u0026quot; KeyTip=\u0026quot;F5\u0026quot; /\u0026gt; \u0026lt;/RibbonGroup\u0026gt; \u0026lt;/RibbonTab\u0026gt; \u0026lt;/Ribbon\u0026gt;  As the code shows, the CommandManagerBinding extension automatically resolves the Refresh command from the CommandManager.\nCommand containers When implementing a ribbon or any menu structure inside an application can result in a very complex view model containing all the commands. Catel solves this issue by implementing so-called command containers. These are containers that have only 1 purpose: contain a command so the logic can easily be viewed / edited and the commands will be available during the whole lifetime of the app. Internally command containers use the ICommandManager to register commands, so the ICommandManager is still responsible for the commands.\nCreating a command container Creating a command container is very simple. It can be done by creating a class deriving from CommandContainerBase as shown in the example below:\npublic class ApplicationAboutCommandContainer : CommandContainerBase { private readonly IAboutService _aboutService; public ApplicationAboutCommandContainer(ICommandManager commandManager, IAboutService aboutService) : base(Commands.Application.About, commandManager) { Argument.IsNotNull(() =\u0026gt; aboutService); _aboutService = aboutService; } protected override Execute(object parameter) { _aboutService.ShowAbout(); } }  As you can see the implementation is very clean and won\u0026rsquo;t pollute any other view models.\nRegistering a command container If you don\u0026rsquo;t use the extension methods below, you must register the command container inside the service locator and register the command inside the ICommandManager. To make this process easier, use a definition file and the code below.\nCommand definitions To make it very easy to register new commands, Catel uses naming conventions and extension methods. The name of the command (for example, About must be a constant on the command definitions class). If the command definition also contains a \u0026lt;CommandName\u0026gt;InputGesture, in this case AboutInputGesture, it will use that input gesture as a default to register the command with.\npublic static class Commands { public static class Application { public const string Exit = \u0026quot;Application.Exit\u0026quot;; public static readonly InputGesture ExitInputGesture = new InputGesture(Key.F4, ModifierKeys.Alt); public const string About = \u0026quot;Application.About\u0026quot;; public static readonly InputGesture AboutInputGesture = new InputGesture(Key.F1); } public static class OtherPartOfApplication { public const string SomeCommand = \u0026quot;OtherPartOfApplication.SomeCommand\u0026quot;; public static readonly InputGesture SomeCommandInputGesture = null; } }  It is recommended to keep a well formed structure for your command definitions to keep them manageable, even in very large applications  Registering the command container Once you have the command container and the command definition (command name and the input gesture), it is time to register the command container:\nvar commandManager = ServiceLocator.Default.ResolveType\u0026lt;ICommandManager\u0026gt;(); commandManager.CreateCommandWithGesture(typeof(Commands.Application), \u0026quot;About\u0026quot;);  This will keep the command registration very readable and maintainable when using a lot of commands:\nvar commandManager = ServiceLocator.Default.ResolveType\u0026lt;ICommandManager\u0026gt;(); commandManager.CreateCommandWithGesture(typeof(AppCommands.Application), \u0026quot;Exit\u0026quot;); commandManager.CreateCommandWithGesture(typeof(AppCommands.Application), \u0026quot;About\u0026quot;); commandManager.CreateCommandWithGesture(typeof(Commands.Project), \u0026quot;Open\u0026quot;); commandManager.CreateCommandWithGesture(typeof(Commands.Project), \u0026quot;Save\u0026quot;); commandManager.CreateCommandWithGesture(typeof(Commands.Project), \u0026quot;SaveAs\u0026quot;); commandManager.CreateCommandWithGesture(typeof(Commands.Project), \u0026quot;Refresh\u0026quot;); commandManager.CreateCommandWithGesture(typeof(AppCommands.Settings), \u0026quot;ToggleTooltips\u0026quot;); commandManager.CreateCommandWithGesture(typeof(AppCommands.Settings), \u0026quot;ToggleQuickFilters\u0026quot;); commandManager.CreateCommandWithGesture(typeof(ExtensibilityCommands.Application), \u0026quot;Extensions\u0026quot;); commandManager.CreateCommandWithGesture(typeof(ExtensibilityCommands.Application), \u0026quot;ExtensionsSettings\u0026quot;);  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/commands-events/commands/","title":"Commands","tags":[],"description":"","content":" Commands are supported in Catel. The base class for commands is Command.\nCode snippets  vmcommand - declare a command on a view model vmcommandwithcanexecute - declare a command with support for CanExecute on a view model  Explanation To implement commands, and still be able to unit test the view models, a separate command is introduced. This command allows a developer to implement a command that can be invoked both via code (unit testing) and UI.\nThere are several classes to represent a command:\n Command\\\u0026lt;TCanExecuteParameter, TExecuteParameter\\\u0026gt; - synchronous commands TaskCommand\\\u0026lt;TCanExecuteParameter, TExecuteParameter\\\u0026gt; - asynchronous commands  The TCanExecuteParameter is the parameter that is passed to the CanExecute of the command, ands saves the developer from casting the object (as in the interface ICommand to a typed object). The same goes for TExecuteParameter which makes the Execute of the command typed.\nExamples Xaml (assuming that the view model is set as datacontext):\n\u0026lt;Button Content=\u0026quot;Click me\u0026quot; Command=\u0026quot;{Binding MyCommand}\u0026quot; /\u0026gt;  Async Code:\nprivate readonly IMessageService _messageService; public void MyViewModel(IMessageService messageService) { Argument.IsNotNull(() =\u0026gt; messageService); _messageService = messageService; // Add commands MyAction = new TaskCommand(MyAction_ExecuteAsyc); } /// \u0026lt;summary\u0026gt; /// Gets the MyAction command. /// \u0026lt;/summary\u0026gt; public TaskCommand MyAction { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the MyAction command is executed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;parameter\u0026quot;\u0026gt;The parameter of the command.\u0026lt;/param\u0026gt; private async Task MyAction_ExecuteAsync(object parameter) { // Show message box await _messageService.ShowInfoAsync(\u0026quot;My action in MVVM\u0026quot;); }  Sync Code:\nprivate readonly IMessageService _messageService; public void MyViewModel(IMessageService messageService) { Argument.IsNotNull(() =\u0026gt; messageService); _messageService = messageService; // Add commands MyAction = new Command(MyAction_Execute); } /// \u0026lt;summary\u0026gt; /// Gets the MyAction command. /// \u0026lt;/summary\u0026gt; public Command MyAction { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the MyAction command is executed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;parameter\u0026quot;\u0026gt;The parameter of the command.\u0026lt;/param\u0026gt; private void MyAction_Execute(object parameter) { // Show message box _messageService.ShowInfo(\u0026quot;My action in MVVM\u0026quot;); }  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/commands-events/","title":"Commands &amp; events","tags":[],"description":"","content":"Commanding is supported by Catel. Catel supports Command classes, which is also known as RelayCommand or DelegateCommand in other frameworks. Defining a command on a view model is very easy, as you can see in the code below:\n// TODO: Move code below to constructor Edit = new Command(OnEditExecute, OnEditCanExecute); // TODO: Move code above to constructor /// \u0026lt;summary\u0026gt; /// Gets the Edit command. /// \u0026lt;/summary\u0026gt; public Command Edit { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to check whether the Edit command can be executed. /// \u0026lt;/summary\u0026gt; private bool OnEditCanExecute() { return true; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the Edit command is executed. /// \u0026lt;/summary\u0026gt; private void OnEditExecute() { // TODO: Handle command logic here }  There are some people who don’t like the ICommand implementations. For example, Caliburn (Micro) uses convention and does not require the creation of a command. There are a few downsides for that:\n It requires you to make sure the name of the control is the same as the method; It is not clear that it is actually a command if you are not fully familiar with the conventions; The methods need to be public (otherwise, how are you going to invoke the commands during unit tests?), which make them freely available (and that’s not something we like); You will always have to invoke CanExecute yourself again in Execute, because you have no guarantee that the source of Execute is actually the convention mapping; There is no way to manually refresh the CanExecute state on the bound controls.  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/commands-events/authentication/","title":"Commands authentication","tags":[],"description":"","content":" One of the questions an MVVM developer faces is how to control the executation state of a command by role or user authentication method. Catel offers an out-of-the-box solution for this problem to check the CanExecute state of the commands in the UI. It is very important that this way of disabling commands is only used to easy the development of consistent user interfaces. It cannot replace the actual check whether a user can or cannot modify data. The actual and final responsibility still lays at the business layer.\nTagging your commands To know whether a specific user can execute a command, you need to be able to distinguish one command from another. The ICatelCommand interface (which derives from ICommand) providers a Tag property that allows you to tag the command with any object that fits your needs. In one application, commands might be distinguished using strings, other applications use integer ID\u0026rsquo;s.\nA tag must be set in the constructor of a command and cannot be changed:\nEdit = new Command(OnEditExecute, OnEditCanExecute, \u0026quot;editCommand\u0026quot;);  IAuthenticationProvider The IAuthenticationProvider is a provider that needs to be implemented per application and must be registered in the IoC container. Below is the interface definition:\n/// \u0026lt;summary\u0026gt; /// Interface to allow an authentication mechanism to control the CanExecute state of a command. /// \u0026lt;/summary\u0026gt; public interface IAuthenticationProvider { /// \u0026lt;summary\u0026gt; /// Determines whether the specified \u0026lt;paramref name=\u0026quot;command\u0026quot;/\u0026gt; can be executed. The class implementing this interface /// can use any required method to check the command. /// \u0026lt;para /\u0026gt; /// It is recommended to use the \u0026lt;see cref=\u0026quot;ICatelCommand.Tag\u0026quot;/\u0026gt; property to identify a command. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;command\u0026quot;\u0026gt;The command that is requested.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;commandParameter\u0026quot;\u0026gt;The command parameter.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt; /// \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if this instance [can command be executed] the specified command; otherwise, \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;. /// \u0026lt;/returns\u0026gt; /// \u0026lt;remarks\u0026gt; /// The \u0026lt;c\u0026gt;CanExecute\u0026lt;/c\u0026gt; state of a command is queried a lot. The command itself does not cache any results because /// it is not aware of role or identity changes. If caching is required, this must be implemented in the class implementing /// the \u0026lt;see cref=\u0026quot;ICommandAuthenticationProvider\u0026quot;/\u0026gt; interface. /// \u0026lt;/remarks\u0026gt; bool CanCommandBeExecuted(ICatelCommand command, object commandParameter); }  To register a custom implementation of the command authentication provider, use the code below:\nCatel.IoC.ServiceLocator.Instance.RegisterType\u0026lt;IAuthenticationProvider, RoleAuthenticationProvider\u0026gt;();  The code above registers a custom made command authentication provider that checks whether a specific role can execute the command.\nCatel checks whether an `IAuthenticationProvider` is registered. If not, the way commands are handled is not affected in any way. If there is an `IAuthenticationProvider` available, the `CanExecute` state is checked, even when there is no custom `CanExecute` implemented.  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/configuration/","title":"Configuration","tags":[],"description":"","content":" Catel makes it very easy to use configurations on all supported platforms. Below is a table to explain what technology is used per platform to retrieve and store configuration values.\n   Platform Technology     .NET ConfigurationManager.AppSettings   UWP ApplicationData.Current.LocalSettings   PCL Not supported    Getting values from the configuration To retrieve values from the configuration, use the following code:\nvar configurationService = new ConfigurationService(); var mySetting = configurationService.GetValue\u0026lt;int\u0026gt;(\u0026quot;mySetting\u0026quot;, 42);  The code above will retrieve the values from the configuration. If the configuration value does not exist, it will return 42 as default value.\nIt's best to retrieve the service from the dependency resolver or let it be injected into the classes using it  Setting values to the configuration To store values in the configuration, use the following code:\nvar configurationService = new ConfigurationService(); configurationService.SetValue(\u0026quot;mySetting\u0026quot;, 42);  It's best to retrieve the service from the dependency resolver or let it be injected into the classes using it  Customizing the way values are stored The ConfigurationService is written with extensibility in mind. Though it defaults to the .NET local storage system, it is very easy to create a customized configuration service. Below is an example on how to customize the service so it reads and writes values from/to a database.\npublic class DbConfigurationService : ConfigurationService { protected override bool ValueExists(string key) { using (var context = new ConfigurationContext()) { return (from config in context.Configurations where config.Key == key select config).Any(); } } protected override string GetValueFromStore(string key) { using (var context = new ConfigurationContext()) { return (from config in context.Configurations where config.Key == key select config.Value).First(); } } protected override void SetValueToStore(string key, string value) { using (var context = new ConfigurationContext()) { var configuration (from config in context.Configurations where config.Key == key select config).FirstOrDefault(); if (configuration == null) { configuration = context.CreateObject\u0026lt;Configuration\u0026gt;(); configuration.Key = key; } configuration.Value = value; context.SaveChanges(); } } }  Don't forget to register the customized *ConfigurationService* in the *ServiceLocator*  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/console-log-listener/","title":"ConsoleLogListener","tags":[],"description":"","content":"The ConsoleLogListener writes messages to the console with automatic colors:\nTo add it, use the code below:\nvar logListener = new ConsoleLogListener(); logListener.IgnoreCatelLogging = true; // TODO: Customize options LogManager.AddListener(logListener);  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/view-models/advanced/controlling-instantiation-of-view-models/","title":"Controlling the instantiation of view models","tags":[],"description":"","content":" Starting with Catel 3.1, it is possible to take control of the view model instantiation of a view dynamically at runtime. This feature can be used when the construction of a view model is more complex than injecting the datacontext as model, or when the view model instance in a custom repository should be re-used.\nHow to control the view model instantiation using the IViewModelFactory The IViewModelFactory is the best way to customize the instantiation of view models in Catel. This allows full control for all view models because the factory will be used to create all view models, except when any other methods described below are used.\nIf customization of the view model instantiation is required, it is best the derive from the default ViewModelFactory class to be able to fall back to the default behavior in non-special cases.\npublic class CustomViewModelFactory : ViewModelFactory { public override IViewModel CreateViewModel(Type viewModelType, object dataContext) { if (viewModelType == typeof(MySpecialViewModel)) { // Use custom constructor with dependency injection return new MySpecialViewModel(dep1, dep2, dep3, dataContext); } // Fall back to default behavior return base.CreateViewModel(viewModelType, dataContext); } }  When a custom factory is used, it is important to register it in the ServiceLocator:\nServiceLocator.Default.RegisterType\u0026lt;IViewModelFactory, CustomViewModelFactory\u0026gt;();  How to control the view model instantiation using a UserControl Note that it is best to use the `IViewModelFactory` for view model instantation because it is a more generic solution  Controlling the instantiation of the view model dynamically when using the UserControl is extremely easy. You can override the GetViewModelInstance(object) method like this:\nprotected override IViewModel GetViewModelInstance(object dataContext) { if (dataContext is Rectangle) { return new RectangleViewModel((Rectangle)dataContext); } return null; }  When the method returns null, the logic will try to construct the view model by itself.\nHow to control the view model instantiation using a behavior Note that it is best to use the `IViewModelFactory` for view model instantation because it is a more generic solution  Controlling the instantiation of the view model dynamically when using behaviors must be done via the DetermineViewModelInstance event like this:\nmvvmBehavior.DetermineViewModelInstance += (sender, e) =\u0026gt; { var dataContext = e.DataContext; if (dataContext is Rectangle) { e.ViewModel = new RectangleViewModel((Rectangle)dataContext); } };  There is no need to set the e.ViewModel to null because that is the default value.\nPreventing the logic to create a view model by itself When using the behavior, it is possible to prevent the logic to instantiate a view model. In this case, it is really possible to have full control over view model instantiation. To prevent the logic to create a view model, use this code:\nmvvmBehavior.DetermineViewModelInstance += (sender, e) =\u0026gt; { var dataContext = e.DataContext; if (dataContext is Rectangle) { e.ViewModel = new RectangleViewModel((Rectangle)dataContext); } e.DoNotCreateViewModel = true; };  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/converters/","title":"Converters","tags":[],"description":"","content":" In MVVM, there will be some point where you will need to use converters. Most of these converters are used in any project, so we have decided to add them to Catel. Below is a list of converters and a short description what they are used for.\nNote that the behavior of most converters can be inverted by using the `ConverterParameter`  Linking converters It is possible to link converters. To link converters, simply set the Link property in xaml:\n\u0026lt;catel:NullableValueConverter x:Key=\u0026quot;NullableValueConverter\u0026quot; /\u0026gt; \u0026lt;catel:BooleanToVisibilityConverter\u0026gt; \u0026lt;catel:BooleanToVisibilityConverter.Link\u0026gt; \u0026lt;code:NullToBoolConverter Link=\u0026quot;{StaticResource NullableValueConverter}\u0026quot; /\u0026gt; \u0026lt;/catel:BooleanToVisibilityConverter.Link\u0026gt; \u0026lt;/catel:BooleanToVisibilityConverter\u0026gt;  Available converters    Name Description     AreEqualMultiValueConverter Converts the comparison of 2 values to a boolean   BooleanToCollapsingVisibilityConverter Convert from bool to Visibility and back.   BooleanToHidingVisibilityConverter Convert from bool to Visibility and back.   BooleanToGrayscaleConverter Converts a boolean to a grayscale saturation value. If the input is false, this converter will return 0, otherwise 1.   BooleanToOppositeBooleanConverter Convert a boolean to it\u0026rsquo;s inverted value.   BooleanToTextConverter Converts a boolean value to text, for example \u0026ldquo;yes\u0026rdquo; and \u0026ldquo;no\u0026rdquo;, or \u0026ldquo;x\u0026rdquo; and \u0026ldquo; \u0026ldquo;.   BooleanToCollapsingVisibilityConverter Convert from bool to Visibility and back. True returns Visibility.Visible, False returns Visibility.Collapsed.   BooleanToHidingVisibilityConverter Convert from bool to Visibility and back. True returns Visibility.Visible, False returns Visibility.Hidden.   ColorToBrushConverter Converts a color value to a brush and vice versa.   ContainsItemsConverter Convert the count of an ICollection or IEnumerable to true or false, depending on whether the instance contains items.    For an instance which implements ICollection, check Count \u0026gt; 0\nFor an instance which implements IEnumerable, if the instance can be Enumerated.\nCountCollapsedConverter|Converts the \u0026lsquo;count\u0026rsquo; of ICollection, string, long, int or short to Visibility.Visible or Visibility.Collapsed\nVisible means: ICollection.Count \u0026gt; 0, String.Length \u0026gt; 0 or long, int, short \u0026gt; 0.\nCountHiddenConverter|Converts the \u0026lsquo;count\u0026rsquo; of ICollection, string, long, int or short to Visibility.Visible or Visibility.Hidden\nVisible means: ICollection.Count \u0026gt; 0, String.Length \u0026gt; 0 or long, int, short \u0026gt; 0.\nEmptyStringToCollapsingVisibilityConverter|Converts a string to Visibility. If the string is empty, it will return Visibility.Collapsed. EmptyStringToHidingVisibilityConverter|Converts a string to Visibility. If the string is empty, it will return Visibility.Hidden. EnumToCollapsingVisibilityConverter|Converts an enum to Visibility. The allowed values must be defined inside the ConverterParameter as shown below (element will be visible when MyEnumValue is Enum1 or Enum3):\n\u0026lt;TextBlock Visibility=\u0026quot;{Binding MyEnumValue, Converter={converters:EnumToCollapsingVisibilityConverter}, ConverterParameter=Enum1|Enum3}\u0026quot;/\u0026gt;  If the ConverterParameter starts with !, the element will not be visible for the specified enum values\nEnumToHidingVisibilityConverter|Converts an enum to Visibility. The allowed values must be defined inside the ConverterParameter as shown below (element will be visible when MyEnumValue is Enum1 or Enum3):\n\u0026lt;TextBlock Visibility=\u0026quot;{Binding MyEnumValue, Converter={converters:EnumToHidingVisibilityConverter}, ConverterParameter=Enum1|Enum3}\u0026quot;/\u0026gt;  If the ConverterParameter starts with !, the element will not be visible for the specified enum values\nFormattingConverter|Formats the value using the format string provided in the ConverterParameter IsSelectedConverter|Converts a selected value to either true of false. IsSelectedValueConverter|Converts a selected value to either true of false. GetFirstValidationErrorConverter|Converts a collection containing ValidationError objects to return the first error or an empty string in case there are no errors. IsSelectedConverter|Converts a selected value to either true or false. Useful whena mutually exclusive selection must be made. IntToStringConverter|Converts an inteteger to a string and back. LanguageConverter|Converts the string (value) to a translated value using the ILanguageService. The parameter can be specified, then it should be a CultureInfo. MethodToValueConverter|Converts the result of a method to a value. This makes it possible to bind to a method. See Source MultiplyConverter|Calculates the product of given value and factor in parameter. NullableValueConverter|Converts a value to a representive value for nullable. ObjectToDisplayNameConverter|Converts any value to a display name. Uses the DisplayNameAttribute to handle the tough work. PlatformToBooleanConverter|Converts a value of KnownPlatforms to a boolean based on the current platform. This makes it possible to enable / disable functionality in shared projects based on the target platform. ReferenceToBooleanConverter|Converts a reference to a boolean. If the reference is null, it will return false. ReferenceToCollapsingVisibilityConverter|Converts a reference to Visibility. If the reference is null, it will return Visibility.Collapsed. ReferenceToHidingVisibilityConverter|Converts a reference to Visibility. If the reference is null, it will return Visibility.Hidden. ShortDateFormattingConverter|Converts a date to a short date and back. StringToIntConverter|Converts string to an integer and back. ViewModelToViewConverter|Converts a view model to a view. Great way to locate a view based on a view model inside xaml.\n"},{"uri":"https://docs.catelproject.com/vnext/tips-tricks/core/","title":"Core","tags":[],"description":"","content":" "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/view-models/creating-basic-view-model/","title":"Creating a basic view model","tags":[],"description":"","content":" This example shows how to create a view model without a model. This is useful when a UI item should simply acknowledge a step that doesn\u0026rsquo;t need to be persisted to a persistence store. The view model does include validation.\nCode snippets  vm - declare a view model vmprop - declare a property on a view model  Explanation When implementing a simple view model without a model, only one property has to be implemented that represents the checkbox that needs to be checked. The example view model declares a single property using the vmprop code snippet. Then, a field error is set if the user has not agreed in the ValidateFields method.\nCode C#\n/// \u0026lt;summary\u0026gt; /// Simple view model. /// \u0026lt;/summary\u0026gt; public class SimpleViewModel : ViewModelBase { /// \u0026lt;summary\u0026gt; /// Gets the title of the view model. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;The title.\u0026lt;/value\u0026gt; public override string Title { get { return \u0026quot;Just acknowledge\u0026quot;; } } /// \u0026lt;summary\u0026gt; /// Gets or sets whether the user has agreed to continue. /// \u0026lt;/summary\u0026gt; public bool UserAgreedToContinue { get { return GetValue\u0026lt;bool\u0026gt;(UserAgreedToContinueProperty); } set { SetValue(UserAgreedToContinueProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the UserAgreedToContinue property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData UserAgreedToContinueProperty = RegisterProperty(\u0026quot;UserAgreedToContinue\u0026quot;, typeof(bool)); /// \u0026lt;summary\u0026gt; /// Validates the fields. /// \u0026lt;/summary\u0026gt; protected override void ValidateFields(List\u0026lt;FieldValidationResult\u0026gt; validationResults) { // Check if the user agrees to continue if (!UserAgreedToContinue) { validationResults.Add(FieldValidationResult.CreateError(UserAgreedToContinueProperty, \u0026quot;User must agree to continue\u0026quot;); } } }   **XAML (assuming that the view model is set as datacontext) **\n\u0026lt;CheckBox Content=\u0026quot;Check me to continue\u0026quot; IsChecked=\u0026quot;{Binding UserAgreedToContinue, NotifyOnValidationError=True, ValidatesOnDataErrors=True}\u0026quot; /\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/view-models/creating-view-model-with-model/","title":"Creating a view model with a model","tags":[],"description":"","content":" This example shows how to create a \u0026ldquo;classical\u0026rdquo; view model without any Catel specific MVVM features such as data pass-through. Although it is recommended to use the pass-through features, some people want to have custom validation on the view model, or want to be fully in control.\nCode snippets  vm - declare a view model vmprop - declare a property on a view model  Explanation To be in full control, the only thing required is to create a basic view model with the vm code snippet. Then, the following methods should be implemented:\n Constructor - initialize the properties on the view model ValidateFields - check for field errors in the view model ValidateBusinessRules - check for business rules in the view model Save - save the view model data to the model and then save the model  Code C#\n/// \u0026lt;summary\u0026gt; /// Classical view model. /// \u0026lt;/summary\u0026gt; public class ClassicalViewModel : ViewModelBase { #region Properties /// \u0026lt;summary\u0026gt; /// Gets or sets the Person. /// \u0026lt;/summary\u0026gt; private Person Person { get { return GetValue\u0026lt;Person\u0026gt;(PersonProperty); } set { SetValue(PersonProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Person property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData PersonProperty = RegisterProperty(\u0026quot;Person\u0026quot;, typeof(Person)); /// \u0026lt;summary\u0026gt; /// Gets or sets the first name. /// \u0026lt;/summary\u0026gt; public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FirstName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string)); /// \u0026lt;summary\u0026gt; /// Gets or sets the last name. /// \u0026lt;/summary\u0026gt; public string LastName { get { return GetValue\u0026lt;string\u0026gt;(LastNameProperty); } set { SetValue(LastNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the LastName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData LastNameProperty = RegisterProperty(\u0026quot;LastName\u0026quot;, typeof(string)); #endregion #region Methods /// \u0026lt;summary\u0026gt; /// Initializes the object by setting default values. /// \u0026lt;/summary\u0026gt; protected override void Initialize() { // Get the person from (in this case) a magical context Person = Context.CurrentPerson; // Load the data manually to the view model FirstName = Person.FirstName; LastName = Person.LastName; } /// \u0026lt;summary\u0026gt; /// Validates the field values of this object. Override this method to enable /// validation of field values. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results, add additional results to this list.\u0026lt;/param\u0026gt; protected override void ValidateFields(List\u0026lt;FieldValidationResult\u0026gt; validationResults) { if (string.IsNullOrWhiteSpace(FirstName)) { validationResults.Add(FieldValidationResult.CreateError(FirstNameProperty, \u0026quot;First name is required\u0026quot;)); } if (string.IsNullOrWhiteSpace(LastName)) { validationResults.Add(FieldValidationResult.CreateError(LastNameProperty, \u0026quot;Last name is required\u0026quot;)); } } /// \u0026lt;summary\u0026gt; /// Saves the data. /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt; /// \u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if successful; otherwise \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;. /// \u0026lt;/returns\u0026gt; protected override Task\u0026lt;bool\u0026gt; Save() { return Task.Factory.StartNew(() =\u0026gt; { // Save the data manually to the model Person.FirstName = FirstName; Person.LastName = LastName; // Save the model return Person.Save(); }); } #endregion }  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/view-models/creating-view-model-with-model-and-mappings/","title":"Creating a view model with a model and mappings","tags":[],"description":"","content":" During of the use of the MVVM pattern, we noticed that lots and lots of developers have a model, and map the values of the model to all properties of the view model. When the UI closes, the developers map all the properties back to the model. All this redundant code is not necessary when using the view models of Catel.\nIn Catel, we have created attributes that allow you to define a property as a model. A model is a property that a part of the view model represents to the user. A view model might have multiple models if it is a combination of several models.\nTo use the mapping features, the following attributes are very important:\n ModelAttribute - declare a model in a view model ViewModelToModelAttribute - declare a mapping from a view model property to a model property  In Catel 4.0 a new mapping mechanism is introduced that makes it possible to convert types of properties of the mappings between the Model and ViewModel. It is also possible to map to a collection of properties to a single property as result (like MultiBinding and Converter in WPF).\nTo use new mechanism you should declare this attributes:\n ConverterType - declare a type of converter that converts properties, converter should implement IViewModelToModelConverter. It is recommended to use ViewModelToModelConverterBase as base class for custom converters. The default converter used is DefaultViewModelToModelMappingConverter that provides basic 1:1 mappings between the model and view model. AdditionalConstructorArgs - declare a arguments witch would be passed to converter constructor via reflection AdditionalPropertiesToWatch - declare properties, which changes would trigger the converter  Code snippets  vm - declare a view model vmpropmodel - declare a property as model on a view model vmpropviewmodeltomodel - declare a property as a pass-through property on a view model\u0026rdquo;  Explanation Defining a model is very simple, you only have to decorate your property with the ModelAttribute:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the person. /// \u0026lt;/summary\u0026gt; [Model] public IPerson Person { get { return GetValue\u0026lt;IPerson\u0026gt;(PersonProperty ); } private set { SetValue(PersonProperty , value); } } /// \u0026lt;summary\u0026gt; /// Register the Person property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData PersonProperty = RegisterProperty(\u0026quot;Person\u0026quot;, typeof(IPerson));  Using the ModelAttribute is very powerful. Basically, this is the extended functionality in the view model. If the model supports IEditableObject, BeginEdit is automatically called in the initialization of the view model. When the view model is canceled, the CancelEdit is called so the changes are undone.\nWhen a model is defined, it is possible to use the ViewModelToModelAttribute, as you can see in the code below:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the FirstName of the person. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Person\u0026quot;)] public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FirstName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string)); /// \u0026lt;summary\u0026gt; /// Gets or sets the LastName of the person. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Person\u0026quot;)] public string LastName { get { return GetValue\u0026lt;string\u0026gt;(LastNameProperty); } set { SetValue(LastNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the LastName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData LastNameProperty = RegisterProperty(\u0026quot;LastName\u0026quot;, typeof(string));  If there is a single model on a view model, the name of the model in the `ViewModelToModel` can be ommitted as shown in the code below: ``` [ViewModelToModel] public string FirstName { get { return GetValue(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } public static readonly PropertyData FirstNameProperty = RegisterProperty(\"FirstName\", typeof(string)); ```  The ViewModelToModelAttribute in the code example above automatically maps the view model FirstName and LastName properties to the Person.FirstName and Person.LastName properties. This way, you don’t have to manually map the values from and to the model. Another nice effect is that the view model automatically validates all objects defined using the ModelAttribute, and all field and business errors mapped are automatically mapped to the view model.\nSometimes you need the full name of a person, you can easily acquire it by creating a custom converter:\n public class CollapsMappingConverter : DefaultViewModelToModelMappingConverter { #region Fields private readonly char _separator; #endregion #region Constructors public CollapsMappingConverter(string[] propertyNames) : this(propertyNames, ' ') { } public CollapsMappingConverter(string[] propertyNames, char separator = ' ') : base(propertyNames) { _separator = separator; } #endregion #region Properties public char Separator { get { return _separator; } } #endregion #region Methods public override bool CanConvert(Type[] types, Type outType, Type viewModelType) { return types.All(x =\u0026gt; x == typeof (string)) \u0026amp;\u0026amp; outType == typeof (string); //check that all input and output values are strings } public override object Convert(object[] values, IViewModel viewModel) { return string.Join(Separator.ToString(), values.Where(x =\u0026gt; !string.IsNullOrWhiteSpace((string) x))); } public override bool CanConvertBack(Type inType, Type[] outTypes, Type viewModelType) { return outTypes.All(x =\u0026gt; x == typeof (string)) \u0026amp;\u0026amp; inType == typeof (string); //check that all input and output values are strings } public override object[] ConvertBack(object value, IViewModel viewModel) { return ((string) value).Split(Separator); } #endregion }  Now, when we created the converter we should define it in mapping like this:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the FullName of the person. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Person\u0026quot;, \u0026quot;FirstName\u0026quot;, AdditionalPropertiesToWatch = new[] { \u0026quot;LastName\u0026quot; }, ConverterType = typeof(CollapsMappingConverter))] public string FullName { get { return GetValue\u0026lt;string\u0026gt;(FullNameProperty); } set { SetValue(FullNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the LastName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FullNameProperty = RegisterProperty(\u0026quot;FullName\u0026quot;, typeof(string));  The ViewModelToModelAttribute in the code example above automatically maps the view model FullName property to the Person.FirstName and Person.LastName properties and converts them with CollapsMappingConverter. This way, you don’t have to manually map the values from the model and update FullName property when FirstName or LastName property changed.\nSummarized, the Model and ViewModelToModel attributes make sure no duplicate validation and no manual mappings are required.\n "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/customizing-datacontext-subscription-behavior/","title":"Customizing DataContext subscription behavior","tags":[],"description":"","content":" Starting with Catel 4.0, the views watch both the direct and inherited DataContext. Starting with Catel 4.1, it is possible to mimick the pre 4.0 DataContext subscription behavior.\nCustomizing the behavior for all views To mimick pre Catel 4.0, use the following code:\nvar dependencyResolver = this.GetDependencyResolver(); var dataContextSubscriptionService = dependencyResolver.Resolve\u0026lt;IDataContextSubscriptionService\u0026gt;(); dataContextSubscriptionService.DefaultDataContextSubscriptionMode = DataContextSubscriptionMode.DirectDataContext;  Customizing the behavior per view It is also customize the behavior per view. This allows very customized fine tuning of the behavior. To use this feature, one needs to create a custom implementation of the IDataContextSubscriptionService.\npublic class CustomDataContextSubscriptionService : DataContextSubscriptionService { public override DataContextSubscriptionMode GetDataContextSubscriptionMode(Type viewType) { // TODO: Add logic here return base.GetDataContextSubscriptionMode(viewType); } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/data-handling/","title":"Data handling","tags":[],"description":"","content":"This part of the documentation is all about data handling the way it should that is available via Catel. Some parts are based on the article on Code Project, but this documentation is more up-to-date.\nThe first thing that is important is that lots of developers lose way too much time writing custom serializable objects. Serialization is a field of expertise, and only a handful of developers I know really master the serialization of objects (think of version changes of the assembly, class changes (new or removed properties), etc.). Most developers think they master serialization by creating a BinaryFormatter object like the code belows show:\nvar serializer = new BinaryFormatter(); var myObject = (MyObject)serializer.Deserialize(stream);  Most developers don’t know that reflection breaks when:\n You change the version number of your assembly; You add or remove a property or field; You add or remove an event.  And even if you know, it takes a lot of knowledge and courage to start beating the beast of burden. Like every developer, I also encountered this and was writing backwards compatibility code until I had enough of it and decided to master the field of serialization. The result is the ModelBase class, which can be used as a base class for all data objects that need to be held in memory and maybe serialized to disk (or a stream, or XML, or \u0026hellip;).\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/advanced/datawindow-under-the-hood/","title":"DataWindow - under the hood","tags":[],"description":"","content":"This documentation has to be written in the future  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/debug-log-listener/","title":"DebugLogListener","tags":[],"description":"","content":"The DebugLogListener is the best debugging tool there is during development. It shows you insight in your application in the output window of Visual Studio, even from messages generated by Catel. To use it, use this:\n#if DEBUG LogManager.AddDebugListener(); #endif  For some platforms (like UWP), Catel uses `Debug.WriteLine` which gets removed in a release build. For such platforms, it is recommended to create a customer log listener as shown below.  public class DebugLogListener : LogListenerBase { protected override void Write(ILog log, string message, LogEvent logEvent, object extraData, LogData logData, DateTime time) { if (log.IsCatelLogging \u0026amp;\u0026amp; IgnoreCatelLogging) { return; } var consoleMessage = FormatLogEvent(log, message, logEvent, extraData, logData, time); System.Diagnostics.Debug.WriteLine(consoleMessage); } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/delay-binding-update/","title":"DelayBindingUpdate","tags":[],"description":"","content":"Sometimes, a binding update should be delayed for performance reasons. This is possible using the DelayBindingUpdate behavior. This behavior modifies the binding mode to explicit and internally watches for property changes. If the bound dependency property changes, the behavior will wait for the time to pass and then update. If the value changes again within the timeframe, the timer is reset (so you won\u0026rsquo;t get \u0026ldquo;double\u0026rdquo; updates).\n1) Add the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  2) Use the following definition. This example will delay the update of the SelectedItem binding with 100 milliseconds:\n\u0026lt;ListBox x:Name=\u0026quot;listBox\u0026quot; ItemsSource=\u0026quot;{Binding PersonCollection}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedPerson}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:DelayBindingUpdate PropertyName=\u0026quot;SelectedItem\u0026quot; UpdateDelay=\u0026quot;100\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/ListBox\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/designers/design-time-view-models/","title":"Design-time view models","tags":[],"description":"","content":"Lots of developers are using designers such as the built-in designer in Visual Studio or Expression Blend to design their xaml based applications. Although you should use designers with lots of care, we strive to fully support all designers.\nSince Catel 1.3, it is possible to create design-time versions of a view model. This way, you can preview the UserControl or DataWindow implementations using example data.\nTo create design-time support for a data window, use the following steps:\n1. Create a design time view model. Normally, this can easily be achieved by deriving a new class from the actual view-model and inject the model. Below is an example of a design time version of a person view model:\n/// \u0026lt;summary\u0026gt; /// Design time version of the \u0026lt;see cref=\u0026quot;PersonViewModel\u0026quot;/\u0026gt;. /// \u0026lt;/summary\u0026gt; public class DesignPersonViewModel : PersonViewModel { /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;DesignPersonViewModel\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; public DesignPersonViewModel() : base(new Person { FirstName = \u0026quot;Geert\u0026quot;, MiddleName = \u0026quot;van\u0026quot;, LastName = \u0026quot;Horrik\u0026quot;, Gender = Gender.Male }) { } }  2. Define the type of the design time view model.\nd:DataContext=\u0026quot;{d:DesignInstance ViewModels:DesignPersonViewModel}\u0026quot;  If you want it to actually show demo data (instead of allowing to configure bindings), use IsDesignTimeCreatable:\nd:DataContext=\u0026quot;{d:DesignInstance ViewModels:DesignPersonViewModel, IsDesignTimeCreatable=True}\u0026quot;  Full DataWindow declaration:\n\u0026lt;catel:DataWindow x:Class=\u0026quot;Catel.Examples.PersonApplication.UI.Windows.PersonWindow\u0026quot; xmlns=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026quot; xmlns:x=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml\u0026quot; xmlns:d=\u0026quot;http://schemas.microsoft.com/expression/blend/2008\u0026quot; xmlns:mc=\u0026quot;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot; xmlns:ViewModels=\u0026quot;clr-namespace:Catel.Examples.PersonApplication.ViewModels\u0026quot; xmlns:Converters=\u0026quot;clr-namespace:Catel.Examples.PersonApplication.Data.Converters\u0026quot; xmlns:Models=\u0026quot;clr-namespace:Catel.Examples.Models;assembly=Catel.Examples.Models\u0026quot; mc:Ignorable=\u0026quot;d\u0026quot; d:DataContext=\u0026quot;{d:DesignInstance ViewModels:DesignPersonViewModel, IsDesignTimeCreatable=True}\u0026quot;\u0026gt;   Example of design time data support:  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/designers/","title":"Designers","tags":[],"description":"","content":" Design-time view models   Running code at design-time   "},{"uri":"https://docs.catelproject.com/vnext/catel-core/multilingual/displayattribute/","title":"DisplayAttribute","tags":[],"description":"","content":" Catel implements a custom implementation of the DisplayAttribute known in the DataAnnotations namespace of .NET. This attribute uses the ILanguageService so you can easily have all translations in a single location when using Catel.\nNote that this is still work in progress, we would love to support this, but MS sealed the class so we cannot derive from it (at the moment)  Using the attribute Using the attribute is really easy. Just put the attribute on top of any method, property, field or parameter like this:\npublic enum Condition { [DisplayName(\u0026quot;Contains\u0026quot;)] Contains, [Display(\u0026quot;StartsWith\u0026quot;)] StartsWith, [Display(\u0026quot;EndsWith\u0026quot;)] EndsWith, [Display(\u0026quot;EqualTo\u0026quot;)] EqualTo, [Display(\u0026quot;NotEqualTo\u0026quot;)] NotEqualTo, [Display(\u0026quot;GreaterThan\u0026quot;)] GreaterThan, [Display(\u0026quot;LessThan\u0026quot;)] LessThan, [Display(\u0026quot;GreaterThanOrEqualTo\u0026quot;)] GreaterThanOrEqualTo, [Display(\u0026quot;LessThanOrEqualTo\u0026quot;)] LessThanOrEqualTo, [Display(\u0026quot;IsEmpty\u0026quot;)] IsEmpty, [Display(\u0026quot;NotIsEmpty\u0026quot;)] NotIsEmpty, [Display(\u0026quot;IsNull\u0026quot;)] IsNull, [Display(\u0026quot;NotIsNull\u0026quot;)] NotIsNull }  Using the ILanguageService By default, the attribute uses the ILanguageService to resolve the values to show. The DisplayAttribute uses conventions to resolve the different values from the resources.\nProperty|ResourceName used when resolving|Fallback value \u0026mdash;|\u0026mdash; ShortName|[ResourceName]_ShortName|Name Name|[ResourceName]_Name|No fallback value, will return empty value Description|[ResourceName]_Description|No fallback value, will return empty value Prompt|[ResourceName]_Prompt|No fallback value, will return empty value GroupName|[ResourceName]_GroupName|No fallback value, will return empty value\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/multilingual/displaynameattribute/","title":"DisplayNameAttribute","tags":[],"description":"","content":" Catel implements a custom implementation of the DisplayNameAttribute known in the DataAnnotations namespace of .NET. This attribute uses the *ILanguageService* so you can easily have all translations in a single location when using Catel.\nUsing the attribute Using the attribute is really easy. Just put the attribute on top of any method, property, field or parameter like this:\npublic enum Condition { [DisplayName(\u0026quot;Contains\u0026quot;)] Contains, [Display(\u0026quot;StartsWith\u0026quot;)] StartsWith, [Display(\u0026quot;EndsWith\u0026quot;)] EndsWith, [Display(\u0026quot;EqualTo\u0026quot;)] EqualTo, [Display(\u0026quot;NotEqualTo\u0026quot;)] NotEqualTo, [Display(\u0026quot;GreaterThan\u0026quot;)] GreaterThan, [Display(\u0026quot;LessThan\u0026quot;)] LessThan, [Display(\u0026quot;GreaterThanOrEqualTo\u0026quot;)] GreaterThanOrEqualTo, [Display(\u0026quot;LessThanOrEqualTo\u0026quot;)] LessThanOrEqualTo, [Display(\u0026quot;IsEmpty\u0026quot;)] IsEmpty, [Display(\u0026quot;NotIsEmpty\u0026quot;)] NotIsEmpty, [Display(\u0026quot;IsNull\u0026quot;)] IsNull, [Display(\u0026quot;NotIsNull\u0026quot;)] NotIsNull }  Using the ILanguageService By default, the attribute uses the ILanguageService to resolve the values to show. The resource name that is passed into the constructor of the attribute will be used to resolve the localized value.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/double-click-to-command/","title":"DoubleClickToCommand","tags":[],"description":"","content":"Lots of times, a developer needs to handle a double click event. This trigger allows a developer to track a double click on any FrameworkElement and respond to that using a command.\n1) Add the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  2) Use the following definition. This example will invoke the Edit command of the view model when the item is double clicked):\n\u0026lt;ListBox x:Name=\u0026quot;listBox\u0026quot; ItemsSource=\u0026quot;{Binding PersonCollection}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedPerson}\u0026quot;\u0026gt; \u0026lt;ListBox.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:DoubleClickToCommand Command=\u0026quot;{Binding ElementName=listBox, Path=DataContext.Edit}\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;StackPanel Orientation=\u0026quot;Horizontal\u0026quot;\u0026gt; \u0026lt;Label Content=\u0026quot;{Binding FirstName}\u0026quot; /\u0026gt; \u0026lt;Label Content=\u0026quot;{Binding MiddleName}\u0026quot; /\u0026gt; \u0026lt;Label Content=\u0026quot;{Binding LastName}\u0026quot; /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListBox.ItemTemplate\u0026gt; \u0026lt;/ListBox\u0026gt;  The trigger contains an additional property AutoFixListBoxItemTemplate which is set to true by default to easily allow the addition of a double click event to a ListBox. The item template must contain a grid as a base like shown above.\nThis behavior also supports a constructor that accepts an Action. This way, an anonymous delegate can be executed when the behavior is created in code  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/event-tracing-for-windows/","title":"Event Tracing for Windows (ETW)","tags":[],"description":"","content":"Starting with version 4.0.0, Catel supports Event Tracking for Windows (ETW) out of the box. To add a log listener, use the code below:\nvar logListener = new EtwLogListener(); logListener.IgnoreCatelLogging = true; // TODO: Customize options LogManager.AddListener(logListener);  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/event-log-listener/","title":"EventLogListener","tags":[],"description":"","content":"The EventLogListener allow to write log data to the system event log. To add it, use the code below:\nvar logListener = new EventLogListener(); logListener.IgnoreCatelLogging = true; // TODO: Customize options LogManager.AddListener(logListener);  This log listener is currently available only for the full .net framework  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/event-to-command/","title":"EventToCommand","tags":[],"description":"","content":"Almost every respectable MVVM framework supports the EventToCommand trigger. It is a trigger that allows a an event to be turned into a command. This way, you never have to manually add event handlers, search for the view model in the code-behind and then call the right command.\nThe usage is really simple, but requires the System.Windows.Interactivity.dll reference (ships with Catel). The example below shows how to add a trigger for the double click of a ListBox.\n 1) Add the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  2) Use the following definition. This example will invoke the Edit command of the view model):\n\u0026lt;ListBox ItemsSource=\u0026quot;{Binding PersonCollection}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedPerson}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Triggers\u0026gt; \u0026lt;i:EventTrigger EventName=\u0026quot;MouseDoubleClick\u0026quot;\u0026gt; \u0026lt;catel:EventToCommand Command=\u0026quot;{Binding Edit}\u0026quot; DisableAssociatedObjectOnCannotExecute=\u0026quot;False\u0026quot; /\u0026gt; \u0026lt;/i:EventTrigger\u0026gt; \u0026lt;/i:Interaction.Triggers\u0026gt; \u0026lt;ListBox.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;StackPanel Orientation=\u0026quot;Horizontal\u0026quot;\u0026gt; \u0026lt;Label Content=\u0026quot;{Binding FirstName}\u0026quot; /\u0026gt; \u0026lt;Label Content=\u0026quot;{Binding MiddleName}\u0026quot; /\u0026gt; \u0026lt;Label Content=\u0026quot;{Binding LastName}\u0026quot; /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListBox.ItemTemplate\u0026gt; \u0026lt;/ListBox\u0026gt;  If you want to use parameters (in the case of this example, get the MouseDoubleClick event args, set PassEventArgsToCommand to true:\n\u0026lt;Commands:EventToCommand Command=\u0026quot;{Binding Edit}\u0026quot; DisableAssociatedObjectOnCannotExecute=\u0026quot;False\u0026quot; PassEventArgsToCommand=\u0026quot;True\u0026quot; /\u0026gt;  Then, in the view model, you can even make the command \u0026ldquo;type-safe\u0026rdquo;:\n/// \u0026lt;summary\u0026gt; /// Gets the Edit command. /// \u0026lt;/summary\u0026gt; public Command\u0026lt;MouseEventArgs\u0026gt; Edit { get; private set; } // TODO: Move code below to constructor Edit = new Command\u0026lt;MouseEventArgs\u0026gt;(OnEditExecute, OnEditCanExecute); // TODO: Move code above to constructor /// \u0026lt;summary\u0026gt; /// Method to check whether the Edit command can be executed. /// \u0026lt;/summary\u0026gt; private bool OnEditCanExecute(MouseEventArgs e) { return true; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the Edit command is executed. /// \u0026lt;/summary\u0026gt; private void OnEditExecute(MouseEventArgs e) { // TODO: Handle command logic here }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/exception-handling/","title":"Exception handling","tags":[],"description":"","content":" With exception handling in Catel, it is possible to create an exception handling policy and execute code in a safe way without have to check all the exception types manually. Catel exposes this technique via the IExceptionService.\n/**/ Setting up the IExceptionService Executing code using the IExceptionService Executing an action Executing a function Use the retry capabilities Retry Immediately Retry defined Process with retry Subscribe to the retry events Handling exceptions manually Unregistering exceptions Buffering Define the way to buffer Subscribe to the buffering events Determine if an exception type are registered for handling Get a specific exception handler\nAlso see\nWPF implementation for exception handling\nSetting up the IExceptionService It is important to register an exception in the service and let Catel know how it should be handled. The service handles exceptions in the way they are added to the IExceptionService.\nThe example below registers several exceptions and how they should be handled. When a FileNotFoundException occurs, it will show a message to the user. For any other exception, it will log the exception and show a message that the user should contact the developers.\nvar dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver .Resolve\u0026lt;IExceptionService\u0026gt;(); exceptionService.Register\u0026lt;FileNotFoundException\u0026gt;(exception =\u0026gt; dependencyResolver.Resolve\u0026lt;IMessageService\u0026gt;().Show(exception.Message)); exceptionService.Register\u0026lt;Exception\u0026gt;(exception =\u0026gt; { Log.Error(exception); dependencyResolver.Resolve\u0026lt;IMessageService\u0026gt;().Show(\u0026quot;An unknown exception occurred, please contact the developers\u0026quot;); });  The IExceptionService checks for type hierarchy. For example, when an exception as type Exception is registered, this handler will handle all exceptions  Executing code using the IExceptionService The Process method is responsible to keep track of all exceptions which might occur and will handle them if they are registered. If one of your registered exceptions is thrown by the code, the Process method will handle it and perform the action defined while the registration operation (for example, by showing a message box).\nThe Process method comes in two flavors: as action and as function.\nExecuting an action var dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); exceptionService.Process(() =\u0026gt; { throw new ArgumentOutOfRangeException(); });  Executing a function var dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); var result = exceptionService.Process\u0026lt;int\u0026gt;(() =\u0026gt; 1 + 1);  You can process yours actions asynchronously by using the ***ProcessAsync*** method.  Use the retry capabilities In some cases, you can want to have possibility to retry an action a certain number of times before finally handle your exception. Let see how the IExceptionService allows us to handle this kind of cases.\nFirstly, you need to define how the IExceptionService will retry your action in case of error, two possibilities are provided for that.\nRetry Immediately When you setting up your exceptions on IExceptionService, you have to additionnally use the OnErrorRetryImmediately method like shown below :\nvar dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); exceptionService.Register\u0026lt;ArgumentNullException\u0026gt;(exception =\u0026gt; { /* Do something */ }) .OnErrorRetryImmediately();  This method will say to the IExceptionService to retry the action each times this one throw an exception until it succeed and without to wait before the next retry.\nYou can also specify the number of times you want the IExceptionService to retry immediately like this for example : OnErrorRetryImmediately(5)\nRetry defined You have also the possibility to define more deeply the way you want your actions to be retried by using the OnErrorRetry method like shown below.\nvar dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); exceptionService.Register\u0026lt;ArgumentNullException\u0026gt;(exception =\u0026gt; { /* Do something */ }) .OnErrorRetry(5, TimeSpan.FromMinutes(2));  Where 5 represents the nombre of times the action will be retried and TimeSpan.FromMinutes(2) the interval between the retries.\nProcess with retry If you have provided a retry policy, you can use the ProcessWithRetry method to expect have your policy applied on error. Below an example :\nvar dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); exceptionService.ProcessWithRetry(() =\u0026gt; { /* Do something */ });  Subscribe to the retry events Can you subscribe to the events which are thown each time an action is retried like this :\nvar dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); exceptionService.RetryingAction += (sender, eventArgs) =\u0026gt; Console.WriteLine(\u0026quot;The '{0}' have caused retrying action for the '{1}' times.\u0026quot;, eventArgs.LastException, eventArgs.CurrentRetryCount);  Handling exceptions manually It is possible to manually handle exceptions using the service. This is useful when you don\u0026rsquo;t want to wrap code in the Process method, but still want to be able to create a generic exception handling policy.\nvar dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); try { var value = 150/0; } catch (DivideByZeroException exception) { exceptionService.HandleException(exception); }  If the exception can be handled, the registered action will be executed, but your code can safely continue. If the exception (in this case DivideByZeroException) is not registered, the HandleException method will rethrow the exception.\nUnregistering exceptions Although it will probably hardly used, it is possible to unregister exceptions again using the code below:\nvar exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); exceptionService.Unregister\u0026lt;ArgumentException\u0026gt;();  Buffering Define the way to buffer You can want to throttle down the number of exceptions you receive when a production process goes awry for example. You can do it through the UsingTolerance extension method as shown below :\nvar dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); exceptionService.Register\u0026lt;DivideByZeroException\u0026gt;(exception =\u0026gt; { }) .UsingTolerance(9, TimeSpan.FromSeconds(10.0));  Here, the idea is to only receive the 10th exception message.\nSubscribe to the buffering events Can you subscribe to the events which are thown each time an exception is buffered like this :\nvar dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); exceptionService.ExceptionBuffered += (sender, eventArgs) =\u0026gt; Console.WriteLine(\u0026quot;The '{0}' is buffered for at '{1}'.\u0026quot;, eventArgs.BufferedException, eventArgs.DateTime);  Determine if an exception type are registered for handling If you want to know if an exception type have its policy registered on the IExceptionService, you can do this by using the IsExceptionRegistered method like shown below :\nvar dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); if (exceptionService.IsExceptionRegistered\u0026lt;ArgumentNullException\u0026gt;()) { //Do something }  Get a specific exception handler If you want to retrieve the registered exception handler for an exception type, you have to use the GetHandler method like shown below :\nvar dependencyResolver = this.GetDependencyResolver(); var exceptionService = dependencyResolver.Resolve\u0026lt;IExceptionService\u0026gt;(); var exceptionHandler = exceptionService.GetHandler\u0026lt;ArgumentException\u0026gt;();  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/view-models/advanced/exposing-properties-of-model-automatically/","title":"Exposing properties of a model automatically","tags":[],"description":"","content":"See Catel.Fody for more information.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/file-log-listener/","title":"FileLogListener","tags":[],"description":"","content":" Catel also supports very lightweight listeners to allow external logging libraries to hook on. To create a listener, first create a new class that implements the ILogListener interface. Next, register it in the LogManager using the LogManager.AddListener method.\nThe ILogListener has a separate method for each LogEvent, but also has a shared method that is called for each log event. For example, if a debug message is written to the log, both the Write and Debug methods are invoked on the ILogListener.\nFor an example which writes to disk in batches, see the [batch log event listeners](Batch_log_listeners)  Note that Catel already contains a FileLogListener and there is no need to reproduce this class. It only acts as an example that is easy to understand  Specifying the path The default FileLogListener that ships with Catel allows the customization of the file name and the size of the log file. If no size is specified, the max log file size will default to 10 MB. There are several constants inside the file name that can be used:\n{AppData}\nThe application data directory that is used by all users.\nBased on the entry assembly. For example %ProgramData%\\[company]\\[product]\\.\n*Note: Currently this writes to %ProgramData% only if HttpContext.Current evaluates to an object (e.g. a web app); otherwise it uses %AppData%. *\n{AppDataLocal}\nThe local application data directory that is used by the current, non-roaming user.\nBased on the entry assembly. For example %LocalAppData%\\[company]\\product]\\.\n{AppDataRoaming}\nThe roaming application data directory that is used by the current roaming user.\nBased on the entry assembly. For example %AppData%\\[company]\\[product]\\.\n{AppDataMachine}\nThe application data directory that is used by all users.\nBased on the entry assembly. For example %ProgramData%\\[company]\\[product]\\.\n{AppDir}\nThe directory of the current application (i.e. AppDomain.CurrentDomain.BaseDirectory).\n{AssemblyCompany}\nThe assembly company.\n{AssemblyName}\nThe assembly name.\n{AssemblyProduct}\nThe assembly product.\n{AutoLogFileName}\nCreates a log file with the following format: {AssemblyName}_{Date}_{Time}_{ProcessId}.\n{Date}\nThe date as yyyy-MM-dd.\n{Time}\nThe time as HHmmss.\n{ProcessId}\nThe process id.\n{WorkDir}\nThe application execution directory. Calls Directory.GetCurrentDirectory(), internally.\nA good example would be:\nvar fileLogListener = new FileLogListener(); fileLogListener.FilePath = \u0026quot;{AppDir}\\{AutoLogFileName}\u0026quot;; LogManager.AddListener(fileLogListener);  Note that the default path of the *FileLogListener* is *{AppData}\\\\{AutoLogFileName}*  Creating a custom listener A listener can be created by creating a new class deriving from LogListenerBase.\npublic class FileLogListener : LogListenerBase { private readonly TextWriter _textWriter; public FileLogListener(string fileName) { Argument.IsNotNullOrWhitespace(\u0026quot;fileName\u0026quot;, fileName); FileName = fileName; _textWriter = new StreamWriter(fileName, true); } public string FileName { get; private set; } public override void Write(ILog log, string message, LogEvent logEvent) { _textWriter.WriteLine(message); } }  Registering the listener  Last but not least, it is important to register the listener:\nLogManager.AddListener(new FileLogListener(\u0026quot;\u0026lt;log_file_path\u0026gt;\u0026quot;));  "},{"uri":"https://docs.catelproject.com/vnext/tips-tricks/mvvm/finding-view-of-view-model/","title":"Finding the view of a view model","tags":[],"description":"","content":" Sometimes it is required to find the view of a view model. For example, this comes in handy when implementing drag and drop where you only want to support code via view models.\nInternally, Catel uses with the IViewManager for this. As soon as a view is loaded (via the Loaded event), the view is registered to the view manager. The view manager will keep an eye on the events of the view and notice view model changes.\nA view is removed from the manager as soon as it is unloaded (via the Unloaded event). From this moment on, it is no longer possible to retrieve a view via its view model.\nRemember that only view classes implementing *IView* are supported by the *IViewManager*  Retrieving the view of a view model To find the view of a view model, use the steps below:\n1) Resolve the view from IViewManager from the ServiceLocator:\nvar viewManager = ServiceLocator.Default.ResolveType\u0026lt;IViewManager\u0026gt;();  2) Resolve the view:\nvar views = viewManager.GetViewsOfViewModel(myViewModel);  Note that it is possible that multiple views are linked to the same view model\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/focus/","title":"Focus","tags":[],"description":"","content":" To set the focus on a UI element, one must write code in the code-behind. With the Focus behavior, this is no longer necessary. This behavior sets the focus only once on the first time the associated object is loaded.\nAdd the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  Focus when the control is loaded The easiest and default method is to set the focus when the associated control is loaded. In WPF, this is immediately when the control is focused.\n\u0026lt;ListBox ItemsSource=\u0026quot;{Binding PersonCollection}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedPerson}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:Focus /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/ListBox\u0026gt;  Focus when an event occurs It is possible to set the focus when a specific event occurs. For example, when the layout root gets a MouseEnter event, the focus must be set on a specific control. This can be done via the following code:\n\u0026lt;ListBox ItemsSource=\u0026quot;{Binding PersonCollection}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedPerson}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:Focus FocusMoment=\u0026quot;Event\u0026quot; Source=\u0026quot;{Binding ElementName=layoutRoot}\u0026quot; EventName=\u0026quot;MouseEnter\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/ListBox\u0026gt;  Focus when a property changes It is possible to set the focus when a specific property changes. For example, when a value is set, the focus must move on to a new control. This can be done via the following code:\n\u0026lt;ListBox ItemsSource=\u0026quot;{Binding PersonCollection}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedPerson}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:Focus FocusMoment=\u0026quot;PropertyChanged\u0026quot; Source=\u0026quot;{Binding }\u0026quot; PropertyName=\u0026quot;MyProperty\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/ListBox\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/_footer/","title":"footer","tags":[],"description":"","content":""},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xamarin-android/fragments-user-controls/","title":"Fragments (user controls)","tags":[],"description":"","content":" The user controls in Android are called fragments. This means that if a user control must be created, it must derive from the Fragment class. Catel provides a base implementation of this class to ensure full compatibility with the MVVM framework that ships with Catel.\nCreating the view model The view model can be created (or added as a linked file from another project) just like any platform using Catel (they are all equal on all platforms).\nCreating the view Make sure that a Views folder exists in the project so the views and view models can automatically be hooked together by Catel. Then create a new class to the views folder, in this case PersonView:\npublic class PersonView : Catel.Android.App.Fragment { public override View OnCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { var inflateResult = inflater.Inflate(Resource.Layout.Fragment_Person, container, false); return inflateResult; } }  Note that the class derives from `Catel.Android.App.Fragment`  Designing the view To create the actual user interface of the fragment, add a new xaml file to the Resources/layout folder, in your case Fragment\\_Person (but you can name it whatever you want). Then use the following source:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; android:orientation=\u0026quot;vertical\u0026quot; android:layout_width=\u0026quot;fill_parent\u0026quot; android:layout_height=\u0026quot;fill_parent\u0026quot;\u0026gt; \u0026lt;TextView android:text=\u0026quot;First name\u0026quot; android:textAppearance=\u0026quot;?android:attr/textAppearanceMedium\u0026quot; android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/textView1\u0026quot; /\u0026gt; \u0026lt;EditText android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/firstNameText\u0026quot; /\u0026gt; \u0026lt;TextView android:text=\u0026quot;Last name\u0026quot; android:textAppearance=\u0026quot;?android:attr/textAppearanceMedium\u0026quot; android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/textView2\u0026quot; /\u0026gt; \u0026lt;EditText android:layout_width=\u0026quot;match_parent\u0026quot; android:layout_height=\u0026quot;wrap_content\u0026quot; android:id=\u0026quot;@+id/lastNameText\u0026quot; /\u0026gt; \u0026lt;/LinearLayout\u0026gt;  Setting up synchronization In Android it is required to manually synchronize the values between the view and view model. Below is the fully extended PersonView class containing these mapping functionality:\npublic class PersonView : Catel.Android.App.Fragment { public override View OnCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { var inflateResult = inflater.Inflate(Resource.Layout.Fragment_Person, container, false); return inflateResult; } public override void OnActivityCreated(Bundle savedInstanceState) { base.OnActivityCreated(savedInstanceState); // Note: at this stage the visual tree is guaranteed in Android _firstNameEditText = Activity.FindViewById\u0026lt;EditText\u0026gt;(Resource.Id.firstNameText); _lastNameEditText = Activity.FindViewById\u0026lt;EditText\u0026gt;(Resource.Id.lastNameText); } protected override void SyncViewModel() { var vm = GetViewModel\u0026lt;PersonViewModel\u0026gt;(); if (vm == null) { return; } _firstNameEditText.Text = vm.FirstName; _lastNameEditText.Text = vm.LastName; } }  "},{"uri":"https://docs.catelproject.com/vnext/_header/","title":"header","tags":[],"description":"","content":"Catel Documentation\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/hide-until-view-model-loaded/","title":"HideUntilViewModelLoaded","tags":[],"description":"","content":" The HideUntilViewModelLoaded hides (Visibility.Collapsed) any view model container (IViewModelContainer) when it does not have a valid view model. This is a great way to hide lazy-loaded views that should only be visible when they contain an actual view model.\nAdd the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  Focus when the control is loaded The easiest and default method is to focus the first control. The parent is also focused by default (just in case if it doesn\u0026rsquo;t have any focus):\n\u0026lt;local:MyUserControl ...\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:HideUntilViewModelLoaded /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/local:MyUserControl\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/commands-events/hooking-command-to-validation/","title":"Hooking a command to validation automatically","tags":[],"description":"","content":"It is possible to hook the CanExecute of a Command to the IValidationSummary automatically. This way, there is no need to check for errors manually in the CanExecute method. The example below first adds a validation summary to a view model to get the validation result. Then, it uses this validation summary to automatically determine whether a command can be executed.\n1. Add validation to a person view model (note how the validation adds the tag PersonValidation to a validation):\n/// \u0026lt;summary\u0026gt; /// Validates the field values of this object. Override this method to enable /// validation of field values. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results, add additional results to this list.\u0026lt;/param\u0026gt; protected override void ValidateFields(System.Collections.Generic.List\u0026lt;IFieldValidationResult\u0026gt; validationResults) { if (string.IsNullOrEmpty(FirstName)) { validationResults.Add(FieldValidationResult.CreateErrorWithTag(FirstNameProperty, \u0026quot;First name cannot be empty\u0026quot;, \u0026quot;PersonValidation\u0026quot;)); } if (string.IsNullOrEmpty(LastName)) { validationResults.Add(FieldValidationResult.CreateErrorWithTag(LastNameProperty, \u0026quot;Last name cannot be empty\u0026quot;, \u0026quot;PersonValidation\u0026quot;)); } }  2. Add a property to the view model containing the validation summary using the ValidationToViewModel attribute.\n[ValidationToViewModel(Tag = \u0026quot;PersonValidation\u0026quot;)] public IValidationSummary PersonValidationSummary { get; set; }   Define a command on the view model:\n/// \u0026lt;summary\u0026gt; /// Gets the Save command. /// \u0026lt;/summary\u0026gt; public Command Save { get; private set; } /// \u0026lt;summary\u0026gt; /// Method to invoke when the Save command is executed. /// \u0026lt;/summary\u0026gt; private void OnSaveExecute() { // TODO: Handle command logic here }  Create the command that automatically uses the validation summary using the CommandHelper class:\nSave = CommandHelper.CreateCommand(OnSaveExecute, () =\u0026gt; PersonValidationSummary);   With this example, the Save command on the view model can only be executed when there are no errors with the PersonValidation tag.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/improving-performance-by-defining-view-model-grid-manually/","title":"Improving performance by defining the view model grid manually","tags":[],"description":"","content":" Catel wraps the content of each user control in a grid. This grid is the actual view model container as can be read in the advanced documentation. This wrapper is very convenient, but does have (little) impact on the performance and visual state management. To prevent Catel to wrap the control for you, there are a few things you can do.\nCreating the grid manually The easiest way is to create the grid manually. The default implementation of the IViewModelWrapperService checks if the direct child control is a grid and has a specific name __catelInnerWrapper. To prevent Catel from creating the wrapper, simply specify the name on the root grid.\nNote that Catel will override the DataContext binding of this grid to reflect the view model.\nCustomizing the IViewModelWrapperService Another way to prevent Catel from wrapping the grids is to implement the IViewModelWrapperService yourself.\nNote that we recommend to create the grid manually since that is highly likely to have less side-effects\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/ioc/","title":"IoC (ServiceLocator and TypeFactory)","tags":[],"description":"","content":" Before Catel 2.0, the IoC container used internally was Unity. However, this forced all users to use and configure Unity as the IoC container in their apps and required the shipping of the libraries as well. Since Catel 2.0, a different technique is used which allows the end-developer to use the IoC container technique of their choice.\nDifferent components in IoC There are several different components that are very important for the IoC in Catel:\n ServiceLocator Component that is responsible for the registrations of all types. This is the actual IoC container. TypeFactory Component that is responsible to create types. This uses the *IServiceLocator *to retrieve the types which are required to instantiate a type. DependencyResolver Light-weight implementation of the IServiceLocator which does not expose any register methods, but only allows to resolve types.** **  Getting components for any object In every object, it is possible to use the Default properties to retrieve the instances of each component. This will cause problems when different scoping is used. To always be sure to get the right component for the object you are working with, it is recommended to use the following extension methods:\nusing Catel.IoC; // Contains ObjectExtensions which allow use of below extension methods public class MyService { public void SomeMethod() { // If you need to create a type with the current scope type factory var typeFactory = this.GetTypeFactory(); // If you need to register a type with the current scope service locator var serviceLocator = this.GetServiceLocator(); // If you need to resolve a type with the current scope and the type is not injected via dependency injection var dependencyResolver = this.GetDependencyResolver(); } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/serialization/supported-serializers/json/","title":"Json","tags":[],"description":"","content":" The JsonSerializer is implemented in a separate assembly because it uses Json.Net under the hood.\nCustomizing configuration The JsonSerializationConfiguration enables support for customizing the configuration used while (de)serializing. Below is an example\nUsing Bson instead of Json To use Bson instead of Json, use the JsonSerializationConfiguration class:\nvar configuration = new JsonSerializationConfiguration { UseBson = true }; jsonSerializer.Serialize(myObject, configuration);  Specifying the culture to use during (de)serialization To specify the culture to use during (de)serialization, set the Culture property on the configuration class:\nvar configuration = new SerializationConfiguration { Culture = new CultureInfo(\u0026quot;nl-NL\u0026quot;) }; jsonSerializer.Serialize(myObject, configuration);  Preserve references (and support circular references) By default the JsonSerializer supports circular references. It does so by adding additional property values to the json. Below is a json object with support for circular references:\n{ \u0026quot;$graphid\u0026quot;:1, \u0026quot;Name\u0026quot;:\u0026quot;1\u0026quot;, \u0026quot;CircularModel\u0026quot;:{ \u0026quot;$graphid\u0026quot;:2, \u0026quot;Name\u0026quot;:\u0026quot;2\u0026quot;, \u0026quot;CircularModel\u0026quot;:{ \u0026quot;$graphrefid\u0026quot;:1 } } }  or\n{ \u0026quot;$graphid\u0026quot;: 1, \u0026quot;Collection1\u0026quot;: [1, 2, 3, 4, 5], \u0026quot;$Collection1_$graphid\u0026quot;: 2, \u0026quot;Collection2\u0026quot;: [1, 2, 3, 4, 5], \u0026quot;$Collection2_$graphrefid\u0026quot;: 2 }  To disable the support for reference preservation, use the code below:\nvar jsonSerializer = dependencyResolver.Resolve\u0026lt;IJsonSerializer\u0026gt;(); jsonSerializer.PreserveReferences = false;  Support complex dynamic types Catel can support complex dynamic types. For this to be supported in json, the objects need additional type information in order to restore the type info again during deserialization. Below is a json object with the type information stored inside the json:\n{ \u0026quot;$typename\u0026quot;:\u0026quot;Catel.Test.Data.IniFile\u0026quot;, \u0026quot;FileName\u0026quot;:\u0026quot;MyIniFile\u0026quot;, \u0026quot;IniEntryCollection\u0026quot;:[ { \u0026quot;$typename\u0026quot;:\u0026quot;Catel.Test.Data.IniEntry\u0026quot;, \u0026quot;Group\u0026quot;:\u0026quot;Group 0\u0026quot;, \u0026quot;Key\u0026quot;:\u0026quot;Key 0\u0026quot;, \u0026quot;Value\u0026quot;:\u0026quot;Value 0\u0026quot;, \u0026quot;IniEntryType\u0026quot;:0 }, { \u0026quot;$typename\u0026quot;:\u0026quot;Catel.Test.Data.IniEntry\u0026quot;, \u0026quot;Group\u0026quot;:\u0026quot;Group 1\u0026quot;, \u0026quot;Key\u0026quot;:\u0026quot;Key 1\u0026quot;, \u0026quot;Value\u0026quot;:\u0026quot;Value 1\u0026quot;, \u0026quot;IniEntryType\u0026quot;:1 }, { \u0026quot;$typename\u0026quot;:\u0026quot;Catel.Test.Data.IniEntry\u0026quot;, \u0026quot;Group\u0026quot;:\u0026quot;Group 2\u0026quot;, \u0026quot;Key\u0026quot;:\u0026quot;Key 2\u0026quot;, \u0026quot;Value\u0026quot;:\u0026quot;Value 2\u0026quot;, \u0026quot;IniEntryType\u0026quot;:0 } ] }  To disable the type information in json, use the code below:\nvar jsonSerializer = dependencyResolver.Resolve\u0026lt;IJsonSerializer\u0026gt;(); jsonSerializer.WriteTypeInfo = false;  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/view-models/advanced/keeping-view-models-alive/","title":"Keeping view models alive","tags":[],"description":"","content":"In Catel, view models are automatically closed when the UserControl is unloaded from the visual tree. This is because there is no guarantee that the control will be loaded again. This works great in most of the cases, but sometimes you need more control about the lifetime of the view model. One good example is the use of the TabControl. When a tab control contains a user control with a view model, every time a new tab is selected, the controls on the previously selected tab are unloaded (and thus the view models are closed).\nIt is possible to have more control about the lifetime of view models. To keep a view model alive, even when the view is unloaded, set the CloseViewModelOnUnloaded property of the UserControl to false in the constructor of the view:\nCloseViewModelOnUnloaded = false;  The view model will now be re-used when the view is loaded into the visual tree again.\nKeep in mind that the developer is responsible for actually closing the view model  [Orc.Controls](https://github.com/wildgums/orc.controls) contains an implementation of a `TabControl` that gives more control over the lifetime of the tabs  The Catel Examples repository contains an example demonstrating controlling the lifetime of view models  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/key-press-to-command/","title":"KeyPressToCommand","tags":[],"description":"","content":"Sometimes you need to handle a key press and convert it to a command. An excellent example is a ListBox that should respond to an Ctrl + Enter key press.\n1) Add the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  2) Use the following definition:\n\u0026lt;ListBox x:Name=\u0026quot;listBox\u0026quot; ItemsSource=\u0026quot;{Binding PersonCollection}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedPerson}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:KeyPressToCommand Command=\u0026quot;{Binding MyCommand}\u0026quot; Key=\u0026quot;Enter\u0026quot; Modifiers=\u0026quot;Ctrl\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/ListBox\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/location-service/","title":"LocationService","tags":[],"description":"","content":" The ILocationService allows a developer to use GPS devices inside a view model.\nIt is important that the service must be started and stopped to retrieve values  Starting the service The GPS service needs to be started and stopped. To start the GPS service, use the following code:\nvar dependencyResolver = this.GetDependencyResolver(); var locationService = dependencyResolver.Resolve\u0026lt;ILocationService\u0026gt;(); locationService.LocationChanged += OnCurrentLocationChanged; locationService.Start();  The service will raise the LocationChanged event when a new location becomes available.\nStopping the service It is required to stop the service when it is no longer needed. The service can be stopped using the following code:\nvar dependencyResolver = this.GetDependencyResolver(); var locationService = dependencyResolver.Resolve\u0026lt;ILocationService\u0026gt;(); locationService.LocationChanged -= OnCurrentLocationChanged; locationService.Stop();  Emulating GPS without device It is possible to emulate GPS without actually owning a device or emulate data in the emulator. To accomplish this, it is required to use the Catel.MVVM.Services.Test.LocationService class. This class can be used in the following way:\nvar dependencyResolver = this.GetDependencyResolver(); Test.LocationService service = (Test.LocationService)dependencyResolver.Resolve\u0026lt;ILocationService\u0026gt;(); // Queue the next location (and then wait 5 seconds) var locationTestData = new LocationTestData(new Location(100d, 100d), new TimeSpan(0, 0, 0, 5))); service.ExpectedLocations.Add(locationTestData); // Go to the next location manually service.ProceedToNextLocation();  It is also possible to enqueue lots of coordinates with a time span and emulate a path.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/","title":"Locators &amp; naming conventions","tags":[],"description":"","content":" Naming conventions   UrlLocator   ViewLocator   ViewModelLocator   "},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/integration-with-external-loggers/log4net/","title":"Log4net","tags":[],"description":"","content":" The example below provides an ILogListener for Log4net, but any external logging library can be used.\nCreating the listener A listener can be created by creating a new class deriving from LogListenerBase.\npublic class Log4netListener : LogListenerBase { protected override void Debug(ILog log, string message, object extraData) { var finalLog = log4net.LogManager.GetLogger(log.TargetType); finalLog.Debug(message); } protected override void Info(ILog log, string message, object extraData) { var finalLog = log4net.LogManager.GetLogger(log.TargetType); finalLog.Info(message); } protected override void Warning(ILog log, string message, object extraData) { var finalLog = log4net.LogManager.GetLogger(log.TargetType); finalLog.Warn(message); } protected override void Error(ILog log, string message, object extraData) { var finalLog = log4net.LogManager.GetLogger(log.TargetType); finalLog.Error(message); } }  Registering the listener Last but not least, it is important to register the listener:\nLogManager.AddListener(new Log4netListener());  Configuring log4net Note that this is just a sample configuration. Please use the log4net documentation for all options\n Add reference to log4net Add [assembly: log4net.Config.XmlConfigurator(Watch = true)] to AssemblyInfo.cs Configure log4net in your app.config to configure the actual data  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/","title":"Logging","tags":[],"description":"","content":" Starting with version 2.2, Catel uses a custom internal logging system. This way, the reference to log4net could be removed. The idea behind this move is not to force the user to use log4net. Also, log4net seems deprecated (no new releases for a long time), and other logging systems such as NLog seem to grow in popularity.\nThe new logging system only allows very basic logging. This way, the logging is kept very simple and the real logging can be implemented by the end-developer if he/she feels the need for it.\nLog and ILog All logging is available via the ILog interface. This interface is registered automatically on all objects in Catel as Log field. This way, every object can log any information by calling methods on the Log field.\nIn Catel, there is only one implementation of the ILog interface, which is the Log class. This class makes sure that the log messages are formatted correctly and the LogMessage event is invoked when a message is written to the log.\nCatel internally creates a separate log per type. This way, there will be lots of logs and it should be easy to filter the information the end-developer is really interested in.\nLogManager The LogManager is the class where it all comes together. This class is responsible for creating new logs for types, but also keeps track of all logs and log listeners. To retrieve the log for a specific class, use the following code:\nprivate static readonly ILog Log = LogManager.GetCurrentClassLogger();  Logging in code To log in code, the ILog interface implements some basic methods to log information with an option for extra data. There are however lots of extension methods available to log exceptions, string formats and more. Below is an example of logging in code:\nLog.Warning(\u0026quot;Customer '{0}' does not exist\u0026quot;, customerId);  Or, if an exception is available, this can written to the log as well.\nLog.Error(ex, \u0026quot;Failed to delete file '{0}'\u0026quot;, fileName);  Logging in code with additional data Sometimes additional data is required (for example, the thread id, or anything else like this). The logging is extensible and contains on the the bare minimum required for logging. To pass in additional information, use the [Level]WithData methods (such as DebugWithData):\nLog.Debug(\u0026quot;This is a message from a specific thread\u0026quot;, new LogData { { \u0026quot;ThreadId\u0026quot;, threadId } });  Then the log data will be available in the LogData of the LogEntry:\nvar logData = logEntry.LogData; var threadId = logData[\u0026quot;ThreadId\u0026quot;];  Logging to the output window or console By default, Catel does not add any listeners. However, it contains a ready-to-use implementation that writes all logs to the output window or console, which is the DebugLogListener. To register this listener, call this at any time:\n#if DEBUG LogManager.AddDebugListener(); #endif  Overriding global log level flags Start with Catel 3.8, it is possible to override the global log level flags for all listeners. To do this, set the corresponding flag on the LogManager to a value. For example, to force debug logging on all log listeners, use the code below:\nLogManager.IsDebugEnabled = true;  To reset the override, set the value back to null:\nLogManager.IsDebugEnabled = null;  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/view-models/mapping-properties-from-view-to-view-model/","title":"Mapping properties from view to view model","tags":[],"description":"","content":" Sometimes a view (for example, a user control) contains additional properties besides the DataContext to interact with the view model. By default, it is hard to implement this in an MVVM sccenario, but Catel solves this issue using the ViewToViewModel attribute.\nThis attribute automatically keeps track of changes in both the view and the view model and this way, a control can have several properties and still implement MVVM.\nExample implementation The example below shows how the MapCenter is a dependency property on the control. It automatically maps the property to the ViewModel.MapCenter property.\npublic partial class MyControl : UserControl { static MyControl() { typeof(MyControl).AutoDetectViewPropertiesToSubscribe(); } public MyControl() { InitializeComponent(); } [ViewToViewModel(MappingType = ViewToViewModelMappingType.ViewModelToView)] public GeoCoordinate MapCenter { get { return (GeoCoordinate) GetValue(MapCenterProperty); } set { SetValue(MapCenterProperty, value); } } // Using a DependencyProperty as the backing store for MapCenter. This enables animation, styling, binding, etc... public static readonly DependencyProperty MapCenterProperty = DependencyProperty.Register(\u0026quot;MapCenter\u0026quot;, typeof (GeoCoordinate), typeof (MyControl), new PropertyMetadata(null, (sender, e) =\u0026gt; ((MyControl) sender).UpdateMapCenter())); private void UpdateMapCenter() { map.SetView(ViewModel.MapCenter, ViewModel.ZoomLevel); } public new MainPageViewModel ViewModel { get { return base.ViewModel as MainPageViewModel; } } }  Important note starting with Catel 4.0 Starting with 4.0, Catel no longer subscribes to dependency properties automatically. It is best to let Catel only subscribe to the properties that it should (for the best performance). To do so, use the IViewPropertySelector.AddPropertyToSubscribe method to add properties:\nvar serviceLocator = ServiceLocator.Default; var viewPropertySelector = serviceLocator.ResolveType\u0026lt;IViewPropertySelector\u0026gt;(); viewPropertySelector.AddPropertyToSubscribe(\u0026quot;MyProperty\u0026quot;, typeof(MyView));  In most cases, the only reason to subscribe to property changes is because of the ViewToViewModel attribute. If that is the case, it is best to use the extension method AutoDetectViewPropertiesToSubscribe in the static constructor of the view:\nstatic MyView() { typeof(MyView).AutoDetectViewPropertiesToSubscribe(); }  Mapping types Catel supports the following mapping types using the ViewToViewModelMappingType enum.\nType\nDescription\nTwoWayDoNothing\nTwo way, which means that either the view or the view model will update the values of the other party as soon as they are updated.\nWhen this value is used, nothing happens when the view model of the view changes. This way, it might be possible that the values of the view and the view model are different. The first one to update next will update the other.\nTwoWayViewWins\nTwo way, which means that either the view or the view model will update the values of the other party as soon as they are updated.\nWhen this value is used, the value of the view is used when the view model of the view is changed, and is directly transferred to the view model value\nTwoWayViewModelWins\nTwo way, which means that either the view or the view model will update the values of the other party as soon as they are updated.\nWhen this value is used, the value of the view model is used when the view model of the view is changed, and is directly transferred to the view value.\nViewToViewModel\nThe mapping is from the view to the view model only.\nViewModelToView\nThe mapping is from the view model to the view only.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/message-service/","title":"MessageService","tags":[],"description":"","content":" The IMessageService allows a developer to show message boxes from a view model.\nShowing a message To show a message from a view model, use the following code:\nvar dependencyResolver = this.GetDependencyResolver(); var messageService = dependencyResolver.Resolve\u0026lt;IMessageService\u0026gt;(); await messageService.Show(\u0026quot;My first message via the service\u0026quot;);  Showing an error Showing a warning or error is very easy. Use the following code:\nvar dependencyResolver = this.GetDependencyResolver(); var messageService = dependencyResolver.Resolve\u0026lt;IMessageService\u0026gt;(); await messageService.ShowError(\u0026quot;Whoops, something went wrong\u0026quot;);  Requesting confirmation It is also possible to request confirmation from the user. The number of possibilities depends on the target platform (for example, not all platforms support YesNo).\nThe following code must be used to request confirmation:\nvar dependencyResolver = this.GetDependencyResolver(); var messageService = dependencyResolver.Resolve\u0026lt;IMessageService\u0026gt;(); if (await messageService.Show(\u0026quot;Are you sure you want to do this?\u0026quot;, \u0026quot;Are you sure?\u0026quot;, MessageButton.YesNo) == MessageResult.Yes) { // Do it! }  Asynchronous confirmation var dependencyResolver = this.GetDependencyResolver(); var messageService = dependencyResolver.Resolve\u0026lt;IMessageService\u0026gt;(); await messageService.Show(\u0026quot;Are you sure you want to do this?\u0026quot;, \u0026quot;Are you sure?\u0026quot;, MessageButton.YesNo, OnMessageServiceComplete);  There are two possible callbacks, one with a result of type Func\\\u0026lt;MessageResult\\\u0026gt; or one without a result of type Action.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/messaging/","title":"Messaging","tags":[],"description":"","content":" MessageBase   Message mediator   Messaging via attributes   "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/mouse-info/","title":"MouseInfo","tags":[],"description":"","content":"1) Add the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  2) Use the following definition:\n\u0026lt;ListBox ItemsSource=\u0026quot;{Binding PersonCollection}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedPerson}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:MouseInfo x:Name=\u0026quot;personCollectionMouseInfo\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/ListBox\u0026gt;  3) Now, it is easy to bind to the mouse information like this (textblock will become visible when the listbox is hovered):\n\u0026lt;TextBlock Visibility=\u0026quot;{Binding ElementName=personCollectionMouseInfo, Path=IsMouseOver, Converter={StaticResource BooleanToCollapsingVisibilityConverter}, ConverterParameter=false}\u0026quot; Text=\u0026quot;Hovering listbox\u0026quot; /\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/multilingual/","title":"Multilingual / Localization","tags":[],"description":"","content":" Making an application multilingual is a very common feature request nowadays. Therefore Catel provides the resources in several languages and provides the LanguageService to give the developers full control over the translation process in their applications.\nSetting up the LanguageService Setting cultures By default the LanguageService will use the current UI culture to retrieve the right language values. These can easily be customized:\nvar dependencyResolver = this.GetDependencyResolver(); var languageService = dependencyResolver.Resolve\u0026lt;ILanguageService\u0026gt;(); languageService.PreferredCulture = new CultureInfo(\u0026quot;nl-NL\u0026quot;); languageService.FallbackCulture = new CultureInfo(\u0026quot;en-US\u0026quot;);  Registering custom language sources In order to customize the language sources, custom language sources can be registered via the *RegisterLanguageSource* method.\nThe code below shows how to add a new *LanguageResourceSource* which represents a resource file in a specific assembly:\nvar dependencyResolver = this.GetDependencyResolver(); var languageService = dependencyResolver.Resolve\u0026lt;ILanguageService\u0026gt;(); // Create source for assembly MyApplication where the Resources.resx is located in the Properties folder var resourcesSource = new LanguageResourceSource(\u0026quot;MyApplication\u0026quot;, \u0026quot;MyApplication.Properties\u0026quot;, \u0026quot;Resources\u0026quot;); languageService.RegisterLanguageSource(resourcesSource ); // Create source for assembly MyApplication where the Exceptions.resx is located in the Properties folder var exceptionsSource = new LanguageResourceSource(\u0026quot;MyApplication\u0026quot;, \u0026quot;MyApplication.Properties\u0026quot;, \u0026quot;Exceptions\u0026quot;); languageService.RegisterLanguageSource(exceptionsSource );  The *LanguageService* will now automatically query these sources for the translations.\nUsing the LanguageService To use the LanguageService, retrieve it via the DependencyResolver (or let it be injected) and use the provided methods. The example below retrieves the *WarningTitle *resource string in the PreferredCulture. If the resource cannot be found in the PreferredCulture, it will be retrieved for the FallbackCulture. If that cannot be found, it will return null.\nvar dependencyResolver = this.GetDependencyResolver(); var languageService = dependencyResolver.Resolve\u0026lt;ILanguageService\u0026gt;(); var warningTitle = languageService.GetString(\u0026quot;WarningTitle\u0026quot;);  Using the LanguageService in XAML To use the *LanguageService *in XAML, Catel provides the markup extensions.\nUsing the LanguageBinding in To use the LanguageBinding markup extension, use the following code:\n\u0026lt;TextBlock Text=\u0026quot;{markup:LanguageBinding WarningTitle}\u0026quot; /\u0026gt;  Using the LanguageBinding in Windows Phone Since Windows Phone does not support markup extensions, a custom MarkupExtension implementation is used in Catel. This requires a little difference in the usage of the markup extension:\n\u0026lt;TextBlock Text=\u0026quot;{markup:LanguageBinding ResourceName=WarningTitle}\u0026quot; /\u0026gt;  Implementing custom LanguageService (from database) Implementing a custom LanguageService consists of several steps which are described below.\nNote that this implementation queries the database for each translation. It is best to read all translations into memory at once to improve performance  Creating a custom ILanguageSource implementation First of all, we need to implement a customized language source to allow the custom service to know what source to read for translations:\npublic class DbLanguageSource : ILanguageSource { public DbLanguageSource(string connectionString) { Argument.IsNotNullOrWhitespace(() =\u0026gt; connectionString); ConnectionString = connectionString; } public string ConnectionString { get; private set; } public string GetSource() { return ConnectionString; } }  Creating a custom DbLanguageService Below is a custom implementation of the LanguageService. Note that we only have to derive a single method to fully customize the implementation:\npublic class DbLanguageService : LanguageService { protected override string GetString(ILanguageSource languageSource, string resourceName, CultureInfo cultureInfo) { var connectionString = languageSource.GetSource(); using (var dbConnection = new SqlConnection(connectionString)) { dbConnection.Open(); var sqlCommand = dbConnection.CreateCommand(); sqlCommand.CommandType = CommandType.Text; sqlCommand.CommandText = @\u0026quot;SELECT [Name] FROM [Translations] WHERE [ResourceName] = @ResourceName AND [CultureName] = @CultureName\u0026quot;; sqlCommand.Parameters.Add(new SqlParameter(\u0026quot;ResourceName\u0026quot;, resourceName)); sqlCommand.Parameters.Add(new SqlParameter(\u0026quot;CultureName\u0026quot;, cultureInfo.ThreeLetterISOLanguageName)); var translation = sqlCommand.ExecuteScalar() as string; if (!string.IsNullOrWhiteSpace(translation)) { return translation; } } // Resource not found, fall back to base if you like, or simply return null return base.GetString(languageSource, resourceName, cultureInfo); } }  Enabling the custom DbLanguageService To enable the custom DbLanguageService, it must be registered in the ServiceLocator:\nvar serviceLocator = ServiceLocator.Default; var dbLanguageService = new DbLanguageService(); var dbLanguageSource = new DbLanguageSource(\u0026quot;myConnectionString\u0026quot;); dbLanguageService.RegisterLanguageSource(dbLanguageSource); serviceLocator.RegisterInstance\u0026lt;ILanguageService\u0026gt;(dbLanguageService);  "},{"uri":"https://docs.catelproject.com/vnext/tips-tricks/mvvm/","title":"MVVM","tags":[],"description":"","content":" Finding the view of a view model   Requery commands automatically using CommandManager   Using a tabbed interface with MVVM   Using compiled bindings   "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/naming-conventions/","title":"Naming conventions","tags":[],"description":"","content":" Some services in Catel support naming conventions. For example, the IViewLocator and IViewModelLocator allow naming conventions to prevent a user from having to register all views and view models. Internally, the naming conventions are resolved using the NamingConvention helper class. This part of the documentation explains the possible constants in naming conventions.\n[AS] constant The [AS] constant will be replaced by the assembly name. For example, the following naming convention:\n[AS].Views  in assembly Catel.Examples will be resolved as:\nCatel.Examples.Views  [VM] constant The [VM] constant will be replaced by the name of the view model without the ViewModel postfix. For example, the following naming convention:\n[AS].ViewModels.[VW]ViewModel  in assembly Catel.Examples and for type Catel.Examples.ViewModels.MyViewModel will be resolved as:\nCatel.Examples.ViewModels.MyViewModel  [VW] constant The [VW] constant will be replaced by the name of the view without the View, Control, Page or Window postfixes. For example, the following naming convention:\n[AS].Views.[VM]View  in assembly Catel.Examples and for type Catel.Examples.Views.MyView will be resolved as:\nCatel.Examples.Views.MyView  [UP] constant Sometimes it is not possible to use the [AS] constant because the assembly name is not used in the namespace. For example, for an application called PersonApplication where the client assembly is PersonApplication.Client, the root namespace will still be PersonApplication. Therefore, it is recommend to use the [UP] constant for this situation.\nThe [UP] constant will move the namespaces up by one step. It automatically detects the right separator (\\ (backslash), / (slash), . (dot) and | (pipe) are supported).\nThe following naming convention:\n[UP].Views.[VM]View  for type Catel.Examples.ViewModels.MyViewModel will be resolved as:\nCatel.Examples.Views.MyView  [CURRENT] constant Some people prefer to put classes into the same namespace (such as views and view models).\nThe [CURRENT] constant will use the same namespace.\nThe following naming convention:\n[CURRENT].[VM]View  for type *Catel.Examples.MyViewModel* will be resolved as:\nCatel.Examples.MyView  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/navigate/","title":"Navigate","tags":[],"description":"","content":"Note that this behavior is only available for WPF  The Hyperlink control in WPF is very powerful, but it is hard to make them work outside pages.\nAdd the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  To execute the NavigateUrl, simply use the behavior as shown below:\n\u0026lt;TextBlock\u0026gt; \u0026lt;Hyperlink NavigateUri=\u0026quot;http://schemas.catelproject.com\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:Navigate /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;TextBlock Text=\u0026quot;The best MVVM Framework\u0026quot; /\u0026gt; \u0026lt;/Hyperlink\u0026gt; \u0026lt;/TextBlock\u0026gt;  Another alternative is to use the `LinkLabel` control from [Orc.Controls](https://github.com/wildgums/orc.controls)  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/navigation-service/","title":"NavigationService","tags":[],"description":"","content":" The INavigationService allows a developer to navigate to other pages inside an application using view models only.\nAll pages will have to be registered manually or following the right naming convention.\nThe `NavigationService` uses the `IViewLocator` and `IViewModelLocator` do handle the navigation. See the [Naming conventions](/vnext/catel-mvvm/locators-naming-conventions/) section for more details.  Closing an application It is possible to close an application using the following code:\nvar dependencyResolver = this.GetDependencyResolver(); var navigationService = dependencyResolver.Resolve\u0026lt;INavigationService\u0026gt;(); navigationService.CloseApplication();  Preventing an application to be closed To prevent an application to be closed, one can subscribe to the ApplicationClosing event:\nvar dependencyResolver = this.GetDependencyResolver(); var navigationService = dependencyResolver.Resolve\u0026lt;INavigationService\u0026gt;(); navigationService.ApplicationClosing += (sender, e) =\u0026gt; { e.Cancel = true; };  Navigating to a new view To navigate to a new page, use the following code:\nvar dependencyResolver = this.GetDependencyResolver(); var navigationService = dependencyResolver.Resolve\u0026lt;INavigationService\u0026gt;(); navigationService.Navigate\u0026lt;EmployeeViewModel\u0026gt;();  Navigating with parameters It is very easy to navigate to a new page with parameters. Use the following code:\nvar parameters = new Dictionary\u0026lt;string, object\u0026gt;(); parameters.Add(\u0026quot;id\u0026quot;, employee.EmployeeID); var dependencyResolver = this.GetDependencyResolver(); var navigationService = dependencyResolver.Resolve\u0026lt;INavigationService\u0026gt;(); navigationService.Navigate\u0026lt;EmployeeViewModel\u0026gt;(parameters);  To read the navigation parameters in the receiving view model, use the OnNavigationCompleted method.\nNavigating back and forward The service also supports navigating back and forward:\nvar dependencyResolver = this.GetDependencyResolver(); var navigationService = dependencyResolver.Resolve\u0026lt;INavigationService\u0026gt;(); navigationService.GoBack(); // navigates to the previous page, obviously navigationService.GoForward(); // navigates to the next page, obviously  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/view-models/nested-view-models/","title":"Nested view models","tags":[],"description":"","content":"For more information on this topic, see nested user controls.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/integration-with-external-loggers/nlog/","title":"NLog","tags":[],"description":"","content":" NLog The example below provides an ILogListener for NLog, but any external logging library can be used.\nCreating the listener A listener can be created by creating a new class deriving from LogListenerBase.\npublic class NLogListener : LogListenerBase { protected override void Debug(ILog log, string message, object extraData) { var finalLog = NLog.LogManager.GetLogger(log.TargetType.ToString()); finalLog.Debug(message); } protected override void Info(ILog log, string message, object extraData) { var finalLog = NLog.LogManager.GetLogger(log.TargetType.ToString()); finalLog.Info(message); } protected override void Warning(ILog log, string message, object extraData) { var finalLog = NLog.LogManager.GetLogger(log.TargetType.ToString()); finalLog.Warn(message); } protected override void Error(ILog log, string message, object extraData) { var finalLog = NLog.LogManager.GetLogger(log.TargetType.ToString()); finalLog.Error(message); } }  Registering the listener Last but not least, it is important to register the listener:\nLogManager.AddListener(new NLogListener());  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/numeric-textbox/","title":"NumericTextBox","tags":[],"description":"","content":"The NumericTextBox behavior makes it easy to allow specific numeric input on a TextBox.\n1) Add the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  2) Use the following definition:\n\u0026lt;TextBox Text={Binding Amount}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:NumericTextBox /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/TextBox\u0026gt;  Use the properties on the behavior to customize the behavior to your needs  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/open-file-service/","title":"OpenFileService","tags":[],"description":"","content":" The IOpenFileService allows a developer to let the user choose a file from inside a view model.\nOpening a file To open a file, it is required to set the right properties of the service and then make a call to the DetermineFile method:\nvar dependencyResolver = this.GetDependencyResolver(); var openFileService = dependencyResolver.Resolve\u0026lt;IOpenFileService\u0026gt;(); openFileService.Filter = \u0026quot;All files|*.*\u0026quot;; if (openFileService.DetermineFile()) { // User selected a file }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/parallel-invocation-tasks/","title":"Parallel invocation and tasks","tags":[],"description":"","content":" This page contains helper classes in Catel to invoke specific actions on very large collections in parallel.\nRunning batches on large sets in parallel When handling a lot of items and invoking a method per item, it might be a viable option to execute the actions in batches. This normally requires quite some code to split up the large collection into batches and execute the method for each item. To make this process much easier, Catel introduces the ParallelHelper class.\nTo invoke an Initialize method on all types currently loaded by Catel, in batches of 2500 types per batch, use the following code:\nvar allTypes = new List\u0026lt;Type\u0026gt;(TypeCache.GetTypes()); ParallelHelper.ExecuteInParallel(allTypes, type =\u0026gt; { SomeInitializeTypeMethod(type); }, 2500, \u0026quot;Initialize types\u0026quot;);  It is really easy to tweak the number of items per batch to find the optimal performance of items per batch.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/please-wait-service/","title":"PleaseWaitService","tags":[],"description":"","content":" The IPleaseWaitService allows a developer to show a please wait message (a.k.a. busy indicator) from a view model. Showing using Catel.IoC;  var dependencyResolver = this.GetDependencyResolver(); var pleaseWaitService = dependencyResolver.Resolve\u0026lt;IPleaseWaitService\u0026gt;(); pleaseWaitService.Show();  Hiding var dependencyResolver = this.GetDependencyResolver(); var pleaseWaitService = dependencyResolver.Resolve\u0026lt;IPleaseWaitService\u0026gt;(); pleaseWaitService.Hide();  Showing and automatically hide The IPleaseWaitService can automatically hide itself when an action is completed. To use this feature, simply pass a delegate to the Show method and the service will hide the window as soon as the delegate has completed.\nusing Catel.IoC;  var dependencyResolver = this.GetDependencyResolver(); var pleaseWaitService = dependencyResolver.Resolve\u0026lt;IPleaseWaitService\u0026gt;(); pleaseWaitService.Show(() =\u0026gt; Thread.Sleep(1500));  Changing the status var dependencyResolver = this.GetDependencyResolver(); var pleaseWaitService = dependencyResolver.Resolve\u0026lt;IPleaseWaitService\u0026gt;(); pleaseWaitService.UpdateStatus(\u0026quot;new status\u0026quot;);  Showing a determinate please wait window By default, the IPleaseWaitService shows an indeterminate state (no actual progress is visible).\nThe UpdateStatus method can be used to show the window. The statusFormat argument can contain \u0026lsquo;{0}\u0026rsquo; (represents the current item) and \u0026lsquo;{1}\u0026rsquo; (represents the total items). However, they can also be left out.\nvar dependencyResolver = this.GetDependencyResolver(); var pleaseWaitService = dependencyResolver.Resolve\u0026lt;IPleaseWaitService\u0026gt;(); pleaseWaitService.UpdateStatus(1, 5, \u0026quot;Updating item {0} of {1}\u0026quot;);  The determinate version can be hidden via a call to Hide or when the currentItem argument is larger than the number of totalItems.\nPush/Pop Sometimes, multiple view models or multiple actions use the service. It\u0026rsquo;s not possible to hide the window when the first action is completed, because the user will still have to wait for the other actions to complete (without a please wait window). To implement this correctly, it is possible to use the Push and Pop methods.\nThe Push method shows the window if it is not already visible and then increases an internal counter. At the start of each (asynchronous) action, the developer can call the Push method. When the action is completed, the developer calls Pop which will internally decrease the counter. If the counter hits zero (0), the window is automatically hidden.\nIt is possible to hide the window, even when the internal counter is not yet zero. A call to Hide will reset the counter to zero and thus hide the window.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-core/pooling/","title":"Pooling","tags":[],"description":"","content":" Garbage collection in .NET can be very expensive, especially for objects on the Large Object Heap (LOH). .NET itself already uses pooling for threads to prevent the costly creation of threads but instead re-uses the already created threads using a thread pool. Catel provides an implementation of pooling using the PoolManager\u0026lt;TPoolable\u0026gt;. This allows both Catel and third party developers to create a pool for large objects so they can be reused.\nThe documentation uses a byte array of 4096 as poolable object as example. If `_poolManager` is used in the code below, it represents an instance of `PoolManager`  Introduction to the pool manager The pool manager internally uses a stack to manage the available objects in the pool. It\u0026rsquo;s important to understand how a pool works. The flow diagram below shows how the pool manager deals with objects:\nIt is recommended that a pool manager gets registered in the ServiceLocator so it can be re-used by multiple components.\nNote that the pool manager does not limit the number of objects in memory. It has a `MaxSize` property so it will store only a maximum amount of objects inside the internal pool, but if the pool is running out of instances and a new object is requested, it will return a new instance (and thus creating a new object which could be garbage collected).  Retrieving objects from the pool Retrieving an object from the pool is very simple. When an instance of the PoolManager\u0026lt;TPoolable\u0026gt; is available, use the code below:\nvar poolableBuffer = _poolManager.GetObject();  The PoolManager\u0026lt;TPoolable\u0026gt; will automatically create a new object when no objects are available in the pool.\nReturning objects to the pool Objects should be automatically returned to the pool when the objects are disposed. This means the objects are not really disposed but the state is being reset and the object is being returned to the pool. To automatically take care of this, it\u0026rsquo;s best to use the PoolManager\u0026lt;TPoolable\u0026gt; as shown below:\nusing (var poolableBuffer = _poolManager.GetObject()) { var buffer = poolableBuffer.Data; // work with the buffer here } // outside the scope, the object is automatically disposed and returned to the pool  The flow chart below shows how the PoolManager\u0026lt;TPoolable\u0026gt; will handle the dispose:\nCustomizing a pool manager Catel implements pooling via the PoolManager\u0026lt;TPoolable\u0026gt; class. This class allows the caller to retrieve an object. There is no need to explicitly derive a class from the PoolManager\u0026lt;TPoolable\u0026gt;. It can be customized though.\nCustomizing the maximum size By default, the PoolManager\u0026lt;TPoolable\u0026gt; uses a maximum size of 5 MB per poolable type. If, for this example, the maximum size of byte buffers should be 1 MB, use the code below:\nvar poolManager = new PoolManager\u0026lt;Buffer4096Poolable\u0026gt;(); poolManager.MaxSize = 1024 * 1024 * 1;  If the MaxSize is reached, objects will not be added back to the internal pool but be left out and, if no other references exist to this object, be ready for garbage collection.\nCreating a poolable object Since the objects need to be re-used, it\u0026rsquo;s very important that the PoolManager\u0026lt;TPoolable\u0026gt; knows how to reset objects to the initial state. Therefore every poolable object needs to implement IPoolable which also implements IDisposable. Below is an example implementation of a poolable object.\npublic class Buffer4096Poolable : IPoolable { private const int BufferSize = 4096; protected IPoolManager _poolManager; public Buffer4096Poolable() { Data = new byte[BufferSize]; } public byte[] Data { get; private set; } public int Size { get { return BufferSize; } } public void Reset() { var buffer = Data; Array.Clear(buffer, 0, buffer.Length); } // Implemented explicitly so it can't be called accidentally void IPoolable.SetPoolManager(IPoolManager poolManager) { _poolManager = poolManager; } public void Dispose() { _poolManager.ReturnObject(this); } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/preventing-memory-leaks/","title":"Preventing memory leaks","tags":[],"description":"","content":" Change notification wrapper   Weak events   "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/process-service/","title":"ProcessService","tags":[],"description":"","content":" The IProcessService allows a developer to run processes from inside a view model.\nStarting a process with arguments To start a process with arguments, use the following code:\nvar dependencyResolver = this.GetDependencyResolver(); var processService = dependencyResolver.Resolve\u0026lt;IProcessService\u0026gt;(); processService.StartProcess(\u0026quot;notepad.exe\u0026quot;, @\u0026quot;C:\\mytextfile.txt\u0026quot;);  Starting a process with arguments and completed callback To start a process with arguments and receive a callback on completion, use the following code:\nvar dependencyResolver = this.GetDependencyResolver(); var processService = dependencyResolver.Resolve\u0026lt;IProcessService\u0026gt;(); processService.StartProcess(\u0026quot;notepad.exe\u0026quot;, @\u0026quot;C:\\mytextfile.txt\u0026quot;, OnProcessCompleted);  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/bindings/property-bindings/","title":"Property bindings","tags":[],"description":"","content":" Property bindings are very important in the MVVM pattern. The binding system in Catel will automatically map properties when the binding system is used.\nBinding properties one way To bind properties one way, use the code below.\nAndroid protected override void AddBindings(BindingContext bindingContext, IViewModel viewModel) { var vm = (MainViewModel) viewModel; bindingContext.AddBinding(() =\u0026gt; vm.FirstName, () =\u0026gt; _firstNameEditText.Text, BindingMode.OneWay); }  iOS iOS not yet documented  Binding properties two way To bind properties two way, use the code below.\nAndroid protected override void AddBindings(BindingContext bindingContext, IViewModel viewModel) { var vm = (MainViewModel) viewModel; bindingContext.AddBinding(() =\u0026gt; vm.FirstName, () =\u0026gt; _firstNameEditText.Text).AddTargetEvent(\u0026quot;TextChanged\u0026quot;); }  Note that you need to use the AddTargetEvent to allow two way binding in Android\niOS iOS not yet documented  Binding properties with a converter Converters are a well-known topic in MVVM. Catel supports the use of converters in the binding system. The example below will convert an integer (vm.Counter) to a string with a format to \u0026rdquo;{0} clicks!\u0026rdquo;. The converter will automatically be instantiated using the TypeFactory. Note that using converters in Catel support both TwoWay bindings and ConverterHelper.UnsetValue to prevent any changes in the binding system.\nAndroid protected override void AddBindings(BindingContext bindingContext, IViewModel viewModel) { var vm = (MainViewModel) viewModel; bindingContext.AddBindingWithConverter\u0026lt;ClicksConverter\u0026gt;(() =\u0026gt; vm.Counter, () =\u0026gt; _testButton.Text, BindingMode.OneWay); }  iOS iOS not yet documented  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/reflection/","title":"Reflection","tags":[],"description":"","content":" Internally, Catel uses reflection to implement some of its behavior. And why not make all these excellent reflection classes public?\nGetting types without versioning Sometimes you know what type to get and what assembly it is living in. However, you don\u0026rsquo;t want to be version-dependent by specifying the fully qualified assembly name. Using the TypeHelper.GetType method, it is possible to get a type by only the assembly name (say Catel.Core) and the type name (say Catel.Data.ObservableObject).\nvar type = PropertyHelper.GetType(\u0026quot;Catel.Data.ObservableObject\u0026quot;, \u0026quot;Catel.Core\u0026quot;);  Setting or getting properties of objects In lots of cases, you need to possibility to set or get properties of an object via reflection. This behavior is implemented in the PropertyHelper class. Below are a few examples.\nCheck if a property is available on an object PropertyHelper.IsPropertyAvailable(person, \u0026quot;FirstName\u0026quot;);  Getting a property value PropertyHelper.GetValue(person, \u0026quot;FirstName\u0026quot;);  or\nstring firstName; PropertyHelper.TryGetValue(person, \u0026quot;FirstName\u0026quot;, out firstName);  Setting a property value PropertyHelper.SetValue(person, \u0026quot;FirstName\u0026quot;, \u0026quot;Geert\u0026quot;);  or\nPropertyHelper.TrySetValue(person, \u0026quot;FirstName\u0026quot;, \u0026quot;Geert\u0026quot;);  "},{"uri":"https://docs.catelproject.com/vnext/tips-tricks/mvvm/requery-commands-automatically/","title":"Requery commands automatically using CommandManager","tags":[],"description":"","content":"For performance reasons, Catel no longer automatically subscribes to the CommandManager to invalidate the state (saves a lot of CanExecute calls). If you want this behavior back, you can create a custom class that subscribes to the command manager and invalidates the commands for you.\nThis was removed for a reason (performance), so this is not the recommended approach. But this allows you to get back the old behavior.  To use this class, instantiate it and register it in the ServiceLocator so it stays alive.\npublic class RequeryUsingCommandManager { private IViewModelManager _viewModelManager; public RequeryUsingCommandManager(IViewModelManager viewModelManager) { Argument.IsNotNull(() =\u0026gt; viewModelManager); _viewModelManager = viewModelManager; System.Windows.Input.CommandManager.RequerySuggested += OnCommandManagerRequerySuggested; } private void OnCommandManagerRequerySuggested(object sender, SomeEventArgs e) { InvalidateCommands(); } private void InvalidateCommands() { var viewModels = _viewModelManager.ActiveViewModels; foreach (var viewModel in viewModels) { var viewModelBase = viewModel as ViewModelBase; if (viewModelBase != null) { var viewModelCommandManager = viewModelBase.GetViewModelCommandManager(); viewModelCommandManager.InvalidateCommands(); } } } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/rolling-in-memory-log-listener/","title":"RollingInMemoryLogListener","tags":[],"description":"","content":" In memory logging can be very useful to be able to query the latest log messages. Catel provides this via the RollingInMemoryLogListener and RollingInMemoryLogService. The *RollingInMemoryLogService *is a wrapper around the *RollingInMemoryLogListener* to provide a simple way to use the listener.\nEnabling the feature By default, the feature is disabled to not eat any CPU ticks when not being used. To use the feature, the only thing required is to resolve the type from the ServiceLocator:\nvar rollingInMemoryLogService = ServiceLocator.Default.ResolveType\u0026lt;IRollingInMemoryLogService\u0026gt;();  Querying log messages To query the latest log messages, use one of the following methods:\n GetLogEntries GetWarningLogEntries GetErrorLogEntries  Customizing number of items to keep in memory To customize the number of items being kept in memory, use one of the following properties:\n MaximumNumberOfLogEntries MaximumNumberOfWarningLogEntries MaximumNumberOfErrorLogEntries  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/designers/running-code-at-design-time/","title":"Running code at design-time","tags":[],"description":"","content":" Sometimes one needs to run code during design-time. A good example is to register a custom LanguageResourceSource in the LanguageService to show translations in the designer. Unfortunately it is not as easy as putting some code in the code-behind to get this working.\nStarting with Catel 4.3, calling `CatelEnvironment.IsInDesignTime` will automatically invoke *DesignTimeHelper.InitializeDesignTime* if in design mode. This means you only have to add classes deriving from `DesignTimeInitializer` and they will automatically be invoked when any code is checking if it's currently running inside a designer context (e.g. `LanguageBinding`)  Introducing the DesignTimeCode attribute To allow users to run code in the designer (Visual Studio or Blend), Catel introduces the DesignTimeCodeAttribute. This is an assembly-wide attribute which will specify the class to create at design time. This means that it is possible to create multiple attributes. Below is an example of the usage of the attribute:\n[assembly: DesignTimeCode(typeof(WpfApplication.Catel.DesignTimeLanguageService))] [assembly: DesignTimeCode(typeof(WpfApplication.Catel.DesignTimeServiceLocator))]  When the attribute is found by Catel, it will automatically construct the types specified in the attribute. This will allow the constructor to execute any code during design time.\nIntroducing the DesignTimeInitializer The DesignTimeCodeAttribute contains the types that are constructed during design-time. Although the reflection in Catel is protected by only checking these arguments at design-time, it cannot be guaranteed for other systems. Therefore Catel also provides the DesignTimeInitializer base class. This is a base class that checks whether the type being constructed is actually running inside a design tool.\nBelow is an example of the usage, which registers custom language resource sources in the language service. This allows real-time updates of the LanguageService in the designer.\npublic class DesignTimeLanguageService : Catel.DesignTimeInitializer { protected override void Initialize() { var dependencyResolver = this.GetDependencyResolver(); var languageService = dependencyResolver.Resolve\u0026lt;ILanguageService\u0026gt;(); languageService.CacheResults = false; var resourcesSource = new LanguageResourceSource(\u0026quot;WpfApplication.Catel\u0026quot;, \u0026quot;WpfApplication.Catel.Properties\u0026quot;, \u0026quot;Resources\u0026quot;); languageService.RegisterLanguageSource(resourcesSource); } }  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/save-file-service/","title":"SaveFileService","tags":[],"description":"","content":" The ISaveFileService allows a developer to let the user choose a file from inside a view model.\nChoosing a file To select a file to save, it is required to set the right properties of the service and then make a call to the DetermineFile method:\nvar dependencyResolver = this.GetDependencyResolver(); var saveFileService = dependencyResolver.Resolve\u0026lt;ISaveFileService\u0026gt;(); saveFileService.Filter = \u0026quot;C# File|*.cs\u0026quot;; if (saveFileService.DetermineFile()) { // User selected a file }  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/scheduler-service/","title":"SchedulerService","tags":[],"description":"","content":" The ISchedulerService allows a developer to schedule an action in the relative or absolute future. The SchedulerService will use the DispatcherTimer to invoke the action.\nNote that the `SchedulerService` does not provide any persistence of actions and schedules. When the application is closed, all schedules are lost because they are kept in memory.  Scheduling an action in the relative future To schedule an action in the relative future, use the Schedule method with the TimeSpan overload. The code below starts the action with a delay of 50 milliseconds.\nvar dependencyResolver = this.GetDependencyResolver(); var schedulerService = dependencyResolver.Resolve\u0026lt;ISchedulerService\u0026gt;(); schedulerService.Schedule(() =\u0026gt; DoSomething(), new TimeSpan(0, 0, 0, 0, 50));  Scheduling an action in the absolute future To schedule an action in the absolute future, use the Schedule method with the DateTime overload. The code below starts the action in 5 minutes.\nvar dependencyResolver = this.GetDependencyResolver(); var schedulerService = dependencyResolver.Resolve\u0026lt;ISchedulerService\u0026gt;(); schedulerService.Schedule(() =\u0026gt; DoSomething(), DateTime.Now.AddMinutes(5));  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/scoping/","title":"Scoping","tags":[],"description":"","content":"Sometimes scoping is important to share an object inside a specific scope which cannot be determined upfront. A great example is the serialization inside Catel which requires a serialization scope which can be shared over a lot of objects. Scoping in Catel is really easy. To create a scope of an object with a specific tag, use the code below:\nusing (var scopeManager = ScopeManager\u0026lt;object\u0026gt;.GetScopeManager(\u0026quot;object\u0026quot;)) { var scopeObject = scopeManager.ScopeObject; // scope can be used here }  When the scope does not yet exist, it will be created and the object will be created by the TypeFactory.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/select-directory-service/","title":"SelectDirectoryService","tags":[],"description":"","content":" The ISelectDirectoryService allows a developer to let the user choose a directory from inside a view model.\nSelecting a directory To select a directory, it is required to set the right properties of the service and then make a call to the DetermineDirectory method:\nvar dependencyResolver = this.GetDependencyResolver(); var selectDirectoryService = dependencyResolver.Resolve\u0026lt;ISelectDirectoryService\u0026gt;(); if (selectDirectoryService.DetermineDirectory()) { // User selected a directory }  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/select-text-on-focus/","title":"SelectTextOnFocus","tags":[],"description":"","content":"The SelectTextOnFocus behavior makes it easy to select all text when a TextBox receives the focus.\n1) Add the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  2) Use the following definition:\n\u0026lt;TextBox Text={Binding Amount}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:SelectTextOnFocus /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/TextBox\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/seq-log-listener/","title":"SeqLogListener","tags":[],"description":"","content":"Seq is a structured logs server for .NET Apps. It act like a logs repository, allow to diagnostic by query your logs using a natural syntax, react on notifying you through email or instant messages and so on \u0026hellip;\nTo use the Seq log listener, use the following code:\nvar logListener = new SeqLogListener(); logListener.IgnoreCatelLogging = true; // TODO: Customize options LogManager.AddListener(logListener);  This one can also be used on configuration file:\n\u0026lt;catel\u0026gt; \u0026lt;logging\u0026gt; \u0026lt;listeners\u0026gt; \u0026lt;listener type=\u0026quot;Catel.Logging.SeqLogListener\u0026quot; ServerUrl=\u0026quot;http://localhost:5341\u0026quot; IgnoreCatelLogging=\u0026quot;true\u0026quot; IsDebugEnabled=\u0026quot;false\u0026quot; IsInfoEnabled=\u0026quot;true\u0026quot; IsWarningEnabled=\u0026quot;true\u0026quot; IsErrorEnabled=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;/listeners\u0026gt; \u0026lt;/logging\u0026gt; \u0026lt;/catel\u0026gt;  This log listener is currently available only for the full .net framework  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/serialization/","title":"Serialization","tags":[],"description":"","content":" Serializing a model The code below shows how to save an object (which can, of course, be a complex graph of nested objects):\nvar myObject = new MyObject(); using (var fileStream = File.Create(@\u0026quot;C:\\myobject.dob\u0026quot;)) { myObject.Save(fileStream); }  Looks too easy, but this really is the only thing you need to do. You can specify the serialization mode in the several available overloads of the Save method.\nLoading is as easy as saving, as you can see in the following code:\nMyObject myObject = null; using (var fileStream = File.Open(@\u0026quot;C:\\myobject.dob\u0026quot;, FileMode.Open)) { myObject = ModelBase.Load\u0026lt;MyObject\u0026gt;(fileStream, SerializationMode.Xml); }  Note that for a model to support the `Save` and `Load` methods, it must derive from `SavableModelBase`  Warming up serialization The first time a serializer needs to serialize an object, it needs to perform some reflection to gather all the required information. This can have a negative impact on performance for the end-user during serialization. This load cannot be prevented, but it is possible to warmup the serializer at any time when it is convenient (for example, during startup of the application).\nWarming up specific types This code will warm up all the specified types:\nvar typesToWarmup = new type[] { typeof(Settings) }; var xmlSerializer = SerializationFactory.GetXmlSerializer(); xmlSerializer.Warmup(typesToWarmup); var binarySerializer = SerializationFactory.GetBinarySerializer(); binarySerializer.Warmup(typesToWarmup);  Warming up automatically This code will warm up all types implementing the *ModelBase *class:\nvar xmlSerializer = SerializationFactory.GetXmlSerializer(); xmlSerializer.Warmup(); var binarySerializer = SerializationFactory.GetBinarySerializer(); binarySerialzier.Warmup();  Note that warming up for all types **might** take a serious amount of time and **might** increase the memory footprint of your application depending on the number of models  Warming up using multiple threads By default, Catel will optimize the initialization and dispatch them to different threads. Using extensive testing, the Catel team discovered that approximately 1000 types / thread is the ideal load balancing (otherwise the spawning of the threads is more expensive than it handling it on the same thread). If this behavior needs to be customized, simply provide the number of types per thread. If -1 is specified, all types will be warmed up in a single thread.\nThe code example below shows how to initialize all types deriving from ModelBase on a single thread:\nvar xmlSerializer = SerializationFactory.GetXmlSerializer(); xmlSerialzier.Warmup(null, -1);  Backwards compatibility for binary serialization This example shows how an “old” (standard .NET) data class that uses custom binary serialization can easily be converted to a *ModelBase* to use the *ModelBase* even for all your existing classes.\nDeclare a new *ModelBase* class (remember the *‘dataobject’* code snippet). If the new class is in a new assembly, or has a new name or namespace, use the *RedirectType* attribute to let the *ModelBase* know that when it finds the old type, it should deserialize that type into the new type.\nThen, by default, the *ModelBase* class will try to deserialize the old object. If it fails to do so, it will fall back on the default values provided by the property declarations. However, it is also possible to override the *GetDataFromSerializationInfo* method:\n/// \u0026lt;summary\u0026gt; /// Retrieves the actual data from the serialization info. /// \u0026lt;/summary\u0026gt; /// \u0026lt;remarks\u0026gt; /// This method should only be implemented if backwards compatibility should be implemented for /// a class that did not previously implement the ModelBase class. /// \u0026lt;/remarks\u0026gt; protected override void GetDataFromSerializationInfo(SerializationInfo info) { // Check if deserialization succeeded if (DeserializationSucceeded) { return; } // Deserialization did not succeed for any reason, so retrieve the values manually // Luckily there is a helper class (SerializationHelper) // that eases the deserialization of \u0026quot;old\u0026quot; style objects FirstName = SerializationHelper.GetString(info, \u0026quot;FirstName\u0026quot;, FirstNameProperty.GetDefaultValue()); LastName = SerializationHelper.GetString(info, \u0026quot;LastName\u0026quot;, LastNameProperty.GetDefaultValue()); }  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/","title":"Services","tags":[],"description":"","content":" LocationService   MessageService   NavigationService   OpenFileService   PleaseWaitService   ProcessService   SaveFileService   SchedulerService   SelectDirectoryService   UIVisualizerService   VibrateService   ViewExportService   "},{"uri":"https://docs.catelproject.com/vnext/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://docs.catelproject.com/vnext/catel-core/parallel-invocation-tasks/thread-safe-code/","title":"Thread safe code","tags":[],"description":"","content":" Writing a multiple threading application is always a challenge. Eventually you need use objects or statements with the ability to synchronize access to the critical sections of the code by taking and releasing a lock.\nBackground information The common solution to access the thread-sensitive resources is use the lock statement just as follow:\nprivate readonly object _syncObj = new object(); public void DoTheWork() { lock (_syncObj) { // Access to the thread-sensitive resources here. } }   But some times the scenario is not quite simple, then you need to use the Monitor class in order to synchronize cross method operations. Here is an example: private readonly object _syncObj = new object(); public void DoTheWork() { StartTheWork(); object result = EndTheWork(); } private void StartTheWork() { Monitor.Enter(_syncObj); try { // Access to the thread-sensitive resources here. } catch(Exception) { Monitor.Exit(_syncObj); throw; } } private object EndTheWork() { try { // Access to the thread-sensitive resources here. return new object(); } finally { Monitor.Exit(_syncObj); } }  To combine the power of the simplicity of the lock statement syntax and the flexibility of the Monitor class, Catel introduces the SynchronizationContext class, allowing you to write the code like this.\nprivate readonly List\u0026lt;IValidator\u0026gt; _validators = new List\u0026lt;IValidator\u0026gt;(); private readonly SynchronizationContext _synchronizationContext = new SynchronizationContext(); public bool Contains(IValidator validator) { Argument.IsNotNull(\u0026quot;validator\u0026quot;, validator); return _synchronizationContext.Execute(() =\u0026gt; _validators.Contains(validator)); } public void Remove(IValidator validator) { Argument.IsNotNull(\u0026quot;validator\u0026quot;, validator); _synchronizationContext.Execute(() =\u0026gt; _validators.Remove(validator)); } public void BeforeValidation(object instance, List\u0026lt;IFieldValidationResult\u0026gt; previousFieldValidationResults, List\u0026lt;IBusinessRuleValidationResult\u0026gt; previousBusinessRuleValidationResults) { _synchronizationContext.Acquire(); try { foreach (IValidator validator in _validators) { validator.BeforeValidation(instance, previousFieldValidationResults, previousBusinessRuleValidationResults); } } catch (Exception) { _synchronizationContext.Release(); throw; } } public void AfterValidateBusinessRules(object instance, List\u0026lt;IBusinessRuleValidationResult\u0026gt; validationResults) { try { foreach (IValidator validator in _validators) { validator.AfterValidateBusinessRules(instance, validationResults); } } catch (Exception) { _synchronizationContext.Release(); throw; } }  SynchronizationContext also allow you create asynchronous locking request.  Acquiring a lock To acquire a lock, only a call to Acquire is required:\n_synchronizationContext.Acquire();  Releasing a lock\n To release a lock, only a call to Release is required:\n_synchronizationContext.Release();  Automatic locking of a method It is also possible to automatically lock and release a method call. This can be accomplished using the Execute method.\n_synchronizationContext.Execute(() =\u0026gt; ThreadSafeCodeExecution());  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/ui-visualizer-service/","title":"UIVisualizerService","tags":[],"description":"","content":" The IUIVisualizerService allows a developer to show (modal) windows or dialogs without actually referencing a specific view. Internally, the UIVisualizerService uses the ViewLocator to resolve views.\nScreenshot Showing a non-modal window To show a non-modal window, use the following code:\nvar viewModel = new EmployeeViewModel(); var dependencyResolver = this.GetDependencyResolver(); var uiVisualizerService = dependencyResolver.Resolve\u0026lt;IUIVisualizerService\u0026gt;(); uiVisualizerService.Show(viewModel);  Showing a modal window To show a modal window, use the following code:\nvar viewModel = new EmployeeViewModel(); var dependencyResolver = this.GetDependencyResolver(); var uiVisualizerService = dependencyResolver.Resolve\u0026lt;IUIVisualizerService\u0026gt;(); uiVisualizerService.ShowDialog(viewModel);  Showing a window with callback To show a (modal or non-modal) window and get a callback as soon as the window is closed, use the following code:\nvar viewModel = new EmployeeViewModel(); var dependencyResolver = this.GetDependencyResolver(); var uiVisualizerService = dependencyResolver.Resolve\u0026lt;IUIVisualizerService\u0026gt;(); uiVisualizerService.Show(viewModel, OnWindowClosed);  Registering a window To register a custom window which is not automatically detected via reflection, it is required to use the Register method:\nvar dependencyResolver = this.GetDependencyResolver(); var uiVisualizerService = dependencyResolver.Resolve\u0026lt;IUIVisualizerService\u0026gt;(); uiVisualizerService.Register(typeof(EmployeeViewModel), typeof(EmployeeView));  Using naming conventions to find windows Please see the ViewLocator topic.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/update-binding-on-password-changed/","title":"UpdateBindingOnPasswordChanged","tags":[],"description":"","content":"The UpdateBindingOnPasswordChanged is a very useful behavior which allows to bind the Password property of the PasswordBox Control. Use it, it\u0026rsquo;s really simple.\n 1) Add the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  2) Use the following definition:\n\u0026lt;PasswordBox\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:UpdateBindingOnPasswordChanged Password=\u0026quot;{Binding Password, Mode=TwoWay}\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/PasswordBox\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/update-binding-on-text-changed/","title":"UpdateBindingOnTextChanged","tags":[],"description":"","content":"The UpdateBindingOnTextChange is a very useful behavior which allows to delay a binding update on the TextChanged event of a TextBox. This way, it is possible to implement search boxes that only start a search after a specific time when no new key presses have occurred. For example, when a user types a new search string, and the user doesn\u0026rsquo;t enter a new key for 500 ms, the binding is updated.\n1) Add the following XML namespaces:\nxmlns:i=\u0026quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;  2) Use the following definition. This example will update the binding after 500 ms where normally it would only occur when the user tabs out of the TextBox:\n\u0026lt;TextBox Text=\u0026quot;{Binding SearchParam, Mode=TwoWay}\u0026quot;\u0026gt; \u0026lt;i:Interaction.Behaviors\u0026gt; \u0026lt;catel:UpdateBindingOnTextChanged UpdateDelay=\u0026quot;500\u0026quot; /\u0026gt; \u0026lt;/i:Interaction.Behaviors\u0026gt; \u0026lt;/TextBox\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/url-locator/","title":"UrlLocator","tags":[],"description":"","content":" The IUrlLocator class is responsible for resolving the right urls for the xaml views for a view model in navigation based applications. Before Catel 3.0, the INavigationService was responsible for resolving the url, but this responsibility is now taken over by the IUrlLocator. The NavigationService internally uses the IUrlLocator to resolve the views.\nResolving by naming convention It is possible to resolve views using the IUrlLocator. Then you can use the ResolveUrl method to resolve the url based on the type of the view model.\nFor example, the following view model:\nCatel.Examples.ViewModels.MyViewModel  will be resolved as:\n/Views/MyPage.xaml  Note that the `UrlLocator` checks whether the resource actually exists. If the resource does not exists, it will not be able to resolve a view  Manually resolving a naming convention To manually resolve a naming convention, use the following code:\nvar urlLocator = ServiceLocator.Instance.ResolveType\u0026lt;IUrlLocator\u0026gt;(); var url = urlLocator.ResolveUrl(typeof(MyViewModel));  Customizing naming conventions By default, the IUrlLocator uses the following naming conventions to resolve urls:\n /Views/[VM].xaml /Views/[VM]View.xaml /Views/[VM]Control.xaml /Views/[VM]Page.xaml /Views/[VM]Window.xaml /Controls/[VM].xaml /Controls/[VM]Control.xaml /Pages/[VM].xaml /Pages/[VM]Page.xaml /Windows/[VM].xaml /Windows/[VM]Window.xaml /UI.Views/[VM].xaml /UI.Views/[VM]View.xaml /UI.Views/[VM]Control.xaml /UI.Views/[VM]Page.xaml /UI.Views/[VM]Window.xaml /UI.Controls/[VM].xaml /UI.Controls/[VM]Control.xaml /UI.Pages/[VM].xaml /UI.Pages/[VM]Page.xaml /UI.Windows/[VM].xaml /UI.Windows/[VM]Window.xaml /[VM].xaml /[VM]Control.xaml /[VM]Page.xaml /[VM]Window.xaml  For more information about naming conventions, see [Naming conventions](/vnext/catel-mvvm/locators-naming-conventions/naming-conventions/)  However, it is possible to add or remove new naming conventions to support your own naming convention. For example, to add a new naming convention for a different assembly, use this code:\nvar urlLocator = ServiceLocator.Instance.ResolveType\u0026lt;IUrlLocator\u0026gt;(); urlLocator.NamingConventions.Add(\u0026quot;/MyPages/[VM]Page.xaml\u0026quot;);  Registering custom urls Sometimes, a class doesn\u0026rsquo;t follow a naming convention (for whatever reason possible). In such a case, it is possible to register a mapping manually using the following code:\nvar urlLocator = ServiceLocator.Instance.ResolveType\u0026lt;IUrlLocator\u0026gt;(); urlLocator.Register(typeof(MyViewModelNotFollowingNamingConvention), \u0026quot;/MyVerySpecialUrl.xaml\u0026quot;);  Using a custom UrlLocator If you want to have total freedom to determine which url is provided per view model (maybe there are other services that have an impact on this), it is possible to create a custom IUrlLocator implementation. Then the only thing to do is to register it using the following code:\nServiceLocator.Default.Register\u0026lt;IUrlLocator, MyUrlLocator\u0026gt;();  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/usercontrol/","title":"UserControl","tags":[],"description":"","content":" The UserControl is a very interesting class of Catel, and fully shows the power of the MVVM Framework that ships with Catel. The user control is able to fully integrate MVVM on a user control level and solves the “nested user control” problem, which is explained in detail a bit further in this documentation.\nAutomatic construction without parameter It simplest thing to do is to create a view model that has an empty constructor (thus without parameters). If the UserControl is added to the visual tree, the view model is instantly constructed and available for usage. A view model that is used inside a UserControl implementation is exactly the same as the DataWindow implementation. This way, the developers don’t have to worry about whether they can currently writing a view model that is meant for a window or a control.\nAutomatic construction with parameter A bit harder (it’s still very easy, don’t worry), but much more powerful is the construction with a parameter. This way, a control is forced to use the data context to create the view model. If there is no valid data context that can be used to construct the view model, no view model will be constructed. This sounds a little abstract, but let’s take a look to a more meaningful example.\nSay, you want to write an application to manage company trees. The top-level of the data exists of a collection of Company objects (models). You want to display the companies inside an ItemsControl, which is a very good way to represent the companies. But how are you going to display the company details? You can simply create a template, but I wouldn\u0026rsquo;t recommend that because the company representation can become very complex (and dynamic), because it consists of Person objects that can have children (employees), and the children are person objects as well, that can have children, etc. You might thing that this is a very simple scenario, which it actually is to make sure that all readers understand it correctly. But, there can be a lot of complex tree scenarios. For example, for a client, I had to write a complete treatment overview of a patient, which consists of a lot of different objects, which all have a child collection of other object types. Then you can save yourself with writing a simple and generic data template. Below is a graphical form of the example:\nNow comes the real power of UserControl in to play. For example, to show the company and its managers, one has to write an items control that contains the companies and then a user control containing the details of the company. For the sake of simplicity, I will leave the employees out for now. The usage might seem a bit complex, but once you get the hang of it, it’s actually quite simple. First of all, create a view model that has a constructor of the model that you want to accept, in our case the Company class of which we will show the details:\n/// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;CompanyViewModel\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;company\u0026quot;\u0026gt;The company.\u0026lt;/param\u0026gt; public CompanyViewModel(Models.Company company) : base() { // Store values Company = company; }  As you can see, the view model can only be constructed by passing a company model. This is quite normal, because how can we show details of a non-existing (null) company? Now we have a view model, we can create our user control:\n\u0026lt;catel:UserControl x:Class=\u0026quot;Catel.Articles._03___MVVM.Examples.UserControlWithParameter.Company\u0026quot; xmlns=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026quot; xmlns:x=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;\u0026gt; \u0026lt;!-- For the sake of simplicity, content is left out --\u0026gt; \u0026lt;/catel:UserControl\u0026gt;  Note that the class definition is now `catel:UserControl` instead of `UserControl`  The code behind is even simpler:\n/// \u0026lt;summary\u0026gt; /// Interaction logic for Company.xaml /// \u0026lt;/summary\u0026gt; public partial class Company : UserControl { /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;Company\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; public Company() { InitializeComponent(); } }  Now the control is created (I don’t want to focus on the actual control content here, since it’s not important), we can use the user control in our main window that has a collection of companies. The view model also has a SelectedCompany property representing the selected company inside the listbox. Then, we use the Company control and bind the data context to the SelectedCompany property:\n\u0026lt;!-- Items control of companies --\u0026gt; \u0026lt;ListBox Grid.Column=\u0026quot;0\u0026quot; ItemsSource=\u0026quot;{Binding CompanyCollection}\u0026quot; SelectedItem=\u0026quot;{Binding SelectedCompany}\u0026quot;\u0026gt; \u0026lt;ListBox.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;StackPanel\u0026gt; \u0026lt;Label Content=\u0026quot;{Binding Name}\u0026quot; /\u0026gt; \u0026lt;Label Content=\u0026quot;{Binding CEO.FullName}\u0026quot; /\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/ListBox.ItemTemplate\u0026gt; \u0026lt;/ListBox\u0026gt; \u0026lt;!-- Company details --\u0026gt; \u0026lt;UserControlWithParameter:Company Grid.Column=\u0026quot;1\u0026quot; DataContext=\u0026quot;{Binding SelectedCompany}\u0026quot; /\u0026gt;  As the code shows, there is a listbox containing all the companies. The data context of the user control is bound to the SelectedCompany. The cool thing is that as soon as a company is selected, the user control will create an instance of the CompanyViewModel because it accepts a Company instance in the constructor. The screenshot of the example application will (hopefully) give more insight in what change is causing the exact view model creation:\nIn the image above, you see 2 controls. The first one is an items control that binds to the CompaniesViewModel because the window represents list of companies. The second one is the CompanyControl, which dynamically constructs the CompanyViewModel as soon as a company is selected at the left. This means that for every company selection, and new view model is constructed. This way, you can handle the saving, canceling and closing of the view model before the next is view model is constructed.\nThe best thing about this is that you can actually start re-using user controls throughout your whole application. Instead of having the main view model have to define all the properties of (sub) controls, now each control has its own view model, and you don’t have to worry about the implementation in the parent of a control. Simply set the data context of the user control to the right type instance, and the user control will handle the rest.\nThe easiest way to create a new `UserControl` is to use item templates  Mapping properties from/to view model When developing custom user controls, you still want to use the power of MVVM, right? With Catel, all of this is possible. All other frameworks require a developer to manually set the data context on a user control. Or what about mapping user control properties from/to the view model?\nTo map a property of a custom user control to a view model and back, the only thing a developer has to do is to decorate the dependency property of the control with the ViewToViewModelAttribute. Normally, a developer has to build logic that subscribes to property changes of both the view model and the control, and then synchronize all the differences. Thanks to the ViewToViewModelAttribute, the UserControl that ships with Catel takes care of this. The usage of the attribute looks as follows:\n[ViewToViewModel] public bool MyDependencyProperty { get { return (bool)GetValue(MyDependencyPropertyProperty); } set { SetValue(MyDependencyPropertyProperty, value); } } // Using a DependencyProperty as the backing store for MyDependencyProperty. This enables animation, styling, binding, etc... public static readonly DependencyProperty MyDependencyPropertyProperty = DependencyProperty.Register(\u0026quot;MyDependencyProperty\u0026quot;, typeof(bool), typeof(MyControl), new UIPropertyMetadata(true));  By default, the attribute assumes that the name of the property on the view model is the same as the property on the user control. To specify a different name, use the overload of the attribute constructor as shown in the following example:\n[ViewToViewModel(\u0026quot;MyViewModelProperty\u0026quot;)] public bool MyDependencyProperty ... (remaining code left out for the sake of simplicity)  In the first place, all of this looks fine enough. However, what should happen when the current view model of the control is replaced by another instance? Or what if the developer only wants to map values from the control to the view model, but not back? By default, the view model will take the lead when this attribute is used. This means that as soon as the view model is changed, the values of the control will be overwritten by the values of the view model. If another behavior is required, the MappingType property of the attribute should be used:\n[ViewToViewModel(\u0026quot;MyViewModelProperty\u0026quot;, MappingType = ViewToViewModelMappingType.TwoWayControlWins)] public bool MyDependencyProperty ... (remaining code left out for the sake of simplicity)  The table below explains the options in detail:\nTwoWayDoNothing\nTwo way, which means that either the control or the view model will update the values of the other party as soon as they are updated.\nWhen this value is used, nothing happens when the view model of the user control changes. This way, it might be possible that the values of the control and the view model are different. The first one to update next will update the other.\nTwoWayViewWins\nTwo way, which means that either the control or the view model will update the values of the other party as soon as they are updated.\nWhen this value is used, the value of the control is used when the view model of the user control is changed, and is directly transferred to the view model value.\nTwoWayViewModelWins\nTwo way, which means that either the control or the view model will update the values of the other party as soon as they are updated.\nWhen this value is used, the value of the view model is used when the view model of the user control is changed, and is directly transferred to the control value.\nViewToViewModel\nThe mapping is from the control to the view model only.\nViewModelToView\nThe mapping is from the view model to the control only.\nKeeping view models alive The UserControl automatically closes view models in the Unloaded event. Reason for this is that there is no guarantee that the control will be loaded again. However, this can have some negative side effects. On of this side effects is a user control shown as a tab in a tab control. One of the behaviors of a tab control is that it unloads all non-active tabs from the visual tree. Therefore, the UserControl cancels and closes the view model. However, the state of the tab is lost then as well.\nTo prevent this behavior, it is possible to keep view models alive when a user control is unloaded. This can be done by setting CloseViewModelOnUnloaded to false. This way, the view model is not closed and will be re-used when the control is loaded again. The downside of this is that the responsibility of closing and disposing the view model is now in the hands of the developer. A great way to make a difference between unloading (tab switch) and closing is to create a close button on the tabs that will explicitly call ViewModel.CloseViewModel.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/advanced/usercontrol-under-the-hood/","title":"UserControl - under the hood","tags":[],"description":"","content":" The UserControl is a pretty sophisticated class. In this part of the documentation, the inner workings of the control are explained. What better way is there than to using flowcharts. There are a few events very important for the inner workings of the user control. The flowcharts are created per event.\nKeep in mind that the actual logic is implemented in the `UserControlLogic`, which is used by the `UserControl`. This way, the logic can be used by any user control via the `UserControlBehavior`.  Managing the custom DataContext The UserControl logic uses an additional layer to customize the DataContext. Below is a graphical representation of how it works.\nAnother view can be found in the image below:\nMain flow The following flowchart shows what happens with a user control in the main flow (the startup). First, it checks whether the user control is loaded (which is not in a normal case). If the control is loaded, it goes directly to determining the datacontext. Otherwise, it will postpone the action until the Loaded event. Loaded When the control is loaded, it starts checking for the first time whether the current datacontext can be used to create a view model. But, before it does this, it checks whether it should (and can) re-use an existing view model. To control whether view models should be re-used, use the CloseViewModelOnUnloaded property.\nIf a view model can and should be re-used, it sets the view model as data context and that\u0026rsquo;s it. If there is no view model, or the previous view model should not be re-used, the control continues to determine the datacontext.\nUnloaded Another event that is very important is the Unloaded event. In this event, the control either cleans up the view model or stores it so it can be re-used later. Then, it also restores the old datacontext so it never breaks existing application bindings. This way, the control won\u0026rsquo;t leave any traces behind.\nDataContextChanged The DataContextChanged event is used to react to changes of the datacontext. We use the DataContextHelper class for that. If the new datacontext is new (thus not a view model that the control just set itself), it it continues to determine the datacontext. Otherwise, it will not take any action.\nDetermineDataContext All other flowcharts eventually led to this flowchart, the determination of the datacontext. The determination of the datacontext is very important, because this is the moment where the user control transforms the datacontext into a new view model if possible. First it tries is to construct the view model with the datacontext. So, if the datacontext is an object of type Person, and the view model of the user control has a constructor that accepts a Person object, it injects the datacontext into the constructor of the view model. If that fails, or there is simply no constructor, the control checks whether the view model has an empty constructor. If so, it constructs the view model and sets it as the new datacontext. If not, it will leave the datacontext untouched.\nBasically, this is all that happens on a higher level to transform a datacontext into a view model. Under the hood, it\u0026rsquo;s a bit more complicated but again, on a higher level this is what happens.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/usercontrol-resources/","title":"UserControl Resources","tags":[],"description":"","content":"For the most part the resources declared within a Catel UserControl behave the exact same as resources defined in the standard UserControl. However because of the way the Catel UserControl operates (see UserControl Under the hood) any bindings performed inside a Resource will not be found at runtime (example CollectionViewSource Source) . The solution is to declare the resource inside an element within the UserControl, not at the UserControl level. Example below:\nGiven this simple Model and ViewModel (Catel.Fody used for parameter declaration)\n public class DataSource : ModelBase { public int Id { get; set; } public string URI { get; set; } public string DataSourceType { get; set; } public string Description { get; set; } public string ShortURI { get { if (string.IsNullOrEmpty(URI)) return null; Uri uri = new System.Uri(URI); if (uri.IsFile) { return System.IO.Path.GetFileName(uri.LocalPath); } return URI; } } } public class DocumentViewModel : ViewModelBase { public DocumentViewModel(ICommandManager commandManager) { ProjectDataSources = new FastObservableCollection\u0026lt;DataSource\u0026gt;(); ProjectDataSources.Add(new DataSource() { Id = 1, URI = \u0026quot;file:///D:/src/TAnaylze/Data/DataSources/dnd-viewerPolygon_AoI-Intergranular_porosity.json\u0026quot;, DataSourceType = \u0026quot;tmapdd\u0026quot;, Description = \u0026quot;From TMap DragDrop\u0026quot; }); ProjectDataSources.Add(new DataSource() { Id = 2, URI = \u0026quot;file:///D:/src/TAnaylze/Data/DataSources/dnd-viewerPolygon_AoI-Intergranular_porosity.json\u0026quot;, DataSourceType = \u0026quot;tmapdd\u0026quot; }); ProjectDataSources.Add(new DataSource() { Id = 3, URI = \u0026quot;file:///D:/src/TAnaylze/Data/DataSources/Project X.tdb\u0026quot;, DataSourceType = \u0026quot;tdb\u0026quot;, Description = \u0026quot;Project X.tdb\u0026quot; }); ProjectDataSources.Add(new DataSource() { Id = 4, URI = \u0026quot;file:///D:/src/TAnaylze/Data/DataSources/TMap Workshop.tmap\u0026quot;, DataSourceType = \u0026quot;tmap\u0026quot;, Description = \u0026quot;TMap Workshop.tmap\u0026quot; }); } public FastObservableCollection\u0026lt;DataSource\u0026gt; ProjectDataSources { get; set; } }  and this View:\nView\n\u0026lt;catel:UserControl x:Class=\u0026quot;Catel.Examples.WPF.Commanding.Views.DocumentView\u0026quot; xmlns=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026quot; xmlns:x=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml\u0026quot; xmlns:sys=\u0026quot;clr-namespace:System;assembly=mscorlib\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;\u0026gt; \u0026lt;catel:UserControl.Resources\u0026gt; \u0026lt;ResourceDictionary\u0026gt; \u0026lt;!-- The Resource ListViewTitle will be found at run time --\u0026gt; \u0026lt;sys:String x:Key=\u0026quot;ListViewTitle\u0026quot;\u0026gt;Items:\u0026lt;/sys:String\u0026gt; \u0026lt;!-- The Resource DataSourceGroup will be found but the binding will not work. --\u0026gt; \u0026lt;CollectionViewSource x:Key=\u0026quot;DataSourceGroup\u0026quot; Source=\u0026quot;{Binding ProjectDataSources}\u0026quot; IsLiveSortingRequested=\u0026quot;True\u0026quot; IsLiveGroupingRequested=\u0026quot;True\u0026quot;\u0026gt; \u0026lt;CollectionViewSource.GroupDescriptions\u0026gt; \u0026lt;PropertyGroupDescription PropertyName=\u0026quot;DataSourceType\u0026quot; /\u0026gt; \u0026lt;/CollectionViewSource.GroupDescriptions\u0026gt; \u0026lt;/CollectionViewSource\u0026gt; \u0026lt;/ResourceDictionary\u0026gt; \u0026lt;/catel:UserControl.Resources\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;5\u0026quot; /\u0026gt; \u0026lt;ColumnDefinition Width=\u0026quot;*\u0026quot; /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;ScrollViewer Grid.Column=\u0026quot;0\u0026quot;\u0026gt; \u0026lt;StackPanel\u0026gt; \u0026lt;StackPanel.Resources\u0026gt; \u0026lt;/StackPanel.Resources\u0026gt; \u0026lt;Label Foreground=\u0026quot;Blue\u0026quot; Margin=\u0026quot;5,5,5,0\u0026quot; Content=\u0026quot;{StaticResource ListViewTitle}\u0026quot;\u0026gt;\u0026lt;/Label\u0026gt; \u0026lt;ListView Name=\u0026quot;_datasourcelv1\u0026quot; ItemsSource=\u0026quot;{Binding Source={StaticResource DataSourceGroup}}\u0026quot;\u0026gt; \u0026lt;ListView.View\u0026gt; \u0026lt;GridView\u0026gt; \u0026lt;GridViewColumn Header=\u0026quot;Name\u0026quot; Width=\u0026quot;120\u0026quot; DisplayMemberBinding=\u0026quot;{Binding ShortURI}\u0026quot; /\u0026gt; \u0026lt;GridViewColumn Header=\u0026quot;Type\u0026quot; Width=\u0026quot;50\u0026quot; DisplayMemberBinding=\u0026quot;{Binding DataSourceType}\u0026quot; /\u0026gt; \u0026lt;/GridView\u0026gt; \u0026lt;/ListView.View\u0026gt; \u0026lt;ListView.GroupStyle\u0026gt; \u0026lt;GroupStyle\u0026gt; \u0026lt;GroupStyle.HeaderTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;TextBlock Text=\u0026quot;{Binding Name}\u0026quot;/\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/GroupStyle.HeaderTemplate\u0026gt; \u0026lt;/GroupStyle\u0026gt; \u0026lt;/ListView.GroupStyle\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/ScrollViewer\u0026gt; \u0026lt;GridSplitter Grid.Column=\u0026quot;1\u0026quot; Width=\u0026quot;5\u0026quot; HorizontalAlignment=\u0026quot;Stretch\u0026quot; /\u0026gt; \u0026lt;ScrollViewer Grid.Column=\u0026quot;2\u0026quot;\u0026gt; \u0026lt;StackPanel\u0026gt; \u0026lt;StackPanel.Resources\u0026gt; \u0026lt;!-- The solution is to embed the resource inside the UserControl, this way the binding is within the runtime Visual Tree. --\u0026gt; \u0026lt;CollectionViewSource x:Key=\u0026quot;DataSourceGroup2\u0026quot; Source=\u0026quot;{Binding ProjectDataSources}\u0026quot; IsLiveSortingRequested=\u0026quot;True\u0026quot; IsLiveGroupingRequested=\u0026quot;True\u0026quot;\u0026gt; \u0026lt;CollectionViewSource.GroupDescriptions\u0026gt; \u0026lt;PropertyGroupDescription PropertyName=\u0026quot;DataSourceType\u0026quot; /\u0026gt; \u0026lt;/CollectionViewSource.GroupDescriptions\u0026gt; \u0026lt;/CollectionViewSource\u0026gt; \u0026lt;/StackPanel.Resources\u0026gt; \u0026lt;Label Foreground=\u0026quot;Blue\u0026quot; Margin=\u0026quot;5,5,5,0\u0026quot; Content=\u0026quot;{StaticResource ListViewTitle}\u0026quot;\u0026gt;\u0026lt;/Label\u0026gt; \u0026lt;ListView Name=\u0026quot;_datasourcelv2\u0026quot; ItemsSource=\u0026quot;{Binding Source={StaticResource DataSourceGroup2}}\u0026quot;\u0026gt; \u0026lt;ListView.View\u0026gt; \u0026lt;GridView\u0026gt; \u0026lt;GridViewColumn Header=\u0026quot;Name\u0026quot; Width=\u0026quot;120\u0026quot; DisplayMemberBinding=\u0026quot;{Binding ShortURI}\u0026quot; /\u0026gt; \u0026lt;GridViewColumn Header=\u0026quot;Type\u0026quot; Width=\u0026quot;50\u0026quot; DisplayMemberBinding=\u0026quot;{Binding DataSourceType}\u0026quot; /\u0026gt; \u0026lt;/GridView\u0026gt; \u0026lt;/ListView.View\u0026gt; \u0026lt;ListView.GroupStyle\u0026gt; \u0026lt;GroupStyle\u0026gt; \u0026lt;GroupStyle.HeaderTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;TextBlock Text=\u0026quot;{Binding Name}\u0026quot;/\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/GroupStyle.HeaderTemplate\u0026gt; \u0026lt;/GroupStyle\u0026gt; \u0026lt;/ListView.GroupStyle\u0026gt; \u0026lt;/ListView\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/ScrollViewer\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/catel:UserControl\u0026gt;   Will produce this at runtime:\n The ListView on the left is not populated because the binding is not found and will produce this error:\nSystem.Windows.Data Error: 40 : BindingExpression path error: 'ProjectDataSources' property not found on 'object' ''MainWindowViewModel' (HashCode=-1500006600)'. BindingExpression:Path=ProjectDataSources; DataItem='MainWindowViewModel' (HashCode=-1500006600); target element is 'CollectionViewSource' (HashCode=5965360); target property is 'Source' (type 'Object')  While the ListView on the right has the correct content due to the proper binding. Further discussion on Stack Overflow.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/external-controls/using-custom-control/","title":"Using a custom control","tags":[],"description":"","content":" In this part of the documentation, the RadTabItem of Telerik will be used as an example on how to create a RadTabItem that behaves like the UserControl.\nCreating the base class with behavior The first thing to do is to create a new base class that accepts a view model type argument. In this example, we will call it TabItem (to make it as \u0026ldquo;external control company independent\u0026rdquo; as possible). Below is the code for the control definition. The downside of xaml based applications is that you cannot derive from controls or windows that have a partial class defined in xaml. Therefore, all controls and code must be initialized via code as you can see in the code below.\n/// \u0026lt;summary\u0026gt; /// Base class for a control with the Catel mvvm behavior. /// \u0026lt;/summary\u0026gt; public class TabItem : RadTabItem, IUserControl { private readonly UserControlLogic _logic; private event EventHandler\u0026lt;EventArgs\u0026gt; _viewLoaded; private event EventHandler\u0026lt;EventArgs\u0026gt; _viewUnloaded; private event EventHandler\u0026lt;Catel.MVVM.Views.DataContextChangedEventArgs\u0026gt; _viewDataContextChanged; /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;TabItem\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; public TabItem() { _logic = new UserControlLogic(this, viewModelType); _logic.PropertyChanged += (sender, e) =\u0026gt; PropertyChanged.SafeInvoke(this, e); Loaded += (sender, e) =\u0026gt; _viewLoaded.SafeInvoke(this); Unloaded += (sender, e) =\u0026gt; _viewUnloaded.SafeInvoke(this); this.AddDataContextChangedHandler((sender, e) =\u0026gt; _viewDataContextChanged.SafeInvoke(this, new Catel.MVVM.Views.DataContextChangedEventArgs(e.OldValue, e.NewValue))); SetBinding(RadTabItem.HeaderProperty, new Binding(\u0026quot;Title\u0026quot;)); } /// \u0026lt;summary\u0026gt; /// Gets the view model that is contained by the container. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;The view model.\u0026lt;/value\u0026gt; public IViewModel ViewModel { get { return _logic.ViewModel; } } /// \u0026lt;summary\u0026gt; /// Occurs when a property on the container has changed. /// \u0026lt;/summary\u0026gt; /// \u0026lt;remarks\u0026gt; /// This event makes it possible to externally subscribe to property changes of a \u0026lt;see cref=\u0026quot;DependencyObject\u0026quot;/\u0026gt; /// (mostly the container of a view model) because the .NET Framework does not allows us to. /// \u0026lt;/remarks\u0026gt; public event PropertyChangedEventHandler PropertyChanged; /// \u0026lt;summary\u0026gt; /// Occurs when the view is loaded. /// \u0026lt;/summary\u0026gt; event EventHandler\u0026lt;EventArgs\u0026gt; IView.Loaded { add { _viewLoaded += value; } remove { _viewLoaded -= value; } } /// \u0026lt;summary\u0026gt; /// Occurs when the view is unloaded. /// \u0026lt;/summary\u0026gt; event EventHandler\u0026lt;EventArgs\u0026gt; IView.Unloaded { add { _viewUnloaded += value; } remove { _viewUnloaded -= value; } } /// \u0026lt;summary\u0026gt; /// Occurs when the data context has changed. /// \u0026lt;/summary\u0026gt; event EventHandler\u0026lt;Catel.MVVM.Views.DataContextChangedEventArgs\u0026gt; IView.DataContextChanged { add { _viewDataContextChanged += value; } remove { _viewDataContextChanged -= value; } } }  You would expect an abstract class here, but the designers (both Visual Studio and Expression Blend) can't handle abstract base classes  Using the class The class can now be used the same as the UserControl class. For more information, see UserControl explained.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/external-controls/using-custom-window/","title":"Using a custom window","tags":[],"description":"","content":" In this part of the documentation, the RadWindow of Telerik will be used as an example on how to create a WindowBase that behaves like the DataWindow.\nCreating the base class with behavior The first thing to do is to create a new base class that accepts a view model type argument. In this example, we will call it WindowBase (to make it as \u0026ldquo;external control company independent\u0026rdquo; as possible). Below is the code for the window definition. The downside of xaml based applications is that you cannot derive from controls or windows that have a partial class defined in xaml. Therefore, all controls and code must be initialized via code as you can see in the code below.\nBecause the RadWindow of Telerik does not close the window when the DialogResult is set, this window subscribes to the ViewModelClosed event to close the window\n/// \u0026lt;summary\u0026gt; /// Base class for a window with the Catel mvvm behavior. /// \u0026lt;/summary\u0026gt; public class Window : RadWindow, IDataWindow { private readonly WindowLogic _logic; private event EventHandler\u0026lt;EventArgs\u0026gt; _viewLoaded; private event EventHandler\u0026lt;EventArgs\u0026gt; _viewUnloaded; private event EventHandler\u0026lt;Catel.MVVM.Views.DataContextChangedEventArgs\u0026gt; _viewDataContextChanged; public Window() : this(null) { } public Window(IViewModel viewModel) { _logic = new WindowLogic(this, null, viewModel); _logic.ViewModelChanged += (sender, e) =\u0026gt; ViewModelChanged.SafeInvoke(this, e); _logic.PropertyChanged += (sender, e) =\u0026gt; PropertyChanged.SafeInvoke(this, e); Loaded += (sender, e) =\u0026gt; _viewLoaded.SafeInvoke(this); Unloaded += (sender, e) =\u0026gt; _viewUnloaded.SafeInvoke(this); this.AddDataContextChangedHandler((sender, e) =\u0026gt; _viewDataContextChanged.SafeInvoke(this, new Catel.MVVM.Views.DataContextChangedEventArgs(e.OldValue, e.NewValue))); // Because the RadWindow does not close when DialogResult is set, the following code is required ViewModelChanged += (sender, e) =\u0026gt; OnViewModelChanged(); // Call manually the first time (for injected view models) OnViewModelChanged(); WindowStartupLocation = WindowStartupLocation.CenterScreen; SetBinding(RadWindow.HeaderProperty, new Binding(\u0026quot;Title\u0026quot;)); } public IViewModel ViewModel { get { return _logic.ViewModel; } } public event PropertyChangedEventHandler PropertyChanged; public event EventHandler\u0026lt;EventArgs\u0026gt; ViewModelChanged; event EventHandler\u0026lt;EventArgs\u0026gt; IView.Loaded { add { _viewLoaded += value; } remove { _viewLoaded -= value; } } event EventHandler\u0026lt;EventArgs\u0026gt; IView.Unloaded { add { _viewUnloaded += value; } remove { _viewUnloaded -= value; } } event EventHandler\u0026lt;Catel.MVVM.Views.DataContextChangedEventArgs\u0026gt; IView.DataContextChanged { add { _viewDataContextChanged += value; } remove { _viewDataContextChanged -= value; } } private void OnViewModelChanged() { if (ViewModel != null \u0026amp;\u0026amp; !ViewModel.IsClosed) { ViewModel.Closed += ViewModelClosed; } } private void ViewModelClosed(object sender, ViewModelClosedEventArgs e) { Close(); } }  You would expect an abstract class here, but the designers (both Visual Studio and Expression Blend) can't handle abstract base classes  Handling Close Event Since the latest upgrade to Catel 5.x, the UIVisualizerService has been modified in terms of how Close events are handled. Currently, a non-generic EventHandler is utilized; this would present a problem if a window other than DataWindow is utilized and the Close event handler is generic; a simple cast from EventHandler to EventHandler\u0026lt;\u0026gt; is not possible without reflection. For our example here, the RadWindow utilizes EventHandler\u0026lt;WindowClosedEventArgs\u0026gt;. In order to be able to utilize UIVisualizerService without any exception, the HandleCloseSubscription will need to be overridden. See example below:\npublic class CustomUIVisualService : UIVisualizerService, ICustomUIVisualizerService { private readonly IViewLocator _viewLocator; public CustomUIVisualService(IViewLocator viewLocator) : base(viewLocator) { this._viewLocator = viewLocator; } protected override void HandleCloseSubscription(object window, object data, EventHandler\u0026lt;UICompletedEventArgs\u0026gt; completedProc, bool isModal) { var eventInfo = window.GetType().GetEvent(\u0026quot;Closed\u0026quot;); var addMethod = eventInfo?.AddMethod; if (addMethod != null) { EventHandler\u0026lt;WindowClosedEventArgs\u0026gt; eventHandler = null; void Closed(object s, EventArgs e) { if (!ReferenceEquals(window, s)) { // Fix for https://github.com/Catel/Catel/issues/1074 return; } bool? dialogResult; PropertyHelper.TryGetPropertyValue(window, \u0026quot;DialogResult\u0026quot;, out dialogResult); try { completedProc(this, new UICompletedEventArgs(data, isModal ? dialogResult : null)); } finally { var removeMethod = eventInfo.RemoveMethod; if (removeMethod != null) { removeMethod.Invoke(window, new object[] { eventHandler }); } } } eventHandler = Closed; addMethod.Invoke(window, new object[] { eventHandler }); } } }  We have basically created a new class named CustomUIVisualizerService which inherits from UIVisualizerService and then have overridden the HandleCloseSubscription. If you peek into the base method definition you will see that the only change is from EventHandler to EventHandler\u0026lt;WindowClosedEventArgs\u0026gt;.\nThe ICustomUIVisualizerService interface is only a convenience interface to allow for service injection:\npublic interface ICustomUIVisualizerService : IUIVisualizerService { }  Of course, this will need to be registered with the ServiceLocator to be utilized correctly:\nServiceLocator.Default.RegisterType\u0026lt;ICustomUIVisualService, CustomUIVisualService\u0026gt;  Using the class The class can now be used the same as the DataWindow class. For more information, see Window and DataWindow.\n"},{"uri":"https://docs.catelproject.com/vnext/tips-tricks/mvvm/using-tabbed-interface-with-mvvm/","title":"Using a tabbed interface with MVVM","tags":[],"description":"","content":" A common scenario in WPF is to use a tabbed interface to give the user the option to use multiple main views in a tabbed environment. This example shows how to implement this correctly with both closable and non-closable tabs.\nFor this example, we will have a few requirements:\n Be able to add, close and activate tabs via a service Be able to specify whether a tab can be closed by the end-user  Creating the model describing a tab item First of all, we need a model describing a tab item so we can interact with a service. We want the tab to be closeable via the service, but also via the view model it is representing.\npublic namespace TabDemo { using System; using System.Threading.Tasks; using Catel; using Catel.MVVM; public class TabItem { public TabItem(IViewModel viewModel) { Argument.IsNotNull(() =\u0026gt; viewModel); ViewModel = viewModel; CanClose = true; if (!viewModel.IsClosed) { viewModel.ClosedAsync += OnViewModelClosed; } } public IViewModel ViewModel { get; private set; } public bool CanClose { get; set; } public object Tag { get; set; } public event EventHandler\u0026lt;EventArgs\u0026gt; Closed; private async Task OnViewModelClosed(object sender, ViewModelClosedEventArgs e) { var vm = ViewModel; if (vm != null) { vm.ClosedAsync -= OnViewModelClosed; } Closed.SafeInvoke(this); } } }  Because we subscribe to the ClosedAsync event, we can close the tab from withing the view model.\nCreating the service Interface namespace TabDemo.Services { using System; using System.Collections.Generic; public interface ITabService { /// \u0026lt;summary\u0026gt; /// Gets all the tabs. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;The tabs.\u0026lt;/value\u0026gt; IEnumerable\u0026lt;TabItem\u0026gt; Tabs { get; } /// \u0026lt;summary\u0026gt; /// Gets the selected tab. /// \u0026lt;/summary\u0026gt; /// \u0026lt;value\u0026gt;The selected tab.\u0026lt;/value\u0026gt; TabItem SelectedTab { get; } /// \u0026lt;summary\u0026gt; /// Occurs when the selected tab has changed. /// \u0026lt;/summary\u0026gt; event EventHandler\u0026lt;TabItemEventArgs\u0026gt; SelectedTabChanged; /// \u0026lt;summary\u0026gt; /// Determines whether the specified tab item is visible. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;tabItem\u0026quot;\u0026gt;The tab item.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if the specified tab item is visible; otherwise, \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;.\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026quot;ArgumentNullException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;tabItem\u0026quot;/\u0026gt; is \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;.\u0026lt;/exception\u0026gt; bool IsVisible(TabItem tabItem); /// \u0026lt;summary\u0026gt; /// Determines whether the specified tab item is active. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;tabItem\u0026quot;\u0026gt;The tab item.\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;c\u0026gt;true\u0026lt;/c\u0026gt; if the specified tab item is active; otherwise, \u0026lt;c\u0026gt;false\u0026lt;/c\u0026gt;.\u0026lt;/returns\u0026gt; /// \u0026lt;exception cref=\u0026quot;ArgumentNullException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;tabItem\u0026quot;/\u0026gt; is \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;.\u0026lt;/exception\u0026gt; bool IsActive(TabItem tabItem); /// \u0026lt;summary\u0026gt; /// Shows the specified tab item in a tab. /// \u0026lt;para /\u0026gt; /// If the tab is already in the list of open tabs, this method won't do anything. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;tabItem\u0026quot;\u0026gt;The tab item.\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026quot;ArgumentNullException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;tabItem\u0026quot;/\u0026gt; is \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;.\u0026lt;/exception\u0026gt; void Add(TabItem tabItem); /// \u0026lt;summary\u0026gt; /// Shows the specified tab item in a tab. /// \u0026lt;para /\u0026gt; /// If the tab is already in the list of open tabs, this method won't do anything. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;index\u0026quot;\u0026gt;The index.\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;tabItem\u0026quot;\u0026gt;The tab item.\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026quot;ArgumentNullException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;tabItem\u0026quot; /\u0026gt; is \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;.\u0026lt;/exception\u0026gt; void Insert(int index, TabItem tabItem); /// \u0026lt;summary\u0026gt; /// Activates the specified tab item. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;tabItem\u0026quot;\u0026gt;The tab item.\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026quot;ArgumentNullException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;tabItem\u0026quot;/\u0026gt; is \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;.\u0026lt;/exception\u0026gt; /// \u0026lt;exception cref=\u0026quot;InvalidOperationException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;tabItem\u0026quot;/\u0026gt; is not visible, use \u0026lt;see cref=\u0026quot;Add\u0026quot;/\u0026gt; first.\u0026lt;/exception\u0026gt; void Activate(TabItem tabItem); /// \u0026lt;summary\u0026gt; /// Hides the specified tab item. /// \u0026lt;para /\u0026gt; /// If the tab is not in the list of open tabs, this method won't do anything. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;tabItem\u0026quot;\u0026gt;The tab item.\u0026lt;/param\u0026gt; /// \u0026lt;exception cref=\u0026quot;ArgumentNullException\u0026quot;\u0026gt;The \u0026lt;paramref name=\u0026quot;tabItem\u0026quot;/\u0026gt; is \u0026lt;c\u0026gt;null\u0026lt;/c\u0026gt;.\u0026lt;/exception\u0026gt; void Remove(TabItem tabItem); } }  Implementation namespace TabDemo.Services { using System; using System.Collections.Generic; using System.Linq; using System.Windows.Controls; using Catel; using Catel.Logging; using Catel.MVVM; using Catel.Windows.Threading; using TabItem = TabDemo.TabItem; public class TabService : ITabService { private static readonly ILog Log = LogManager.GetCurrentClassLogger(); private TabControl _tabControl; public TabService() { } public IEnumerable\u0026lt;TabItem\u0026gt; Tabs { get { if (_tabControl == null) { return new List\u0026lt;TabItem\u0026gt;(); } return (from tab in _tabControl.Items.Cast\u0026lt;object\u0026gt;() where tab is TabItem select (TabItem)tab).ToList(); } } public TabItem SelectedTab { get { if (_tabControl == null) { return null; } var tabItem = _tabControl.SelectedItem as TabItem; return tabItem; } } public event EventHandler\u0026lt;TabItemEventArgs\u0026gt; SelectedTabChanged; internal void SetTabControl(TabControl tabControl) { Argument.IsNotNull(() =\u0026gt; tabControl); if (_tabControl != null) { _tabControl.SelectionChanged -= OnTabControlSelectionChanged; } _tabControl = tabControl; _tabControl.SelectionChanged += OnTabControlSelectionChanged; } public bool IsVisible(TabItem tabItem) { Argument.IsNotNull(() =\u0026gt; tabItem); if (_tabControl == null) { return false; } var isVisible = (from item in _tabControl.Items.Cast\u0026lt;object\u0026gt;() where ReferenceEquals(tabItem, item) select true).Any(); return isVisible; } public bool IsActive(TabItem tabItem) { Argument.IsNotNull(() =\u0026gt; tabItem); if (_tabControl == null) { return false; } var selectedTab = SelectedTab; var isActive = ReferenceEquals(selectedTab, tabItem); return isActive; } public void Add(TabItem tabItem) { Argument.IsNotNull(() =\u0026gt; tabItem); if (_tabControl == null) { return; } Insert(_tabControl.Items.Count, tabItem); } public void Insert(int index, TabItem tabItem) { Argument.IsNotNull(() =\u0026gt; tabItem); if (_tabControl == null) { return; } var isVisible = IsVisible(tabItem); if (isVisible) { return; } tabItem.Closed += OnTabItemClosed; _tabControl.Items.Insert(index, tabItem); } public void Activate(TabItem tabItem) { Argument.IsNotNull(() =\u0026gt; tabItem); if (_tabControl == null) { return; } var isVisible = IsVisible(tabItem); if (!isVisible) { throw Log.ErrorAndCreateException\u0026lt;InvalidOperationException\u0026gt;(\u0026quot;Tab item is not visible, use the Show() method first\u0026quot;); } _tabControl.SelectedItem = tabItem; } public void Remove(TabItem tabItem) { Argument.IsNotNull(() =\u0026gt; tabItem); if (_tabControl == null) { return; } tabItem.Closed -= OnTabItemClosed; _tabControl.RemoveAndUpdateSelection(tabItem); } private void OnTabItemClosed(object sender, EventArgs e) { var tabItem = sender as TabItem; if (tabItem != null) { tabItem.Closed -= OnTabItemClosed; if (_tabControl == null) { return; } _tabControl.Dispatcher.BeginInvoke(() =\u0026gt; Remove(tabItem)); } } private void OnTabControlSelectionChanged(object sender, SelectionChangedEventArgs e) { var handler = SelectedTabChanged; if (handler != null) { var selectedTab = SelectedTab; handler(this, new TabItemEventArgs(selectedTab)); } } } }  Creating the views For this to work, the service needs to interact with views. We have a few views to create.\nCreating ClosableTabItem Xaml \u0026lt;UserControl x:Class=\u0026quot;TabDemo.Controls.ClosableTabItem\u0026quot; xmlns=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026quot; xmlns:x=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml\u0026quot; xmlns:mc=\u0026quot;http://schemas.openxmlformats.org/markup-compatibility/2006\u0026quot; xmlns:d=\u0026quot;http://schemas.microsoft.com/expression/blend/2008\u0026quot; xmlns:orchestra=\u0026quot;https://github.com/orcomp/orchestra\u0026quot; xmlns:gum=\u0026quot;http://www.wildgums.net.au/gum\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot; xmlns:controls=\u0026quot;clr-namespace:TabDemo.Controls\u0026quot; mc:Ignorable=\u0026quot;d\u0026quot; d:DesignHeight=\u0026quot;300\u0026quot; d:DesignWidth=\u0026quot;300\u0026quot;\u0026gt; \u0026lt;StackPanel Orientation=\u0026quot;Horizontal\u0026quot;\u0026gt; \u0026lt;TextBlock Text=\u0026quot;{Binding RelativeSource={RelativeSource AncestorType={x:Type controls:ClosableTabItem}}, Path=Title}\u0026quot;/\u0026gt; \u0026lt;Button Click=\u0026quot;OnCloseButtonClick\u0026quot; Margin=\u0026quot;5,0,0,0\u0026quot; Background=\u0026quot;Transparent\u0026quot; Visibility=\u0026quot;{Binding RelativeSource={RelativeSource AncestorType={x:Type controls:ClosableTabItem}}, Path=CanClose, Converter={catel:BooleanToCollapsingVisibilityConverter}}\u0026quot;\u0026gt; \u0026lt;Image Source=\u0026quot;{Image Source to a close Image}\u0026quot; Width=\u0026quot;12\u0026quot; Height=\u0026quot;12\u0026quot; /\u0026gt; \u0026lt;/Button\u0026gt; \u0026lt;/StackPanel\u0026gt; \u0026lt;/UserControl\u0026gt;  Code behind namespace Tabdemo.Controls { using System.Windows; using System.Windows.Controls; using System.Windows.Data; using Catel.MVVM; using Catel.Windows; public partial class ClosableTabItem { #region Constructors public ClosableTabItem() { InitializeComponent(); Loaded += OnLoaded; } #endregion public string Title { get { return (string)GetValue(TitleProperty); } set { SetValue(TitleProperty, value); } } public static readonly DependencyProperty TitleProperty = DependencyProperty.Register(\u0026quot;Title\u0026quot;, typeof(string), typeof(ClosableTabItem), new PropertyMetadata(string.Empty)); public bool CanClose { get { return (bool)GetValue(CanCloseProperty); } set { SetValue(CanCloseProperty, value); } } public static readonly DependencyProperty CanCloseProperty = DependencyProperty.Register(\u0026quot;CanClose\u0026quot;, typeof(bool), typeof(ClosableTabItem), new PropertyMetadata(true)); private void OnLoaded(object sender, RoutedEventArgs e) { var vmContainer = Content as IViewModelContainer; if (vmContainer == null) { return; } var vm = vmContainer.ViewModel; if (vm == null) { var frameworkElement = vmContainer as FrameworkElement; if (frameworkElement != null) { vm = frameworkElement.DataContext as IViewModel; } if (vm == null) { return; } } SetBinding(TitleProperty, new Binding { Source = vm, Path = new PropertyPath(\u0026quot;Title\u0026quot;) }); } private void OnCloseButtonClick(object sender, RoutedEventArgs e) { if (!CanClose) { return; } var tabControl = this.FindVisualAncestorByType\u0026lt;TabControl\u0026gt;(); if (tabControl != null) { tabControl.RemoveAndUpdateSelection(DataContext); } } } }  Creating main view (tab control container) Xaml \u0026lt;catel:UserControl x:Class=\u0026quot;TabDemo.Views.MainView\u0026quot; xmlns=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026quot; xmlns:x=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot; xmlns:controls=\u0026quot;clr-namespace:TabDemo.Controls\u0026quot;\u0026gt; \u0026lt;catel:TabControl x:Name=\u0026quot;tabControl\u0026quot; Margin=\u0026quot;-2\u0026quot; LoadTabItems=\u0026quot;LazyLoading\u0026quot;\u0026gt; \u0026lt;TabControl.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;controls:ClosableTabItem Title=\u0026quot;{Binding ViewModel.Title}\u0026quot; CanClose=\u0026quot;{Binding CanClose}\u0026quot; /\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/TabControl.ItemTemplate\u0026gt; \u0026lt;TabControl.ContentTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;ContentControl Content=\u0026quot;{Binding ViewModel, Converter={catel:ViewModelToViewConverter}}\u0026quot; /\u0026gt; \u0026lt;/DataTemplate\u0026gt; \u0026lt;/TabControl.ContentTemplate\u0026gt; \u0026lt;/catel:TabControl\u0026gt; \u0026lt;/catel:UserControl\u0026gt;  Code behind namespace TabDemo.Views { using Catel.IoC; using Services; public partial class MainView { public MainView() { InitializeComponent(); var serviceLocator = this.GetServiceLocator(); var tabService = serviceLocator.ResolveType\u0026lt;ITabService\u0026gt;() as TabService; if (tabService != null) { tabService.SetTabControl(tabControl); } } } }  Useful extension methods Here are some useful extension methods\nITabServiceExtensions namespace TabDemo.Services { using Catel; using Catel.IoC; using Catel.MVVM; using Services; public static class ITabServiceExtensions { public static TabItem Add\u0026lt;TViewModel\u0026gt;(this ITabService tabService, object dataContext = null, bool canClose = false) where TViewModel : IViewModel { Argument.IsNotNull(() =\u0026gt; tabService); var tabItem = CreateTabItem\u0026lt;TViewModel\u0026gt;(tabService, dataContext); tabItem.CanClose = canClose; tabService.Add(tabItem); return tabItem; } public static TabItem AddAndActivate\u0026lt;TViewModel\u0026gt;(this ITabService tabService, object dataContext = null, bool canClose = false) where TViewModel : IViewModel { Argument.IsNotNull(() =\u0026gt; tabService); var tabItem = Add\u0026lt;TViewModel\u0026gt;(tabService, dataContext, canClose); tabService.Activate(tabItem); return tabItem; } public static TabItem CreateTabItem\u0026lt;TViewModel\u0026gt;(this ITabService tabService, object dataContext) where TViewModel : IViewModel { Argument.IsNotNull(() =\u0026gt; tabService); var dependencyResolver = tabService.GetDependencyResolver(); var viewModelFactory = dependencyResolver.Resolve\u0026lt;IViewModelFactory\u0026gt;(); var vm = viewModelFactory.CreateViewModel\u0026lt;TViewModel\u0026gt;(dataContext); return new TabItem(vm); } public static void AddAndActivate(this ITabService tabService, TabItem tabItem) { Argument.IsNotNull(() =\u0026gt; tabService); Argument.IsNotNull(() =\u0026gt; tabItem); tabService.Add(tabItem); tabService.Activate(tabItem); } } }  TabControlExtensions namespace TabDemo.Services { using System.Linq; using System.Windows.Controls; public static class TabControlExtensions { public static bool RemoveAndUpdateSelection(this TabControl tabControl, object tabItem) { var index = tabControl.Items.IndexOf(tabItem); if (index == -1) { return false; } var wasSelected = ReferenceEquals(tabControl.SelectedItem, tabItem); tabControl.Items.RemoveAt(index); if (wasSelected) { var newIndex = index; var newItem = newIndex \u0026lt; tabControl.Items.Count ? tabControl.Items[newIndex] : tabControl.Items.Cast\u0026lt;object\u0026gt;().LastOrDefault(x =\u0026gt; x is TabItem); tabControl.SelectedItem = newItem; } return true; } } }   Using the service Adding a new tab and activate it This adds and activates a new tab which the user is allowed to close:\n_tabService.AddAndActivate\u0026lt;DemoTabViewModel\u0026gt;(null, true);  Closing a tab from withing a view model This closes a tab from within a tab view model. Closing a view model causes the TabItem to raise the Closed event and the TabService will correctly close the tab and update its selection.\nthis.SaveAndCloseViewModelAsync();  Closing a tab from outside a view model This closes the currently active tab:\nvar selectedTab = _tabService.SelectedTab; _tabService.Remove(selectedTab);  Download example Download example\n"},{"uri":"https://docs.catelproject.com/vnext/tips-tricks/mvvm/using-compiled-bindings/","title":"Using compiled bindings","tags":[],"description":"","content":" A common scenario in UWP is to use x:Bind instead of Binding. This requires knowledge about the actual type of the view model.\nThere are 2 options to support this.\nUse the VM property Catel by default exposes the ViewModel property as IViewModel. However, there is a reserved VM property you can use that is typed:\npublic sealed partial class BikeSummaryView { public BikeSummaryView() { InitializeComponent(); } internal BikeSummaryViewModel VM { get { return ViewModel as BikeSummaryViewModel; } } }  Since this is a reserved keyword, Catel will automatically take care of the change notifications and x:Bind can be used directly against VM:\n\u0026lt;TextBlock Text=\u0026quot;{x:Bind VM.Title}\u0026quot; /\u0026gt;  Note that the binding should either be set to Mode=OneWay per binding or for all bindings in a view by specifying x:DefaultBindMode=\u0026quot;OneWay\u0026quot;.\nCast every compiled bindings Another option is to use casts everywhere in the view:\n\u0026lt;TextBlock Text=\u0026quot;{x:Bind ((vm:BikeSummaryView)VM).Title}\u0026quot; /\u0026gt;  "},{"uri":"https://docs.catelproject.com/vnext/catel-core/validation/","title":"Validation","tags":[],"description":"","content":" The `ViewModelBase` derives from `ModelBase`, thus all information here also applies to the `ViewModelBase`  Validation is very important for data objects. Therefore, the ModelBase supports all kinds of different validation:\n Internal validation via the ValidateFields and ValidateBusinessRules methods Validation via data annotations (attributes) External validators using the IValidatorProvider and IValidator interfaces  The validation results are cached and only executed when a property changes (the object becomes dirty) or when the validation is forced.\n Validation via validate methods   Validation via data annotations   Validation via special model validators   Validation via IValidator   Using the validation context   Getting a summary of validation results   Deferring validation   Different types of validation There are two different types of validation in Catel, namely warnings and errors. There are also two flavors of validations, namely field validation and business rule validation.\nOrder of execution of events The order of execution is very important if you want to perform very advanced validation (such as translating validations at the end of each validation sequence).\n IValidator.BeforeValidation OnValidation (raises Validating event) if not already validated IValidator.BeforeValidateFields OnValidatingFields (raises the ValidatingFields event) IValidator.ValidateFields ValidateFields OnValidatedFields (raises the ValidatedFields event) IValidator.AfterValidateFields IValidator.BeforeValidateBusinessRules OnValidatingBusinessRules (raises the ValidatingBusinessRules event) IValidator.ValidateBusinessRules ValidateBusinessRules OnValidatedBusinessRules (raises the ValidatedBusinessRules event) IValidator.AfterValidateBusinessRules end if not already validated OnValidated (raises the Validated event) IValidator.AfterValidation  There are lots of events, and it may seem complex and confusing at first sight. However, all these events give developers the opportunity to hook into the validation sequence at any time.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/validation-controls/","title":"Validation controls","tags":[],"description":"","content":" There are some very important controls in Catel which help with visualizing the validation results.\nInfoBarMessageControl Ever wanted to show the details of error messages to your end-users? Then, the InfoBarMessageControl is the control to use! The control shows a summary of all business and field errors provided by bindings on objects that implement the IDataErrorInfo interface.\nIn combination with the WarningAndErrorValidator control, the InfoBarMessageControl can even show field and business warnings for objects that implement the IDataWarningInfo interface that ships with Catel.\n\u0026lt;catel:InfoBarMessageControl\u0026gt; \u0026lt;!-- Actual content here --\u0026gt; \u0026lt;/catel:InfoBarMessageControl\u0026gt;  The InfoBarMessageControl subscribes to the Validation class. This class is responsible for showing the red border around the controls that WPF shows by default. Then, it requests the actual field error property of the data item. This is added to an internal collection of error messages, and therefore the control is able to show the errors of all bindings.\nWhen the WarningAndErrorValidator control is found as a child control, the InfoBarMessageControl also subscribes to the events exposed by the WarningAndErrorValidator. The internal working of that control is explained later in this article. When a data object is subscribed via the WarningAndErrorValidator, the InfoBarMessageControl will also handle the warnings and business errors of that data object.\nWarningAndErrorValidator The WarningAndErrorValidator control is not visible to the end user. The only thing this control takes care of is to forward business errors and warnings to controls that are interested in them. The only control that ships with Catel is the InfoBarMessageControl. Thanks to the WarningAndErrorValidator, the InfoBarMessageControl is able to show business errors and warnings to the end user.\n\u0026lt;catel:WarningAndErrorValidator Source=\u0026quot;{Binding MyObject}\u0026quot; /\u0026gt;  The WarningAndErrorValidator needs to be placed inside an InfoBarMessageControl. The control then subscribes to all property changed events to make sure it receives all change notifications. Then, on every property change, the control checks whether the sender either implements the IDataErrorInfo or IDataWarningInfo interfaces.\nWhen an error or warning is found on the changed property, the control invokes the corresponding events so the InfoBarMessageControl can show the right information. When an error or warning no longer exists in a model, a Removed event is invoked so the InfoBarMessageControl knows that the error or warning should be removed from the summary.\nStyling in DataWindow A InfoBarMessageControl is automatically added to the DataWindow, if you want to use a different style for this InfoBarMessageControl, you must override the default style, add your own InfoBarMessageControl and disable the default InfoBarMessageControl from the DataWindow.\n Create a custom style based on the default style. Change the x:Key from x:Key=\u0026ldquo;{x:Type local:InfoBarMessageControl}\u0026rdquo; to x:Key=\u0026ldquo;yourCustomStyleKey\u0026rdquo; Set the InfoBarMessageControlGenerationMode to None\n /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;DataWindow\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;viewModel\u0026quot;\u0026gt;The view model to inject.\u0026lt;/param\u0026gt; /// \u0026lt;remarks\u0026gt; /// This constructor can be used to use view-model injection. /// \u0026lt;/remarks\u0026gt; public DataWindow(DataWindowViewModel viewModel) : base(viewModel, DataWindowMode.Custom, null, DataWindowDefaultButton.None, true, InfoBarMessageControlGenerationMode.None) { InitializeComponent(); }  Add a new InfoBarMessageControl as root control to your DataWindow and set the style.\n\u0026lt;catel:InfoBarMessageControl Style=\u0026quot;{DynamicResource yourCustomStyleKey}\u0026quot;\u0026gt; \u0026lt;Grid\u0026gt; \u0026lt;catel:WarningAndErrorValidator Source=\u0026quot;{Binding}\u0026quot; /\u0026gt; //Your content \u0026lt;/Grid\u0026gt; \u0026lt;/catel:InfoBarMessageControl\u0026gt;   "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/view-models/validation-in-view-models/","title":"Validation in view models","tags":[],"description":"","content":" Validation is very important to provide both feedback to the user, but also to make sure that no invalid data reaches the model or database. Catel offers several ways to implement validation. All options are described in this part of the documentation.\nValidation in models via mappings The best way is to put validation into a model. Most model objects nowadays implement INotifyPropertyChanged and IDataErrorInfo, the most important classes that are required to use mappings from/to a model inside a view model.\nThe great advantage of mapping properties from/to models automatically using Catel is that you don\u0026rsquo;t have to write lots of plumbing yourself (getting and setting values in the model and view model). However, if the model implements INotifyPropertyChanged and *IDataErrorInfo, Catel also automatically uses the validation from the model. For example, if there is aPersonmodel that checks if theFirstNameandLastName` are entered, why rewrite this validation again in the view model?\nThere are two ways to use automatic mappings.\nMapping via ViewModelToModelAttribute Mapping a model property by using the ViewModelToModelAttribute requires the definition of a model property and a separate property per mapped property. The code below automatically maps the FirstName property.\n/// \u0026lt;summary\u0026gt; /// Gets or sets the person. /// \u0026lt;/summary\u0026gt; [Model] public Person Person { get { return GetValue\u0026lt;Person\u0026gt;(PersonProperty); } private set { SetValue(PersonProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Person property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData PersonProperty = RegisterProperty(\u0026quot;Person\u0026quot;, typeof(Person)); /// \u0026lt;summary\u0026gt; /// Gets or sets the first name. /// \u0026lt;/summary\u0026gt; [ViewModelToModel(\u0026quot;Person\u0026quot;)] public string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FirstName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FirstNameProperty = RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string));  If the Person.FirstName provides an error via the IDataErrorInfo interface, it will automatically be exposed by the view model as well.\nMapping via ExposeAttribute Mapping a property via the ExposeAttribute is even more simple, but has some disadvantages. First, let\u0026rsquo;s talk about the disadvantages before showing the code:\n Catel uses the ICustomTypeDescriptor interface to implement this behavior, and the interface is only available in WPF. The properties are not actually created, so you cannot use them inside your view model as real properties.  In other words, the ExposeAttribute is only very useful if 1) you are using WPF and 2) if the property is not used inside the view model but only declared to protect the model from the outside world. If both of these constraints are true, then the ExposeAttribute is definitely worth taking a look at. The usage is very simple:\n/// \u0026lt;summary\u0026gt; /// Gets or sets the person. /// \u0026lt;/summary\u0026gt; [Model] [Expose(\u0026quot;FirstName\u0026quot;)] [Expose(\u0026quot;MiddleName\u0026quot;)] [Expose(\u0026quot;LastName\u0026quot;)] private Person Person { get { return GetValue\u0026lt;Person\u0026gt;(PersonProperty); } set { SetValue(PersonProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the Person property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData PersonProperty = RegisterProperty(\u0026quot;Person\u0026quot;, typeof(Person));  Simply declare the model property and decorate it with one or multiple ExposeAttribute instances. Not only are the properties automatically available for binding, the view model also checks for errors and automatically maps these as well.\nValidation in view models Until now, we only spoke about automatic validation for validation that was written in the model. However, sometimes it is required to write validation inside the view model as well. One reason might be that the model is a POCO object not providing any validation. Or, sometimes there is a logical error that has nothing to do with the model, but should be shown to the user anyway.\nIn such a case, Catel offers lots of possibilities to write custom validation inside the view model. Below are the possibilities:\n Field warnings Field errors Business rule warnings Business rule errors  The difference between a field and business rule is that a field error or warning is specific for a property. These are returned via IDataErrorInfo[\u0026quot;propertyName\u0026quot;]. A business rule is a rule that applies to multiple fields or even a whole entity. Business rule validations are returned via IDataErrorInfo.Error.\nTo implement validation into a view model, only two methods need to be implemented. Catel clearly separates the field validation from the business rule validation to make it much clearer to the developer what is going on.\nValidating fields To validate fields, one should override the ValidateFields method. Below is an example of field validation on a view model:\n/// \u0026lt;summary\u0026gt; /// Validates the field values of this object. Override this method to enable /// validation of field values. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results, add additional results to this list.\u0026lt;/param\u0026gt; protected override void ValidateFields(List\u0026lt;IFieldValidationResult\u0026gt; validationResults) { if (!string.IsNullOrEmpty(FirstName)) { validationResults.Add(FieldValidationResult.CreateError(FirstNameProperty, \u0026quot;First name cannot be empty\u0026quot;)); } }  Validating business rules To validate business rules, one should override the ValidateBusinessRules method. Below is an example of business rule validation on a view model:\n/// \u0026lt;summary\u0026gt; /// Validates the field values of this object. Override this method to enable /// validation of field values. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results, add additional results to this list.\u0026lt;/param\u0026gt; protected override void ValidateBusinessRules(List\u0026lt;IBusinessRuleValidationResult\u0026gt; validationResults) { if (SomeBusinessErrorOccurs) { validationResults.Add(BusinessRuleValidationResult.CreateError(\u0026quot;A business error occurred\u0026quot;)); } }  Translating model validation in the view model Thanks to the validation system in Catel, it is very easy to implement very advanced validation features in view models. The example below shows how to translate errors that are added to a model in the Data Access Layer or validation layer. Assume that the following pseudo code is used to set an error on a model in the DAL:\nSetFieldError(“FirstName”, “FirstNameRequired”);  All errors that are mapped from the model to the view model automatically are available in the validationResults parameter. This way, the error can be easily translated:\n/// \u0026lt;summary\u0026gt; /// Validates the field values of this object. Override this method to enable /// validation of field values. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;validationResults\u0026quot;\u0026gt;The validation results, add additional results to this list.\u0026lt;/param\u0026gt; protected override void ValidateFields(List\u0026lt;IFieldValidationResult\u0026gt; validationResults) { foreach (var validationResult in validationResults) { if (validationResult.Message == \u0026quot;FirstNameRequired\u0026quot;) { validationResult.Message = Properties.Resources.FirstNameRequired; } } }  Of course this is not something you want to actually do in your view model, so you’ll probably have to write a helper class that translates the validation for you. You might or might not like delaying the translation of the model errors to as close as the view, but it shows how extremely powerful the improved validation of Catel is. And if you think a bit about it, wouldn\u0026rsquo;t it be a good idea to delay the translation from the server to the actual client to as close as the view…?\nValidating via annotations Some people like to add validation to their (view)models using annotations (attributes). Catel also supports this method, but adds additional functionality. The idea behind it is that in the end, Catel always provides all errors of an object via the IDataErrorInfo interface. This means that when attribute validation is used, the errors are internally registered and provided in the ValidateFields method. This way, all types of validation that are provided by the .NET framework are gathered into one single location where they can be used by the view.\n/// \u0026lt;summary\u0026gt; /// Gets or sets the first name. /// \u0026lt;/summary\u0026gt; [Required(\u0026quot;This value is required\u0026quot;)] private string FirstName { get { return GetValue\u0026lt;string\u0026gt;(FirstNameProperty); } set { SetValue(FirstNameProperty, value); } } /// \u0026lt;summary\u0026gt; /// Register the FirstName property so it is known in the class. /// \u0026lt;/summary\u0026gt; public static readonly PropertyData FirstNameProperty= RegisterProperty(\u0026quot;FirstName\u0026quot;, typeof(string));  To validate required fields or not to validate required fields at startup Catel does not validate the properties with data annotations at startup. It will only validate the data annotations when properties change or when the view model is about to be saved. This is implemented this way to allow a developer to show required fields with an asterisk (*) instead of errors. If a developer still wants to initially display errors, only a single call has to be made in the constructor:\nValidate(true, false);  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/vibrate-service/","title":"VibrateService","tags":[],"description":"","content":" The IVibrateService allows a developer to start and stop vibration of the device via a service.\nStarting vibration To start the vibration, use the following code (will vibrate for 250 ms). Note that the time span must be between 0 and 5 seconds.\nvar dependencyResolver = this.GetDependencyResolver(); var vibrateService = dependencyResolver.Resolve\u0026lt;IVibrateService\u0026gt;(); vibrateService.Start(new TimeSpan(0, 0, 0, 0, 250);  Stopping the vibration earlier than initially planned By default, the vibration stops automatically after the specified time span has passed. However, it is possible to stop the vibration manually.\nvar dependencyResolver = this.GetDependencyResolver(); var vibrateService = dependencyResolver.Resolve\u0026lt;IVibrateService\u0026gt;(); vibrateService.Stop();  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/view-models/","title":"View models","tags":[],"description":"","content":"The view model is a very important part in the MVVM pattern. The view model is responsible for the actual logic that ensures separation of concerns, but also allows unit testing on the view logic (which is implemented in the view model) without actually instantiating the views.\nLike almost every other MVVM framework, the base class for all View-Models is ViewModelBase. This base class is derived from the ModelBase class explained earlier in this article, which gives the following advantages:\n Dependency property a-like property registration; Automatic change notification; Support for field and business errors.  Because the class derives from ModelBase, you can simply add field and business errors that are automatically being reflected to the UI. Writing View-Models has never been so easy!\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/view-models/advanced/","title":"View models (advanced)","tags":[],"description":"","content":" Controlling the instantiation of view models   Exposing properties of a model automatically   Keeping view models alive   "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/services/view-export-service/","title":"ViewExportService","tags":[],"description":"","content":" The IViewExportService allows a developer to export a specific view that belongs to a view model to the clipboard, a file or a printer.\nExporting a view To export a view, use the following code:\nvar dependencyResolver = this.GetDependencyResolver(); var viewExportService = dependencyResolver.Resolve\u0026lt;IViewExportService\u0026gt;(); viewExportService.Export(myViewModel, ExportMode.File);  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/view-locator/","title":"ViewLocator","tags":[],"description":"","content":" The IViewLocator class is responsible for resolving the right views for a view model. Before Catel 3.0, the IUIVisualizerService was responsible for resolving the view, but this responsibility is now taken over by the IViewLocator. The UIVisualizerService internally uses the IViewLocator to resolve the views. Resolving by naming convention It is possible to resolve views using the IViewLocator. Then you can use the ResolveView method to resolve the view based on the type of the view model.\nFor example, the following view model:\nCatel.Examples.ViewModels.MyViewModel  will be resolved as:\nCatel.Examples.Views.MyView  Manually resolving a view using naming convention To manually resolve a view using naming convention, use the following code:\nvar viewLocator = ServiceLocator.Default.ResolveType\u0026lt;IViewLocator\u0026gt;(); var viewType = viewLocator.ResolveView(typeof(MyViewModel));  Customizing naming conventions By default, the IViewLocator uses the following naming conventions to resolve views:\n [UP].Views.[VM] [UP].Views.[VM]View [UP].Views.[VM]Control [UP].Views.[VM]Window [UP].Views.[VM]Page [UP].Views.[VM]Activity [UP].Views.[VM]Fragment [UP].Controls.[VM] [UP].Controls.[VM]Control [UP].Pages.[VM] [UP].Pages.[VM]Page [UP].Windows.[VM] [UP].Windows.[VM]Window [AS].Views.[VM] [AS].Views.[VM]View [AS].Views.[VM]Control [AS].Views.[VM]Page [AS].Views.[VM]Window [AS].Views.[VM]Activity [AS].Views.[VM]Fragment [AS].Controls.[VM] [AS].Controls.[VM]Control [AS].Pages.[VM] [AS].Pages.[VM]Page [AS].Windows.[VM] [AS].Windows.[VM]Window [AS].Activities.[VM] [AS].Activities.[VM]Activity [AS].Fragments.[VM] [AS].Fragments.[VM]Fragment [AS].UI.Views.[VM] [AS].UI.Views.[VM]View [AS].UI.Views.[VM]Control [AS].UI.Views.[VM]Page [AS].UI.Views.[VM]Window [AS].UI.Views.[VM]Activity [AS].UI.Views.[VM]Fragment [AS].UI.Controls.[VM] [AS].UI.Controls.[VM]Control [AS].UI.Pages.[VM] [AS].UI.Pages.[VM]Page [AS].UI.Windows.[VM] [AS].UI.Windows.[VM]Window [AS].UI.Activities.[VM] [AS].UI.Activities.[VM]Activity [AS].UI.Activities.[VM]Fragment [CURRENT].[VM]View [CURRENT].[VM]Control [CURRENT].[VM]Page [CURRENT].[VM]Window [CURRENT].[VM]Activity [CURRENT].[VM]Fragment  For more information about naming conventions, see [Naming conventions](/vnext/catel-mvvm/locators-naming-conventions/naming-conventions/)  However, it is possible to add or remove new naming conventions to support your own naming convention. For example, to add a new naming convention for a different assembly, use this code:\nvar viewLocator = ServiceLocator.Default.ResolveType\u0026lt;IViewLocator\u0026gt;(); viewLocator.NamingConventions.Add(\u0026quot;MyCustomAssembly.Views.[VM]View\u0026quot;);  Registering custom views Sometimes, a class doesn\u0026rsquo;t follow a naming convention (for whatever reason possible). In such a case, it is possible to register a mapping manually using the following code:\nvar viewLocator = ServiceLocator.Default.ResolveType\u0026lt;IViewLocator\u0026gt;(); viewLocator.Register(typeof(MyViewModelNotFollowingNamingConvention), typeof(MyView));  Using a custom ViewLocator If you want to have total freedom to determine which view is provided per view model (maybe there are other services that have an impact on this), it is possible to create a custom IViewLocator implementation. Then the only thing to do is to register it using the following code:\nServiceLocator.Default.RegisterType\u0026lt;IViewLocator, MyViewLocator\u0026gt;();  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/view-model-locator/","title":"ViewModelLocator","tags":[],"description":"","content":" Starting with Catel 3.0, there are several ways to hook up a view model to the view. When a view is constructed, an MVVM behavior is added to the view. Thanks to these MVVM behaviors, it is possible to use exactly the same logic on 3rd party controls.\nNote that the while using the conventions, magic words such as \"View\", \"Control\", \"UserControl\", \"Window\" and \"Page\" will be stripped from the view name while locating the view model type  Resolving by naming convention If the GetViewModelType method returns null (which is the default behavior), the view will resolve the IViewModelLocator from the ServiceLocator. Then it will use the ResolveViewModel method to resolve the view model based on the type of the view.\nFor example, the following view:\nCatel.Examples.Views.MyView  will be resolved as:\nCatel.Examples.ViewModels.MyViewModel  Manually resolving a view model using naming convention To manually resolve a view model using naming convention, use the following code:\nvar viewModelLocator = ServiceLocator.Default.ResolveType\u0026lt;IViewModelLocator\u0026gt;(); var viewModelType = viewModelLocator.ResolveViewModel(typeof(MyView));  Customizing naming conventions By default, the IViewModelLocator uses the following naming conventions to resolve view models:\n [UP].ViewModels.[VW]ViewModel [UP].ViewModels.[VW]ControlViewModel [UP].ViewModels.[VW]WindowViewModel [UP].ViewModels.[VW]PageViewModel [UP].ViewModels.[VW]ActivityViewModel [UP].ViewModels.[VW]FragmentViewModel [AS].ViewModels.[VW]ViewModel [AS].ViewModels.[VW]ControlViewModel [AS].ViewModels.[VW]WindowViewModel [AS].ViewModels.[VW]PageViewModel [AS].ViewModels.[VW]ActivityViewModel [AS].ViewModels.[VW]FragmentViewModel [CURRENT].[VW]ViewModel [CURRENT].[VW]ControlViewModel [CURRENT].[VW]WindowViewModel [CURRENT].[VW]PageViewModel [CURRENT].[VW]ActivityViewModel [CURRENT].[VW]FragmentViewModel  For more information about naming conventions, see [Naming conventions](/vnext/catel-mvvm/locators-naming-conventions/naming-conventions/)  However, it is possible to add or remove new naming conventions to support your own naming convention. For example, to add a new naming convention for a different assembly, use this code:\nvar viewModelLocator = ServiceLocator.Default.ResolveType\u0026lt;IViewModelLocator\u0026gt;(); viewModelLocator.NamingConventions.Add(\u0026quot;MyCustomAssembly.ViewModels.[VW]ViewModel\u0026quot;);  Registering custom view models Sometimes, a class doesn\u0026rsquo;t follow a naming convention (for whatever reason possible). In such a case, it is possible to register a mapping manually using the following code:\nvar viewModelLocator = ServiceLocator.Default.ResolveType\u0026lt;IViewModelLocator\u0026gt;(); viewModelLocator.Register(typeof(MyViewNotFollowingNamingConvention), typeof(MyViewModel));  Using a custom ViewModelLocator If you want to have total freedom to determine which view model is provided per view (maybe there are other services that have an impact on this), it is possible to create a custom IViewModelLocator implementation. Then the only thing to do is to register it using the following code:\nServiceLocator.Default.Register\u0026lt;IViewModelLocator, MyViewModelLocator\u0026gt;();  Using a generic implementation of the view Last but not least, it is still possible to use the \u0026ldquo;old-fashioned\u0026rdquo; way by using the generic view bases. These classes directly derive from the non-generic views and return the generic type definition of the view model using the GetViewModelType method.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/","title":"Views","tags":[],"description":"","content":" Xamarin.Android   Xamarin.Forms   Xamarin.iOS   XAML   "},{"uri":"https://docs.catelproject.com/vnext/catel-core/preventing-memory-leaks/weak-events/","title":"Weak events","tags":[],"description":"","content":" You have probably heard about weak events before. This documentation is not about the issue of the cause of weak events, there are lots of articles about that. This documentation writes about the solution, which is the WeakEventListener. Shortly said, when you do this in every class (just for the sake of explaining the problem, don’t start thinking this code has no business value):\nvar log = Log.Instance; log.LogReceived += OnLogReceived;  As you can see, the log is a singleton, so there is only one living instance of the Log class. It will probably live as long as the app itself. Now you might be thinking: what’s wrong with this code? Nothing, until the app starts growing and growing and your users start complaining about memory issues.\nWhat happens here is that you subscribe to the LogReceived event of the Log class. This subscription contains 2 things:\n What class do I need to call (null for static, otherwise the instance of the class) What method do I need to call  So, in fact now the Log class knows about the instance of the class that just subscribed to it and holds a reference to it (how else can it deliver the event, if it doesn’t know the address). Thus, the classes that subscribe to the Log and that do no unsubscribe will never be collected by the garbage collection.\nOpen instance delegates The key feature behind this implementation of the weak event pattern is open instance delegates. You are probably wondering: what the hell are open instance delegates? Well, good question, and I will try to explain it. An open instance delegate is just as a regular delegate, it points to the method of a specific class, but the biggest difference is that it does not bind to a specific instance. This means that it can be described as: I know you live on that street (method), but I have not clue in which city (instance) that is. The instance can be specified later. The delegate for a regular event handler looks like this:\npublic delegate void OpenInstanceHandler(TTarget @this, object sender, TEventArgs e);  The @this is nothing special, it allows us to use the this keyword so everyone knows that the target should be passed there. As you can see, it contains 3 parameters. The first one is the target (the city), the second and third parameters are the parameters of the regular event handler.\nWeak references The weak event listener creates an open instance delegate and stores both the source and target in a WeakReference class. As soon as one of these references are no longer valid, the class is unbound. The good side of this approach is that this weak event listener does not leak when the event never fires.\nWhat does it support The following use cases are supported:\n Instance source (event) and instance target (handler) Static source (event) and instance target (handler) Instance source (event) and static target (handler)  So, actually it handles everything that can cause a memory leak via event subscriptions!\nWhat does it not support and what are the downsides This weak event listener follows the rules of the .NET framework. So, it cannot subscribe to private events. If you want private events, do your own hacking (the source is available, you only have to change the DefaultEventBindingFlags at the top of the class).\nThere are a few downsides about using a weak event listeners in general:\n It’s notation is ugly, the “original” .NET way looks way better You have to name the event by string, that sucks (if you know a better way, contact me!) It can only handle events with a handler of EventHandler\u0026lt;TEventArgs\u0026gt; You become a lazy developer not caring about subscriptions  How to use There are 4 categories of event subscriptions, all described below.\nInstance to instance This is the situation where an instance target subscribes to an instance event. The events are unbound as soon as either the target or source are collected.\nvar source = new EventSource(); var listener = new EventListener(); var weakEventListener = WeakEventListener\u0026lt;EventListener, EventSource, EventArgs\u0026gt;.SubscribeToWeakEvent(listener, source, \u0026quot;PublicEvent\u0026quot;, listener.OnPublicEvent);  Instance to static This is the situation where a static target subscribes to an instance event. The events are unbound as soon as the source is collected.\nvar source = new EventSource(); var weakEventListener = WeakEventListener\u0026lt;EventListener, EventSource, EventArgs\u0026gt;.SubscribeToWeakEvent(null, source, \u0026quot;PublicEvent\u0026quot;, EventListener.OnEventStaticHandler);  Static to instance This is the situation where an instance target subscribes to a static event. The events are unbound as soon as the target is collected.\nvar listener = new EventListener(); var weakEventListener = WeakEventListener\u0026lt;EventListener, EventSource, EventArgs\u0026gt;.SubscribeToWeakEvent(listener, null, \u0026quot;StaticEvent\u0026quot;, listener.OnPublicEvent);  Static to static This is not supported because you shouldn’t be using a weak event listener here. Static events with static event handlers simply cannot cause memory leaks because both the source and the target have no instance. However, it might be possible that you subscribe to an event too many times and the event fires too many times. But again, no memory issues here.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/window-and-datawindow/","title":"Window and DataWindow","tags":[],"description":"","content":" Introduction to the Window The Window is a simplified class representing the same logic as the regular System.Windows.Window but with the binding support of Catel.\nIntroduction to the DataWindow When developing software in XAML, most developers always need the following three types of windows:\n OK / Cancel buttons for data windows; OK / Cancel / Apply buttons for application settings / options; Close button on windows for action windows.  Creating these windows is just boring and the steps are always the same:\nThe DataWindow class makes it much easier to create these basic windows, simply by specifying the mode of the Window. By using this window, you can concentrate on the actual implementation and you don’t have to worry about the implementation of the buttons itself, which saves you time! Using the DataWindow in MVVM The easiest object to use with the MVVM Framework is the DataWindow class. The DataWindow takes fully care of the construction of the view models and the validation of the view models.\nThe usage of the DataWindow class is very simple, once you know how to do it. First of all, you will have to specify the base class in the xaml file like shown below:\n\u0026lt;catel:DataWindow x:Class=\u0026quot;Catel.Articles._03___MVVM.Examples.DataWindow.PersonWindow\u0026quot; xmlns=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0026quot; xmlns:x=\u0026quot;http://schemas.microsoft.com/winfx/2006/xaml\u0026quot; xmlns:catel=\u0026quot;http://schemas.catelproject.com\u0026quot;\u0026gt; \u0026lt;!-- Content left out for the sake of simplicity --\u0026gt; \u0026lt;/catel:DataWindow\u0026gt;  As you can see, one thing has changed in regard to a “normal” window definition:\n The type definition has changed from Window to catel:DataWindow;  The code-behind is even simpler:\n/// \u0026lt;summary\u0026gt; /// Interaction logic for PersonWindow.xaml /// \u0026lt;/summary\u0026gt; public partial class PersonWindow : DataWindow { /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026quot;PersonWindow\u0026quot;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;viewModel\u0026quot;\u0026gt;The view model.\u0026lt;/param\u0026gt; public PersonWindow(PersonViewModel viewModel) : base(viewModel) { InitializeComponent(); } }  The code above is everything you will need when using the MVVM Framework of Catel. The easiest way to create a new DataWindow is to use item templates\nConstruction of view models There are multiple ways to construct a window with a view model. There are three options that you have to construct a view model:\n Constructor with view model This is the best option you can use. This way, it is possible to inject view models into the data window. Constructor with model It is possible to save a developer from creating a view model manually by accepting a model as input. Then, the data window will have to construct the view model manually and pass it through to its base constructor. Empty constructor If you use an empty constructor, the developer will have to set the data context manually. This something you really should avoid. But hey, it’s all up to you.  Automatic validation The cool thing about the DataWindow is that it automatically wraps the content that a developer defines into an InfoBarMessageControl. This way, errors and warnings are shown at the top of the window. Another feature of the DataWindow is that it automatically creates a WarningAndErrorValidator control and sets the view model as source. This way, all the warnings of the view model are also shown in the InfoBarMessageControl. In other words: you don’t have to do anything to implementation validation, except for actually setting the warnings and errors in your view model. And if the validation takes place in the model, you can use the ViewModelToModelAttribute so you don’t have to worry about that either.\nCustomizing the buttons It is possible to use custom buttons and still be able to use the DataWindow.\n First, use the base constructor to specify that you want to use custom mode.\n/// \u0026lt;summary\u0026gt; /// Upload window. /// \u0026lt;/summary\u0026gt; public class UploadWindow : DataWindow { public UploadWindow() : base(DataWindowMode.Custom) { InitializeComponent(); } }  Add the custom buttons. This must be done before the call to InitializeComponent.\n/// \u0026lt;summary\u0026gt; /// Upload window. /// \u0026lt;/summary\u0026gt; public class UploadWindow : DataWindow { public UploadWindow() : base(DataWindowMode.Custom) { AddCustomButton(new DataWindowButton(\u0026quot;Upload\u0026quot;, \u0026quot;Upload\u0026quot;)); InitializeComponent(); } }   Styling the DataWindow Starting with Catel 2.4, the DataWindow has its own styles. These are located in DataWindow.generic.xaml. Below is a table that contains the available styles and a short description.\n   Style key Description     DataWindowStyle The actual window style which can be used to decorate or customize the window itself.   DataWindowButtonContainerStyle The container that is used for the buttons. This is a WrapPanel, so the styles must match that.   DataWindowButtonStyle The style for the buttons. By default, the buttons are right aligned and have a fixed size.    Closing the DataWindow with the Escape key The DataWindow can be configured to close with the Escape key using the CanCloseUsingEscape dependency property (default true). This is useful for when DataWindow is used in e.g. dialogs. When used as the main window, it is advised to set CanCloseUsingEscape=False, as the user can inadvertedly close the application by pressing the Escape key.\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xamarin-android/","title":"Xamarin.Android","tags":[],"description":"","content":" Note that this guide is not a full Android development guide. It will cover the basics though.  Bindings Unfortunately Android does not have a powerful binding system like XAML does. Therefore it is required to manually synchronize data from the view to the view model and back or to use the binding system in Catel.\nBinding properties [Activity] public class SecondActivity : Catel.Android.App.Activity { private PersonView _personView; protected override void OnCreate(Bundle bundle) { base.OnCreate(bundle); // Set our view from the \u0026quot;main\u0026quot; layout resource SetContentView(Resource.Layout.Page_Second); _personView = FragmentManager.FindFragmentById\u0026lt;PersonView\u0026gt;(Resource.Id.PersonView); } protected override void AddBindings(BindingContext bindingContext, IViewModel viewModel) { var vm = (SecondViewModel) viewModel; bindingContext.AddBinding(() =\u0026gt; vm.Title, () =\u0026gt; Title); bindingContext.AddBinding(() =\u0026gt; vm.Person, () =\u0026gt; _personView.DataContext); } }  Binding properties with events public class PersonView : Catel.Android.App.Fragment { private EditText _firstNameEditText; private EditText _lastNameEditText; private TextView _lastNameMirrorTextView ; public override View OnCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { var inflateResult = inflater.Inflate(Resource.Layout.Fragment_Person, container, false); return inflateResult; } public override void OnResume() { _firstNameEditText = Activity.FindViewById\u0026lt;EditText\u0026gt;(Resource.Id.firstNameText); _lastNameEditText = Activity.FindViewById\u0026lt;EditText\u0026gt;(Resource.Id.lastNameText); _lastNameMirrorTextView = Activity.FindViewById\u0026lt;TextView\u0026gt;(Resource.Id.lastNameMirrorTextView); base.OnResume(); } protected override void AddBindings(BindingContext bindingContext, IViewModel viewModel) { var vm = (PersonViewModel)viewModel; bindingContext.AddBinding(() =\u0026gt; vm.FirstName, () =\u0026gt; _firstNameEditText.Text).AddTargetEvent(\u0026quot;TextChanged\u0026quot;); bindingContext.AddBinding(() =\u0026gt; vm.LastName, () =\u0026gt; _lastNameEditText.Text).AddTargetEvent(\u0026quot;TextChanged\u0026quot;); bindingContext.AddBinding(() =\u0026gt; vm.LastName, () =\u0026gt; _lastNameMirrorTextView.Text, BindingMode.OneWay); } }  Binding properties with converters protected override void AddBindings(BindingContext bindingContext, IViewModel viewModel) { var vm = (MainViewModel)viewModel; bindingContext.AddBindingWithConverter\u0026lt;ClicksConverter\u0026gt;(() =\u0026gt; vm.Counter, () =\u0026gt; _testButton.Text, BindingMode.OneWay); }  Binding commands  protected override void AddBindings(BindingContext bindingContext, IViewModel viewModel) { var vm = (MainViewModel)viewModel; bindingContext.AddCommandBinding(_testButton, \u0026quot;Click\u0026quot;, vm.RunCommand); }  "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xamarin-forms/","title":"Xamarin.Forms","tags":[],"description":"","content":"This documentation still needs to be written, feel free to help us out!\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xamarin-ios/","title":"Xamarin.iOS","tags":[],"description":"","content":"This documentation still needs to be written, feel free to help us out!\n"},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/","title":"XAML","tags":[],"description":"","content":" XAML - advanced   XAML - external controls   Customizing DataContext subscription behavior   Improving performance by defining the view model grid manually   UserControl   UserControl Resources   Validation controls   Window and DataWindow   "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/advanced/","title":"XAML - advanced","tags":[],"description":"","content":" DataWindow - under the hood   UserControl - under the hood   "},{"uri":"https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/external-controls/","title":"XAML - external controls","tags":[],"description":"","content":" Using a custom control   Using a custom window   "},{"uri":"https://docs.catelproject.com/vnext/catel-core/serialization/supported-serializers/xml/","title":"Xml","tags":[],"description":"","content":"The xml serializer uses the DataContractSerializer from .NET to serialize the object graphs.\n"}]