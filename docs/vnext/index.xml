<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Catel Documentation on Catel docs</title><link>https://docs.catelproject.com/vnext/</link><description>Recent content in Catel Documentation on Catel docs</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://docs.catelproject.com/vnext/index.xml" rel="self" type="application/rss+xml"/><item><title>Caveats in WPF</title><link>https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-wpf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-wpf/</guid><description>Below are all caveats in WPF.
Know caveats? Feel free to add them!</description></item><item><title>Creating the WPF project</title><link>https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-project/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-project/</guid><description>In this step we will create the project and add the relevant NuGet packages.
This guide uses the on-line templates that are available in the Visual Studio gallery. If you can&#39;t find the templates on-line, please download them [here](http://www.catelproject.com/download/general-files/). Creating the project To create the project, start Visual Studio and choose File =&amp;gt; New Project&amp;hellip; Then switch to the on-line template section as you can see in the screenshot below and search for Catel:</description></item><item><title>Creating the Xamarin.Forms project</title><link>https://docs.catelproject.com/vnext/getting-started/xamarin-forms/creating-the-project/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/getting-started/xamarin-forms/creating-the-project/</guid><description>In this step we will create the project and add the relevant NuGet packages.
This documentation is work in progress</description></item><item><title>Customizing the serialization engines</title><link>https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/customizing-serialization-engines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/customizing-serialization-engines/</guid><description>Since the SerializerBase does all the heavy lifting, it is very easy to customize the behavior of an existing serializer or create a completely new one. Each serializer implements its own interface and are registered in the *ServiceLocator *using the following interfaces:
XmlSerializer =&amp;gt; IXmlSerializer BinarySerializer =&amp;gt; IBinarySerializer To customize a serializer, derive from an existing class and customize a method. The serializer below makes sure that specific members are never serialized.</description></item><item><title>Different interpretations of MVVM</title><link>https://docs.catelproject.com/vnext/introduction/mvvm/different-interpretations-of-mvvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/introduction/mvvm/different-interpretations-of-mvvm/</guid><description>There are two different interpretations of MVVM, the &amp;ldquo;purist&amp;rdquo; way where the model is protected, or the &amp;ldquo;shortcut&amp;rdquo; way where the view model only provides the instance of the model and the view then binds directly to the model.
Shortcut interpretation This is what most people do. The view model implements the model, and then provides the model to the view. The view then binds directly to the model.</description></item><item><title>General</title><link>https://docs.catelproject.com/vnext/faq/general/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/faq/general/</guid><description/></item><item><title>MessageBase</title><link>https://docs.catelproject.com/vnext/catel-core/messaging/messagebase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/messaging/messagebase/</guid><description>The MessageMediator is a very powerful class to send messages to other objects inside an application. However, it can sometimes by cumbersome to register and create messages. Therefore the MessageBase class is a very nice convenience class to create messages and allow easier registration.
The MessageBase provides the following additional functionality out of the box:
Send messages with data without instantiating a message Register message handlers Unregister message handlers Creating messages based on the MessageBase  It is very easy to create a new message.</description></item><item><title>ObservableObject</title><link>https://docs.catelproject.com/vnext/catel-core/data-handling/observableobject/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/data-handling/observableobject/</guid><description>The ObservableObject is a very lightweight class that only implements the INotifyPropertyChanging and INotifyPropertyChanged interfaces. This class is ideal for simple objects that only need property notification. Below is an example:
public class Person : ObservableObject { private string _firstName; private string _middleName; private string _lastName; public Person(string firstName, string middleName, string lastName) { FirstName = firstName; MiddleName = middleName; LastName = lastName; } public string FirstName { get { return _firstName; } set { RaisePropertyChanging(() =&amp;gt; FirstName); var oldValue = _firstName; _firstName = value; RaisePropertyChanged(() =&amp;gt; FirstName, oldValue, value); } } public string MiddleName { get { return _middleName; } set { RaisePropertyChanging(() =&amp;gt; MiddleName); var oldValue = _middleName; _middleName = value; RaisePropertyChanged(() =&amp;gt; MiddleName, oldValue, value); } } public string LastName { get { return _lastName; } set { RaisePropertyChanging(() =&amp;gt; LastName); var oldValue = _lastName; _lastName = value; RaisePropertyChanged(() =&amp;gt; LastName, oldValue, value); } } }</description></item><item><title>Property bags</title><link>https://docs.catelproject.com/vnext/catel-core/data-handling/property-bags/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/data-handling/property-bags/</guid><description>A property bag is a class that can hold multiple (dynamically registered) values. It can be compared to a dictionary, but does a bit more since it will also do integrity checks and change notifications.
Catel ships with multiple property bag implementations out of the box and uses a shared interface IPropertyBag to make it easy to switch between multiple implementations.
var propertyBag = new PropertyBag(); propertyBag.SetValue(&amp;quot;MyBoolValue&amp;quot;, true); propertyBag.SetValue(&amp;quot;MyIntValue&amp;quot;, 42); propertyBag.</description></item><item><title>ServiceLocator</title><link>https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/servicelocator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/servicelocator/</guid><description>The ServiceLocator services as the container inside Catel.
Internally it uses the TypeFactory as instantiator for the services.
Catel uses it&amp;rsquo;s own ServiceLocator implementing the IServiceLocator to gather all services required by Catel. For example, default services are the IPleaseWaitService and the IUIVisualizerService. By default, when the first view model is instantiated, Catel registers all default out of the box services to the ServiceLocator. However, it only does this when the specific services are not already registered.</description></item><item><title>Using attributes</title><link>https://docs.catelproject.com/vnext/catel-core/ioc/automatic-type-registration/using-attributes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/ioc/automatic-type-registration/using-attributes/</guid><description>The ServiceLocator in Catel can be set up to discover attribute based registration. Declaring a registration since the type definition There is a way to automatically register types into a service locator. Using ServiceLocatorRegistrationAttribute it is possible to register types into the service locator in a declarative way. The following code shows how use this attribute:
[ServiceLocatorRegistration(typeof(IMyClass))] public class MyClass : IMyClass { } All registration options are available in attribute based registration, such as registration type and tag, as ServiceLocatorRegistrationAttribute constructor arguments.</description></item><item><title>Using the code snippets</title><link>https://docs.catelproject.com/vnext/setup-deployment/code-snippets-templates/using-the-code-snippets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/setup-deployment/code-snippets-templates/using-the-code-snippets/</guid><description>This part of the documentation explains all the code snippets.
Code snippet Explanation modelobject Defines a model using the ModelBase class. modelprop Defines a new property on a model class. modelpropchanged Defines a new property with change notification on a model class. vm Defines a new view model. vmcommand Defines a new view model command with only an executed action.</description></item><item><title>Validation via validate methods</title><link>https://docs.catelproject.com/vnext/catel-core/validation/validation-via-validate-method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/validation/validation-via-validate-method/</guid><description>The ViewModelBase derives from ModelBase, thus all information here also applies to the ViewModelBase The easiest way to implement validation is to override the ValidateFields and ValidateBusinessRules methods. Below is an example of an implementation of the ValidateFields method:
protected override void ValidateFields(List&amp;lt;IFieldValidationResult&amp;gt; validationResults) { if (string.IsNullOrEmpty(FirstName)) { validationResults.Add(FieldValidationResult.CreateError(FirstNameProperty, &amp;quot;First name is required&amp;quot;)); } if (string.IsNullOrEmpty(LastName)) { validationResults.Add(FieldValidationResult.CreateError(LastNameProperty, &amp;quot;Last name is required&amp;quot;)); } if (Gender == Gender.Unknown) { validationResults.</description></item><item><title>WPF implementation for exception handling</title><link>https://docs.catelproject.com/vnext/catel-core/exception-handling/wpf-implementation-for-exception-handling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/exception-handling/wpf-implementation-for-exception-handling/</guid><description>Creating a watcher The watcher below is a self-managed watcher that takes care of exception handling in case of unhandled exceptions in both the AppDomain and Dispatcher.
public class ExceptionWatcher { private static readonly ILog Log = LogManager.GetCurrentClassLogger(); private readonly IExceptionService _exceptionService; private readonly IMessageService _messageService; public ExceptionWatcher(IExceptionService exceptionService, IMessageService messageService) { Argument.IsNotNull(() =&amp;gt; exceptionService); Argument.IsNotNull(() =&amp;gt; messageService); _exceptionService = exceptionService; _messageService = messageService; exceptionService.Register&amp;lt;Exception&amp;gt;(async exception =&amp;gt; { await _messageService.</description></item><item><title>Caveats in UWP</title><link>https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-uwp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-uwp/</guid><description>Below are all caveats in UWP.
Know caveats? Feel free to add them!</description></item><item><title>Creating the models</title><link>https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-models/</guid><description>In this step we will create models. Since this application is about families and persons inside those families, we need to create the following models: Settings, Family and Person. Creating the model classes The models that will be used in this application will derive from the ModelBase, ValidatableModelBase or SavableModelBase class of Catel. These classes enable support for change notifications, validations and persistence. The SavableModelBase adds additional methods to save and load from/to streams or files without having to create a serializer first.</description></item><item><title>Customizing the serialization for specific models</title><link>https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/customizing-serialization-for-specific-models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/customizing-serialization-for-specific-models/</guid><description>Catel has a default behavior for what gets serialized. It can be tweaked by including / excluding fields and properties by using the IncludeInSerialization and ExcludeFromSerialization attributes. But sometimes one needs more specific customization of the serialization for a specific type. This customization is possible via the ISerializerModifier.
Creating the modifier To customize the serialization of a specific model type, one needs to implement the ISerializerModifier interface. The example belows shows how to encrypt the Password property on the Person model class.</description></item><item><title>DispatcherObservableObject</title><link>https://docs.catelproject.com/vnext/catel-core/data-handling/dispatcherobservableobject/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/data-handling/dispatcherobservableobject/</guid><description> Note that the *DispatcherObservableObject* is located in *Catel.MVVM* because it uses the *IDispatcherService* The DispatcherObservableObject is a class that derives from the ObservableObject class. The only difference is that the DispatcherObservableObject will dispatch all property change notifications to the UI thread. Below is a class that uses the DispatcherObservableObject and is thread-safe for the change notifications.
public class Person : DispatcherObservableObject { private string _firstName; private string _middleName; private string _lastName; public Person(string firstName, string middleName, string lastName) { FirstName = firstName; MiddleName = middleName; LastName = lastName; } public string FirstName { get { return _firstName; } set { RaisePropertyChanging(() =&amp;gt; FirstName); var oldValue = _firstName; _firstName = value; RaisePropertyChanged(() =&amp;gt; FirstName, oldValue, value); } } public string MiddleName { get { return _middleName; } set { RaisePropertyChanging(() =&amp;gt; MiddleName); var oldValue = _middleName; _middleName = value; RaisePropertyChanged(() =&amp;gt; MiddleName, oldValue, value); } } public string LastName { get { return _lastName; } set { RaisePropertyChanging(() =&amp;gt; LastName); var oldValue = _lastName; _lastName = value; RaisePropertyChanged(() =&amp;gt; LastName, oldValue, value); } } }</description></item><item><title>Message mediator</title><link>https://docs.catelproject.com/vnext/catel-core/messaging/message-mediator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/messaging/message-mediator/</guid><description>Catel allows sending messages to unknown targets by implementing the mediator pattern. The mediator is assured memory leak free, and can be used safely in any .NET environment (even ASP.NET). Below are a few usage examples of the MessageMediator class.
Registering to a message  To register a handler for a specific message type, in this case a string, use the following code:
var mediator = ServiceLocator.Default.ResolveType&amp;lt;IMessageMediator&amp;gt;(); mediator.Register&amp;lt;string&amp;gt;(this, OnMessage); Sending out a message  To send a message to all recipients, use the following code:</description></item><item><title>MVVM</title><link>https://docs.catelproject.com/vnext/faq/mvvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/faq/mvvm/</guid><description>How to support example data with view models? To find out how to create design time data, see the designerstopic.
How to use events with MVVM? When writing MVVM, it&amp;rsquo;s &amp;ldquo;forbidden&amp;rdquo; (read: not a best practice) to use click handlers (or other UI events) in your view-model. But then should you react to events?
Start with creating a command like you are used to using MVVM. This command will be executed when the event occurs.</description></item><item><title>TypeFactory</title><link>https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/typefactory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/typefactory/</guid><description>The TypeFactory is responsible for actually creating types inside Catel. It uses the following mechanism:
List all the constructors, order them from most parameters to least parameters While (constructors available) try to construct type using injection If all constructors fail, the TypeFactory will fallback to Activator.CreateInstance() Dependency injection The ServiceLocator in Catel supports dependency injection.
Introduction to dependency injection Some people make dependency injection hard to understand, or maybe they don&amp;rsquo;t understand it themselves.</description></item><item><title>Using conventions</title><link>https://docs.catelproject.com/vnext/catel-core/ioc/automatic-type-registration/using-conventions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/ioc/automatic-type-registration/using-conventions/</guid><description>The ServiceLocator in Catel can be set up to automatically register types based on the conventions. The convention based registration should to be run first than the others registration methods to be sure to have all your types registered correctly. Some conventions are provided by default to allow us to register types.
Register using Naming Convention You can want to register all types which match with the default naming convention, means when I have a *IService *interface, I expect the convention to find and register the Service class as implementation.</description></item><item><title>Using the item templates</title><link>https://docs.catelproject.com/vnext/setup-deployment/code-snippets-templates/using-the-item-templates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/setup-deployment/code-snippets-templates/using-the-item-templates/</guid><description>There are lots of item templates available for Catel so it is really easy to develop new views very fast.
Difference between logic in view base or behavior As you might have noticed, there are lots of &amp;ldquo;double&amp;rdquo; item templates. However, there is a substantial difference between the item templates that implement the logic in the view base or the logic in a behavior.
Shortly said, a view with the logic in the view base is defined like this:</description></item><item><title>Validation in model or view model?</title><link>https://docs.catelproject.com/vnext/introduction/mvvm/validation-in-model-or-view-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/introduction/mvvm/validation-in-model-or-view-model/</guid><description>I have had lots of discussion whether the validation should take place in the model or the view model. Some people think that the validation should always occur inside the model because you don’t want to persist invalid models to the persistence store. Others say that the models itself don’t need validation, but the state the view model is in requires the validation. I think both are true, and I will tell you why.</description></item><item><title>Validation via data annotations</title><link>https://docs.catelproject.com/vnext/catel-core/validation/validation-via-data-annotations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/validation/validation-via-data-annotations/</guid><description>The ViewModelBase derives from ModelBase, thus all information here also applies to the ViewModelBase Data annotations are validation when the specific property is set. For example, when a property FirstName is set, all the data annotations on the FirstName property are validated.
Decorating properties with data annotations Decorating properties is very simple. For example, to make a property mandatory, use the following definition (note the Required attribute):</description></item><item><title>Caveats in Android</title><link>https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-android/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-android/</guid><description>Below are all caveats in Android.
Linker settings Know caveats? Feel free to add them!
Linker settings When linking in release mode (or debug if you would like), the linker will remove all non-used items from the final application assembly. Since the binding system in Catel uses reflection, it might break when the linker is too aggressive when optimizing the app. To prevent optimalization, create a dummy file that uses the members of each type so the linker will not exclude them.</description></item><item><title>DependencyResolver and DependencyResolverManager</title><link>https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/dependencyresolver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/dependencyresolver/</guid><description>Introduction to Managing different scoping of service locators and dependency injection can be hard. To aid developers with this, the IDependencyResolver and DependencyResolverManager are introduced.
Why the need for a DependencyResolver That&amp;rsquo;s a good question. Catel already provides the IServiceLocator which allows to resolve types. The downside is that if you want to customize the way dependencies are resolved in Catel, you will have to implement a custom version of the ServiceLocator.</description></item><item><title>Introduction to MVVM and models</title><link>https://docs.catelproject.com/vnext/introduction/mvvm/introduction-to-mvvm-and-models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/introduction/mvvm/introduction-to-mvvm-and-models/</guid><description>This part of the documentation will explain all the parts of MVVM, in the order in which we think they must be built. First of all, the Models, which are the closest to the business. Then, the View Models which define what part of the Models should be visible to the user in a specific situation. This also includes validation that is specific for the functionality that the View Model represents.</description></item><item><title>Messaging via attributes</title><link>https://docs.catelproject.com/vnext/catel-core/messaging/messaging-via-attributes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/messaging/messaging-via-attributes/</guid><description>The message mediator is a great way to communicate between instances in an application. It does however require to manually subscribe to and unsubscribe from classes. This issue can be bypassed using the attribute based approach. This is an alternative for registering a method in the message mediator and not be obliged to use Register&amp;lt;T&amp;gt; method.
Subscribing and unsubscribing  When attributes are using inside a class, it is required to call the MessageMediatorHelper.</description></item><item><title>ModelBase</title><link>https://docs.catelproject.com/vnext/catel-core/data-handling/modelbase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/data-handling/modelbase/</guid><description>The ModelBase class is a generic base class that can be used for all your data classes.
Fully serializable It is now really easy to store objects on disk or serialize them into memory, either binary or in XML. The data object supports this out of the box, and automatically handles the (de)serialization. Support property changed notifications The class supports the INotifyPropertyChanging and INotifyPropertyChanged interfaces so this class can easily be used in applications to reflect changes to the user.</description></item><item><title>Problem solving</title><link>https://docs.catelproject.com/vnext/faq/problem-solving/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/faq/problem-solving/</guid><description>As with every framework or toolkit, developers run into problems. This can be bugs or abuse of the API. Catel has several ways for developers to solve the problems themselves before contacting the team with the possible issue.
Enabling the log We take logging very serious in Catel. This means that a lot of information about the internals can be be seen in the output window. To enable logging in Catel, use the following code in your application startup code:</description></item><item><title>Serializing data from/to disk</title><link>https://docs.catelproject.com/vnext/getting-started/wpf/serializing-data-from-to-disk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/getting-started/wpf/serializing-data-from-to-disk/</guid><description>In this step we will create services that will serialize the models from/to disk. Services are a great way to abstract functionality that can be used in every part of the application. This guide will also register the service in the ServiceLocator so it can be injected in view models.
Creating the service definition The first thing to do is to create the Services folder to group the services. Below is a screenshot of how to solution will look after creating the folders:</description></item><item><title>Serializing members using ToString / Parse</title><link>https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/serializing-members-using-tostring-parse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/serializing-members-using-tostring-parse/</guid><description>Sometimes types (classes or structs) don&amp;rsquo;t implement a proper serialization mechanism. If they support proper ToString(IFormatProvider) and Parse(string, IFormatProvider) methods, there is no need to create a custom SerializerModifier to serialize these types. To let the serializers take care of this automatically, at least one of the following options must be true:
The member is decorated using the SerializeUsingParseAndToString attribute The container class has a SerializerModifier that returns true in the ShouldSerializeMemberUsingParse method Note that decorating a member that does not implement proper *ToString(IFormatProvider)* and *Parse(string, IFormatProvider)* methods is useless, the serialization engine will ignore these types For example, the class below is an excellent usage example of when to use this technique:</description></item><item><title>Using the project templates</title><link>https://docs.catelproject.com/vnext/setup-deployment/code-snippets-templates/using-the-project-templates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/setup-deployment/code-snippets-templates/using-the-project-templates/</guid><description>There are several project templates available for Catel. The easiest way is to follow these steps.
Using the project templates Create a new project. Make sure that at least .NET Framework 4.0 is selected as target framework. The templates can be found under the Catel folder as shown in the image below:
As soon as the project is created, the only thing left to do is add references to the Catel libraries.</description></item><item><title>Validation via special model validators</title><link>https://docs.catelproject.com/vnext/catel-core/validation/validation-via-special-model-validators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/validation/validation-via-special-model-validators/</guid><description>By default, Catel registers the AttributeValidatorProvider as the IValidatorProvider. This way the ModelBase and all the classes that derive from it can easily add a custom validator by using the ValidateModelAttribute.
Note that it is still possible to register a custom *IValidatorProvider* to customize this behavior. It is even possible to set the *Validator* property of the *ModelBase* on a specific instance of a model Implementing the validator The first thing that needs to be done is to write a custom implementation of the IValidator interface.</description></item><item><title>Caveats in iOS</title><link>https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-ios/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/introduction/platform-support/caveats-in-ios/</guid><description>Below are all caveats in iOS.
Know caveats? Feel free to add them!</description></item><item><title>Creating the view models</title><link>https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-view-models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-view-models/</guid><description>In this step we will create the view models. Since this is a very simple application, just a few view models are required. A view model in essence is nothing more than a class that derives from the ViewModelBase class
The *vm* code snippet is available to create view models. There is also an on-line item template available for Catel view models Creating the PersonViewModel Below is the class definition of the PersonViewModel.</description></item><item><title>Creating view models with Catel</title><link>https://docs.catelproject.com/vnext/introduction/mvvm/creating-view-models-with-catel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/introduction/mvvm/creating-view-models-with-catel/</guid><description>The View Models in Catel are very easy to write, and give the end-user a great flexibility in how to approach the Models. This part of the article will explain the classes that make it possible to easily create View Models.
The ViewModelBase class is the most important class of all in the MVVM Framework of Catel. Of course, it can&amp;rsquo;t do anything useful without the other classes, but all the View Models that are created using Catel derive of this class.</description></item><item><title>Ensuring integrity of the ServiceLocator</title><link>https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/ensuring-integrity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/ioc/introduction-to-components/ensuring-integrity/</guid><description>Starting with Catel 3.6, a very useful feature has been added to the ServiceLocator and TypeFactory. This features is called &amp;ldquo;integrity checker&amp;rdquo; and will ensure you with useful information about type registration paths. This protection mechanism is very useful in complex applications. When people start building services, sometimes they accidentally inject other services that via injection to other services cause a stack overflow. Debugging and determining which type is causing the issue can be very time-consuming.</description></item><item><title>Performance considerations</title><link>https://docs.catelproject.com/vnext/faq/performance-considerations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/faq/performance-considerations/</guid><description>While developing software, it is very important to keep an eye on the performance. Catel itself does perform very well, but there are some caveats that you should be aware of. If you have the feeling that the application is laggy or slow, or if you want to make sure to squeeze the best performance out of Catel, consider taking a closer look at the checklist below.
Use the [ApiCop feature]() to get a detailed advisory report on your software General Disable the call to LogManager.</description></item><item><title>Taking full control of serialization</title><link>https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/taking-full-control-of-serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/serialization/customizing-serialization/taking-full-control-of-serialization/</guid><description>It&amp;rsquo;s possible that full control is needed (either for performance or custom serialization formats). To ensure the best performance possible, this is implemented with a special interface for each serialization engine. If one of the engines detects such a special interface, it will skip all the plumbing and directly call the interface with the right context.
Binary serialization Custom binary serialization is not (yet) supported Xml serialization To gain the best performance possible using the xml serializer, a model should implement the ICustomXmlSerializable interface.</description></item><item><title>ValidatableModelBase</title><link>https://docs.catelproject.com/vnext/catel-core/data-handling/validatablemodelbase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/data-handling/validatablemodelbase/</guid><description>The ValidatableModelBase class extends the [ModelBase](/vnext/catel-core/data-handling/modelbase/) class with functionality to validate the model. The class implements the IDataErrorInfo and INotifyDataErrorInfo interfaces so it is possible to validate the data object and check the errors. This way, no custom validation code needs to be written outside the data class.
More documentation should be written in the future</description></item><item><title>Validation via IValidator</title><link>https://docs.catelproject.com/vnext/catel-core/validation/validation-via-ivalidator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/validation/validation-via-ivalidator/</guid><description>The ViewModelBase derives from ModelBase, thus all information here also applies to the ViewModelBase The validation in Catel is extremely flexible, but sometimes it is just not enough or you are forced to use external validators. For such cases, Catel provides the IValidatorProvider and IValidator interfaces. These allow very flexible injection or external validators into data objects and view models of Catel.
Implementing the IValidatorProvider The IValidatorProvider is responsible to return the right IValidator for a specific type.</description></item><item><title>ComparableModelBase</title><link>https://docs.catelproject.com/vnext/catel-core/data-handling/comparablemodelbase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/data-handling/comparablemodelbase/</guid><description>The ComparableModelBase class extends the [ModelBase](/vnext/catel-core/data-handling/modelbase/) class with default equality comparer members. This logic has been moved to a separate class to improve the out-of-the-box performance of the ModelBase class.
More documentation should be written in the future</description></item><item><title>Creating the views (user controls)</title><link>https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-user-controls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-user-controls/</guid><description>In this step we will create the views for the application. There are several views that will be created and both user controls and windows will be handled in this part of the guide. Catel makes it very easy to create views as user controls with their own view models. In the previous step we already created the view models.
Person view To create a new view, right-click the Views folder in the solution =&amp;gt; Add =&amp;gt; New item&amp;hellip; =&amp;gt; On-line =&amp;gt; and search for Catel as you can see in the screen below:</description></item><item><title>Introduction to services</title><link>https://docs.catelproject.com/vnext/introduction/mvvm/introduction-to-services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/introduction/mvvm/introduction-to-services/</guid><description>Services are very important in MVVM. They define a way to interact with the user without using fixed controls such as MessageBox or SaveFileDialog. The interfaces defined in Catel only define generic functionality of what to expect from a specific service. Using services is a great way to abstract away all specific functionality from a view model into a service that can be mocked during unit testing and can be used by other view models as well.</description></item><item><title>Using the validation context</title><link>https://docs.catelproject.com/vnext/catel-core/validation/using-validation-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/validation/using-validation-context/</guid><description>The *ViewModelBase* derives from *ModelBase*, thus all information here also applies to the *ViewModelBase* Sometimes detailed information about validation is required. This is possible in Catel thanks to the ValidationContext class. The ValidationContext serves as the container for all validation results that are gathered via the available validation methods. The ValidationContext has lots of methods that all return lists of either IFieldValidationResult or IBusinessRuleValidationResult.
The examples below are shown a starter examples, but you can gather every type of validation result by using the ValidationContext.</description></item><item><title>Creating the views (windows)</title><link>https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-windows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/getting-started/wpf/creating-the-windows/</guid><description>In this step we will create the windows for the application. In the previous step we already created the user controls. Windows are a great way to show in an edit-context. Catel provides great edit-windows in the form of the DataWindow. This is a window that automatically adds *OK* and *Cancel* buttons (but of course allows customization of the buttons and behavior).
Person window It is very important that the window derives from one of the Catel windows.</description></item><item><title>Getting a summary of validation results</title><link>https://docs.catelproject.com/vnext/catel-core/validation/getting-summary-of-validation-results/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/validation/getting-summary-of-validation-results/</guid><description>Sometimes you just need to get a summary of all warnings and errors of an object. All validation is gathered in the IValidationContext and available on that class. However, there are some convenience classes that allow a developer to create a summary based on a specific tag. This convenience class is IValidationSummary, which gathers the right information from an instance of IValidationContext.
Creating a summary of all validations  To retrieve a summary of all validations from a IValidationContext, use the following code:</description></item><item><title>Introduction to the nested user controls problem</title><link>https://docs.catelproject.com/vnext/introduction/mvvm/introduction-to-nested-user-controls-problem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/introduction/mvvm/introduction-to-nested-user-controls-problem/</guid><description>One of the issues most users of MVVM face is that “nested user controls” problem. The problem is that most (actually all that we’ve seen) MVVM Frameworks only support one view model for a window (or if you’re lucky, a user control). However, the “nested user controls” problem raises lots of questions:
What if the requirements are to build a dynamic UI where the nested user controls are loaded dynamically when they are required?</description></item><item><title>SavableModelBase</title><link>https://docs.catelproject.com/vnext/catel-core/data-handling/savablemodelbase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/data-handling/savablemodelbase/</guid><description>The SavableModelBase class extends the [ModelBase](/vnext/catel-core/data-handling/modelbase/) class with functionality to save the model to a persistence store.
Note that the `SavableModelBase` is just a convenience implementation. The `ModelBase` can be serialized by any `ISerializer` implementation as well. More documentation should be written in the future</description></item><item><title>ChildAwareModelBase</title><link>https://docs.catelproject.com/vnext/catel-core/data-handling/childawaremodelbase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/data-handling/childawaremodelbase/</guid><description>The ChildAwareModelBase class extends the [ModelBase](/vnext/catel-core/data-handling/modelbase/) class with functionality to get change notifications of child objects of the model. The class uses the ChangeNotificationWrapper to subscribe to all child objects using weak events.
More documentation should be written in the future</description></item><item><title>Deferring validation</title><link>https://docs.catelproject.com/vnext/catel-core/validation/deferring-validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/validation/deferring-validation/</guid><description>The opinions about validation differ from person to person. Some people think it is best practice to immediately show the errors to the users. Others want to defer it to the moment where the user clicks the Save or OK button. Catel supports both &amp;ldquo;best practices&amp;rdquo;.
Suspending validation for a batch of changes Sometimes you need to change a batch of properties and don&amp;rsquo;t want validation to be called after every property change.</description></item><item><title>Hooking up everything together</title><link>https://docs.catelproject.com/vnext/getting-started/wpf/hooking-up-everything-together/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/getting-started/wpf/hooking-up-everything-together/</guid><description>In this step we will hook everything together and add additional logic to the remaining view models.
Hooking up the view models We now have most of the application ready. However we need some logic in the view models to hook up everything together.
Adding additional logic to FamilyWindowViewModel The first thing we are going to do is to finalize the FamilyWindowViewModel we created in the previous step. To do this, we are going to add a few properties and commands to the view model.</description></item><item><title>Finalizing the application</title><link>https://docs.catelproject.com/vnext/getting-started/wpf/finalizing-the-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/getting-started/wpf/finalizing-the-application/</guid><description>The application we have created so far is fully functional, but misses a bit of the &amp;ldquo;magic&amp;rdquo;. Below are some additional steps that might make your application more appealing and more user friendly. Of course you can go as far as you want by creating custom animations and such, but this guide focuses purely on making the basics more appealing.
Adding validation Adding validation with Catel is extremely easy. There are two flavors to pick from, but they work exactly the same (since both the models and view models internally derive from ValidatableModelBase).</description></item><item><title>Using ModelBase as base for entities</title><link>https://docs.catelproject.com/vnext/catel-core/data-handling/using-modelbase-as-base-for-entities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/data-handling/using-modelbase-as-base-for-entities/</guid><description>It is possible to use the ModelBase as base class when using EF or any other OR mapper.
Setting up ModelBase as base class There are a few caveats when using the ModelBase as base class for your entities. One of them is that IsDirty is always true because the properties from the persistence store are set after the constructor. This guide will explain how to work past that problem.</description></item><item><title>Advanced property change notifications</title><link>https://docs.catelproject.com/vnext/catel-core/data-handling/advanced-property-change-notifications/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/data-handling/advanced-property-change-notifications/</guid><description>Sometimes the old value is needed in case of property change event. However, the INotifyPropertyChanged interface does not provide any of this. To support this behavior, a new version of the PropertyChangedEventArgs is created called AdvancedPropertyChangedEventArgs. This class derives from PropertyChangedEventArgs so the interfaces are not broken, but it does add additional functionality to the software system.
Getting old value automatically When using the ModelBase or ViewModelBase classes, the old and new value of a property are automatically provided on a property change.</description></item><item><title>Catel 4.0</title><link>https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-4.0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-4.0/</guid><description>This guide describes how to update your code to be fully compatible with Catel 4.0.
Renaming classes Some classes in Catel have been renamed.
Catel.Environment =&amp;gt; CatelEnvironment IDependencyPropertySelector =&amp;gt; IViewPropertySelector Renaming namespaces Some namespaces in Catel have been changed to match the functionality. For example, all services are now in Catel.Service instead of Catel.MVVM.Services because they can be used without MVVM.
Below is a list of changed namespaces:</description></item><item><title>Catel 4.1</title><link>https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-4.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-4.1/</guid><description>This guide describes how to update your code to be fully compatible with Catel 4.1.
This guide assumes that you are coming from Catel 4.0. If not, please read that guide first. IUIVisualizerService We have reverted the change to force you to use async code on the IUIVisualizerService. There are now 2 options:
Synchronous:
var result = uiVisualizerService.ShowDialog&amp;lt;MyViewModel&amp;gt;(); // Window is closed here (synchronous behavior) Asynchronous:</description></item><item><title>Catel 5.0</title><link>https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-5.0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-5.0/</guid><description>This guide describes how to update your code to be fully compatible with Catel 5.0.
Catel v5 contains a lot of breaking changes, not all of them cause compiler errors but change core behavior. It&#39;s important to check out the guide below **before** updating to Catel v5. This guide assumes that you are coming from Catel 4.5. If not, please read that guide first. Encountered issues while upgrading to this version?</description></item><item><title>Catel 5.4</title><link>https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-5.4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/setup-deployment/update-guides/catel-5.4/</guid><description>This guide describes how to update your code to be fully compatible with Catel 5.4.
This guide assumes that you are coming from Catel 5.x. If not, please read that guide first. Encountered issues while upgrading to this version? Add them here to help out others!
Updated converters The behavior of converters have been changed for some converters. The converter parameter will now also serve as an &amp;ldquo;inverter&amp;rdquo;.</description></item><item><title/><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/focus-first-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/focus-first-control/</guid><description>FocusFirstControl The Focus behavior is very powerful, but sometimes you just need to focus the first control on a window or control. This can be done by using the FocusFirstControl behavior instead. This behavior will focus the first control on a window or control and has only one property: FocusParentFirst.
Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; Focus when the control is loaded The easiest and default method is to focus the first control.</description></item><item><title/><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/focus-on-key-press/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/focus-on-key-press/</guid><description> FocusOnKeyPress Sometimes you need to handle a key press and then set the focus on an element.
1) Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; 2) Use the following definition:
&amp;lt;TextBox x:Name=&amp;quot;textBox&amp;quot;&amp;gt; &amp;lt;i:Interaction.Behaviors&amp;gt; &amp;lt;catel:FocusOnKeyPress Key=&amp;quot;F&amp;quot; Modifiers=&amp;quot;Ctrl&amp;quot; /&amp;gt; &amp;lt;/i:Interaction.Behaviors&amp;gt; &amp;lt;/ListBox&amp;gt;</description></item><item><title>Activities (pages)</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xamarin-android/activities-pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xamarin-android/activities-pages/</guid><description>The user controls in Android are called fragments. This means that if a user control must be created, it must derive from the Fragment class. Catel provides a base implementation of this class to ensure full compatibility with the MVVM framework that ships with Catel.
Creating the view model The view model can be created (or added as a linked file from another project) just like any platform using Catel (they are all equal on all platforms).</description></item><item><title>Authentication</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/authentication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/authentication/</guid><description>The Authentication behavior is able to hide, collapse or disable UI elements based on the current user state. The behavior uses the registered IAuthenticationProvider instances to determine whether the user has access to the specified UI element.
1) Creating an authentication provider:
/// &amp;lt;summary&amp;gt; /// Example implementation of the &amp;lt;see cref=&amp;quot;AuthenticationProvider&amp;quot;/&amp;gt;. This class is not really implemented /// like it should, because it shouldn&#39;t be this easy to set the current role.</description></item><item><title>AutoCompletionBehavior</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/autocompletion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/autocompletion/</guid><description>To enable auto completion features, once can use the services and behaviors provided by Catel. There are two components required for auto completion:
AutoCompletionService =&amp;gt; takes care of the actual filtering AutoCompletionBehavior =&amp;gt; can be attached to a TextBox to support a dropdown with recommended values The auto completion features looks like the screenshot below:
AutoCompletion service The default implementation automatically filters the collection specified. If there is no filter yet, it will filter the top 10 occurrences from the collection.</description></item><item><title>AutoScroll</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/autoscroll/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/autoscroll/</guid><description>The AutoScroll behavior automatically scrolls to a specific direction when the ItemsSource of an ItemsControl changes.
1) Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; 2) Add behavior
&amp;lt;ListBox ItemsSource=&amp;quot;{Binding LogEntries}&amp;quot;&amp;gt; &amp;lt;i:Interaction.Behaviors&amp;gt; &amp;lt;catel:AutoScroll ScrollDirection=&amp;quot;Bottom&amp;quot; ScrollTreshold=&amp;quot;10&amp;quot; /&amp;gt; &amp;lt;/i:Interaction.Behaviors&amp;gt; &amp;lt;/ListBox&amp;gt; The ScrollDirection determines the direction (Top or Bottom).
The ScrollTreshold allows the treshold of the real offset (to determine whether auto scroll should be enabled). For example, when the user is manually scrolling, this behavior will pause.</description></item><item><title>Batch log listeners</title><link>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/batch-log-listeners/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/batch-log-listeners/</guid><description>A batch log listener is a class implementing the IBatchLogListener interface (and most probably deriving from BatchLogListenerBase). This interface adds a Flush method which allows a listener to be flushed. The advantage is that when a log listener writes to a slower persistence store, it will not have to access this expensive resource for every log event, but by batches.
Flushing all listeners When using batch log listeners, it is very important to flush the log listeners at important events such as application unhandled exceptions or when the application exits.</description></item><item><title>Binary</title><link>https://docs.catelproject.com/vnext/catel-core/serialization/supported-serializers/binary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/serialization/supported-serializers/binary/</guid><description>The binary serializer uses the .NET binary serializer formatters to serialize the objects.</description></item><item><title>Change notification wrapper</title><link>https://docs.catelproject.com/vnext/catel-core/preventing-memory-leaks/change-notification-wrapper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/preventing-memory-leaks/change-notification-wrapper/</guid><description>Subscribing to change notifications of objects mostly results in large statements such as the one below:
var itemAsPropertyChanged = obj as INotifyPropertyChanged; if (itemAsPropertyChanged != null) { itemAsPropertyChanged.PropertyChanged += OnPropertyChanged; } However, using this code one must be aware that if not unsubscribed, there might be a potential memory leak here. In Catel, there is a solution for such cases that can raise change notifications using weak events called the ChangeNotificationWrapper.</description></item><item><title>Command bindings</title><link>https://docs.catelproject.com/vnext/catel-mvvm/bindings/command-bindings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/bindings/command-bindings/</guid><description> Catel will automatically hook up the CanExecute of the command to the Enabled property of the element it is bound to. A command binding is always bound to an event of a specific element as shown below.
Android protected override void AddBindings(BindingContext bindingContext, IViewModel viewModel) { var vm = (MainViewModel) viewModel; bindingContext.AddCommandBinding(_testButton, &amp;quot;Click&amp;quot;, vm.RunCommand); } iOS iOS not yet documented</description></item><item><title>CommandManager and command containers (Application-wide commands)</title><link>https://docs.catelproject.com/vnext/catel-mvvm/commands-events/application-wide-commands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/commands-events/application-wide-commands/</guid><description>Most commands are registered per view and available per view model. Some commands (such as commands on a Ribbon or Toolbar) are application-wide. Catel supports both types, and this part of the documentation explains how to use the ICommandManager to work with application-wide commands such as Refresh with a key bound to F5.
CommandManager There is no generic way to specify application-wide commands in XAML platforms. To overcome this issue, Catel introduces the CommandManager.</description></item><item><title>Commands</title><link>https://docs.catelproject.com/vnext/catel-mvvm/commands-events/commands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/commands-events/commands/</guid><description>Commands are supported in Catel. The base class for commands is Command.
Code snippets vmcommand - declare a command on a view model vmcommandwithcanexecute - declare a command with support for CanExecute on a view model Explanation To implement commands, and still be able to unit test the view models, a separate command is introduced. This command allows a developer to implement a command that can be invoked both via code (unit testing) and UI.</description></item><item><title>Commands authentication</title><link>https://docs.catelproject.com/vnext/catel-mvvm/commands-events/authentication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/commands-events/authentication/</guid><description>One of the questions an MVVM developer faces is how to control the executation state of a command by role or user authentication method. Catel offers an out-of-the-box solution for this problem to check the CanExecute state of the commands in the UI. It is very important that this way of disabling commands is only used to easy the development of consistent user interfaces. It cannot replace the actual check whether a user can or cannot modify data.</description></item><item><title>ConsoleLogListener</title><link>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/console-log-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/console-log-listener/</guid><description>The ConsoleLogListener writes messages to the console with automatic colors:
To add it, use the code below:
var logListener = new ConsoleLogListener(); logListener.IgnoreCatelLogging = true; // TODO: Customize options LogManager.AddListener(logListener);</description></item><item><title>Controlling the instantiation of view models</title><link>https://docs.catelproject.com/vnext/catel-mvvm/view-models/advanced/controlling-instantiation-of-view-models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/view-models/advanced/controlling-instantiation-of-view-models/</guid><description>Starting with Catel 3.1, it is possible to take control of the view model instantiation of a view dynamically at runtime. This feature can be used when the construction of a view model is more complex than injecting the datacontext as model, or when the view model instance in a custom repository should be re-used.
How to control the view model instantiation using the IViewModelFactory The IViewModelFactory is the best way to customize the instantiation of view models in Catel.</description></item><item><title>Creating a basic view model</title><link>https://docs.catelproject.com/vnext/catel-mvvm/view-models/creating-basic-view-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/view-models/creating-basic-view-model/</guid><description>This example shows how to create a view model without a model. This is useful when a UI item should simply acknowledge a step that doesn&amp;rsquo;t need to be persisted to a persistence store. The view model does include validation.
Code snippets vm - declare a view model vmprop - declare a property on a view model Explanation When implementing a simple view model without a model, only one property has to be implemented that represents the checkbox that needs to be checked.</description></item><item><title>Creating a view model with a model</title><link>https://docs.catelproject.com/vnext/catel-mvvm/view-models/creating-view-model-with-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/view-models/creating-view-model-with-model/</guid><description>This example shows how to create a &amp;ldquo;classical&amp;rdquo; view model without any Catel specific MVVM features such as data pass-through. Although it is recommended to use the pass-through features, some people want to have custom validation on the view model, or want to be fully in control.
Code snippets vm - declare a view model vmprop - declare a property on a view model Explanation To be in full control, the only thing required is to create a basic view model with the vm code snippet.</description></item><item><title>Creating a view model with a model and mappings</title><link>https://docs.catelproject.com/vnext/catel-mvvm/view-models/creating-view-model-with-model-and-mappings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/view-models/creating-view-model-with-model-and-mappings/</guid><description>During of the use of the MVVM pattern, we noticed that lots and lots of developers have a model, and map the values of the model to all properties of the view model. When the UI closes, the developers map all the properties back to the model. All this redundant code is not necessary when using the view models of Catel.
In Catel, we have created attributes that allow you to define a property as a model.</description></item><item><title>Customizing DataContext subscription behavior</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/customizing-datacontext-subscription-behavior/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/customizing-datacontext-subscription-behavior/</guid><description>Starting with Catel 4.0, the views watch both the direct and inherited DataContext. Starting with Catel 4.1, it is possible to mimick the pre 4.0 DataContext subscription behavior.
Customizing the behavior for all views To mimick pre Catel 4.0, use the following code:
var dependencyResolver = this.GetDependencyResolver(); var dataContextSubscriptionService = dependencyResolver.Resolve&amp;lt;IDataContextSubscriptionService&amp;gt;(); dataContextSubscriptionService.DefaultDataContextSubscriptionMode = DataContextSubscriptionMode.DirectDataContext; Customizing the behavior per view It is also customize the behavior per view. This allows very customized fine tuning of the behavior.</description></item><item><title>DataWindow - under the hood</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/advanced/datawindow-under-the-hood/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/advanced/datawindow-under-the-hood/</guid><description> This documentation has to be written in the future</description></item><item><title>DebugLogListener</title><link>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/debug-log-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/debug-log-listener/</guid><description>The DebugLogListener is the best debugging tool there is during development. It shows you insight in your application in the output window of Visual Studio, even from messages generated by Catel. To use it, use this:
#if DEBUG LogManager.AddDebugListener(); #endif For some platforms (like UWP), Catel uses `Debug.WriteLine` which gets removed in a release build. For such platforms, it is recommended to create a customer log listener as shown below.</description></item><item><title>DelayBindingUpdate</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/delay-binding-update/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/delay-binding-update/</guid><description>Sometimes, a binding update should be delayed for performance reasons. This is possible using the DelayBindingUpdate behavior. This behavior modifies the binding mode to explicit and internally watches for property changes. If the bound dependency property changes, the behavior will wait for the time to pass and then update. If the value changes again within the timeframe, the timer is reset (so you won&amp;rsquo;t get &amp;ldquo;double&amp;rdquo; updates).
1) Add the following XML namespaces:</description></item><item><title>Design-time view models</title><link>https://docs.catelproject.com/vnext/catel-mvvm/designers/design-time-view-models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/designers/design-time-view-models/</guid><description>Lots of developers are using designers such as the built-in designer in Visual Studio or Expression Blend to design their xaml based applications. Although you should use designers with lots of care, we strive to fully support all designers.
Since Catel 1.3, it is possible to create design-time versions of a view model. This way, you can preview the UserControl or DataWindow implementations using example data.
To create design-time support for a data window, use the following steps:</description></item><item><title>DisplayAttribute</title><link>https://docs.catelproject.com/vnext/catel-core/multilingual/displayattribute/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/multilingual/displayattribute/</guid><description>Catel implements a custom implementation of the DisplayAttribute known in the DataAnnotations namespace of .NET. This attribute uses the ILanguageService so you can easily have all translations in a single location when using Catel.
Note that this is still work in progress, we would love to support this, but MS sealed the class so we cannot derive from it (at the moment) Using the attribute Using the attribute is really easy.</description></item><item><title>DisplayNameAttribute</title><link>https://docs.catelproject.com/vnext/catel-core/multilingual/displaynameattribute/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/multilingual/displaynameattribute/</guid><description>Catel implements a custom implementation of the DisplayNameAttribute known in the DataAnnotations namespace of .NET. This attribute uses the *ILanguageService* so you can easily have all translations in a single location when using Catel.
Using the attribute Using the attribute is really easy. Just put the attribute on top of any method, property, field or parameter like this:
public enum Condition { [DisplayName(&amp;quot;Contains&amp;quot;)] Contains, [Display(&amp;quot;StartsWith&amp;quot;)] StartsWith, [Display(&amp;quot;EndsWith&amp;quot;)] EndsWith, [Display(&amp;quot;EqualTo&amp;quot;)] EqualTo, [Display(&amp;quot;NotEqualTo&amp;quot;)] NotEqualTo, [Display(&amp;quot;GreaterThan&amp;quot;)] GreaterThan, [Display(&amp;quot;LessThan&amp;quot;)] LessThan, [Display(&amp;quot;GreaterThanOrEqualTo&amp;quot;)] GreaterThanOrEqualTo, [Display(&amp;quot;LessThanOrEqualTo&amp;quot;)] LessThanOrEqualTo, [Display(&amp;quot;IsEmpty&amp;quot;)] IsEmpty, [Display(&amp;quot;NotIsEmpty&amp;quot;)] NotIsEmpty, [Display(&amp;quot;IsNull&amp;quot;)] IsNull, [Display(&amp;quot;NotIsNull&amp;quot;)] NotIsNull } Using the ILanguageService By default, the attribute uses the ILanguageService to resolve the values to show.</description></item><item><title>DoubleClickToCommand</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/double-click-to-command/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/double-click-to-command/</guid><description>Lots of times, a developer needs to handle a double click event. This trigger allows a developer to track a double click on any FrameworkElement and respond to that using a command.
1) Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; 2) Use the following definition. This example will invoke the Edit command of the view model when the item is double clicked):
&amp;lt;ListBox x:Name=&amp;quot;listBox&amp;quot; ItemsSource=&amp;quot;{Binding PersonCollection}&amp;quot; SelectedItem=&amp;quot;{Binding SelectedPerson}&amp;quot;&amp;gt; &amp;lt;ListBox.ItemTemplate&amp;gt; &amp;lt;DataTemplate&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;i:Interaction.</description></item><item><title>Event Tracing for Windows (ETW)</title><link>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/event-tracing-for-windows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/event-tracing-for-windows/</guid><description>Starting with version 4.0.0, Catel supports Event Tracking for Windows (ETW) out of the box. To add a log listener, use the code below:
var logListener = new EtwLogListener(); logListener.IgnoreCatelLogging = true; // TODO: Customize options LogManager.AddListener(logListener);</description></item><item><title>EventArgsConverter</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/event-to-command/event-args-converter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/event-to-command/event-args-converter/</guid><description>The implementation and usage of the EventToCommand behavior is always strongly encouraged when developing an MVVM application as it provides a logical separation of concerns.
However many implementations of the behavior come with the caveat, they cause a ViewModel to have knowledge of View specific types as well as causing a ViewModel to be directly dependent on the View.
To resolve that concern, Catel provides support for an EventArgsConverter that can be attached to an EventToCommand binding.</description></item><item><title>EventLogListener</title><link>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/event-log-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/event-log-listener/</guid><description>The EventLogListener allow to write log data to the system event log. To add it, use the code below:
var logListener = new EventLogListener(); logListener.IgnoreCatelLogging = true; // TODO: Customize options LogManager.AddListener(logListener); This log listener is currently available only for the full .net framework</description></item><item><title>Exposing properties of a model automatically</title><link>https://docs.catelproject.com/vnext/catel-mvvm/view-models/advanced/exposing-properties-of-model-automatically/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/view-models/advanced/exposing-properties-of-model-automatically/</guid><description>See Catel.Fody for more information.</description></item><item><title>Fast member invoker</title><link>https://docs.catelproject.com/vnext/catel-core/reflection/fastmemberinvoker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/reflection/fastmemberinvoker/</guid><description>The FastMemberInvoker is a low-level compiled expression tree member invocation wrapper. That&amp;rsquo;s a lot of buzz-words, but it means that this is a wrapper to get or set properties and fields of objects dynamically in the fastest way possible.
More documentation should be written in the future</description></item><item><title>FileLogListener</title><link>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/file-log-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/file-log-listener/</guid><description>Catel also supports very lightweight listeners to allow external logging libraries to hook on. To create a listener, first create a new class that implements the ILogListener interface. Next, register it in the LogManager using the LogManager.AddListener method.
The ILogListener has a separate method for each LogEvent, but also has a shared method that is called for each log event. For example, if a debug message is written to the log, both the Write and Debug methods are invoked on the ILogListener.</description></item><item><title>Finding the view of a view model</title><link>https://docs.catelproject.com/vnext/tips-tricks/mvvm/finding-view-of-view-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/tips-tricks/mvvm/finding-view-of-view-model/</guid><description>Sometimes it is required to find the view of a view model. For example, this comes in handy when implementing drag and drop where you only want to support code via view models.
Internally, Catel uses with the IViewManager for this. As soon as a view is loaded (via the Loaded event), the view is registered to the view manager. The view manager will keep an eye on the events of the view and notice view model changes.</description></item><item><title>Focus</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/focus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/focus/</guid><description>To set the focus on a UI element, one must write code in the code-behind. With the Focus behavior, this is no longer necessary. This behavior sets the focus only once on the first time the associated object is loaded.
Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; Focus when the control is loaded The easiest and default method is to set the focus when the associated control is loaded.</description></item><item><title>footer</title><link>https://docs.catelproject.com/vnext/_footer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/_footer/</guid><description/></item><item><title>Fragments (user controls)</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xamarin-android/fragments-user-controls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xamarin-android/fragments-user-controls/</guid><description>The user controls in Android are called fragments. This means that if a user control must be created, it must derive from the Fragment class. Catel provides a base implementation of this class to ensure full compatibility with the MVVM framework that ships with Catel.
Creating the view model The view model can be created (or added as a linked file from another project) just like any platform using Catel (they are all equal on all platforms).</description></item><item><title>header</title><link>https://docs.catelproject.com/vnext/_header/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/_header/</guid><description>Catel Documentation</description></item><item><title>HideUntilViewModelLoaded</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/hide-until-view-model-loaded/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/hide-until-view-model-loaded/</guid><description>The HideUntilViewModelLoaded hides (Visibility.Collapsed) any view model container (IViewModelContainer) when it does not have a valid view model. This is a great way to hide lazy-loaded views that should only be visible when they contain an actual view model.
Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; Focus when the control is loaded The easiest and default method is to focus the first control. The parent is also focused by default (just in case if it doesn&amp;rsquo;t have any focus):</description></item><item><title>Hooking a command to validation automatically</title><link>https://docs.catelproject.com/vnext/catel-mvvm/commands-events/hooking-command-to-validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/commands-events/hooking-command-to-validation/</guid><description>It is possible to hook the CanExecute of a Command to the IValidationSummary automatically. This way, there is no need to check for errors manually in the CanExecute method. The example below first adds a validation summary to a view model to get the validation result. Then, it uses this validation summary to automatically determine whether a command can be executed.
1. Add validation to a person view model (note how the validation adds the tag PersonValidation to a validation):</description></item><item><title>Improving performance by defining the view model grid manually</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/improving-performance-by-defining-view-model-grid-manually/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/improving-performance-by-defining-view-model-grid-manually/</guid><description>Catel wraps the content of each user control in a grid. This grid is the actual view model container as can be read in the advanced documentation. This wrapper is very convenient, but does have (little) impact on the performance and visual state management. To prevent Catel to wrap the control for you, there are a few things you can do.
Creating the grid manually The easiest way is to create the grid manually.</description></item><item><title>Json</title><link>https://docs.catelproject.com/vnext/catel-core/serialization/supported-serializers/json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/serialization/supported-serializers/json/</guid><description>The JsonSerializer is implemented in a separate assembly because it uses Json.Net under the hood.
Customizing configuration The JsonSerializationConfiguration enables support for customizing the configuration used while (de)serializing. Below is an example
Using Bson instead of Json To use Bson instead of Json, use the JsonSerializationConfiguration class:
var configuration = new JsonSerializationConfiguration { UseBson = true }; jsonSerializer.Serialize(myObject, configuration); Specifying the culture to use during (de)serialization To specify the culture to use during (de)serialization, set the Culture property on the configuration class:</description></item><item><title>Keeping view models alive</title><link>https://docs.catelproject.com/vnext/catel-mvvm/view-models/advanced/keeping-view-models-alive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/view-models/advanced/keeping-view-models-alive/</guid><description>In Catel, view models are automatically closed when the UserControl is unloaded from the visual tree. This is because there is no guarantee that the control will be loaded again. This works great in most of the cases, but sometimes you need more control about the lifetime of the view model. One good example is the use of the TabControl. When a tab control contains a user control with a view model, every time a new tab is selected, the controls on the previously selected tab are unloaded (and thus the view models are closed).</description></item><item><title>KeyPressToCommand</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/key-press-to-command/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/key-press-to-command/</guid><description>Sometimes you need to handle a key press and convert it to a command. An excellent example is a ListBox that should respond to an Ctrl + Enter key press.
1) Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; 2) Use the following definition:
&amp;lt;ListBox x:Name=&amp;quot;listBox&amp;quot; ItemsSource=&amp;quot;{Binding PersonCollection}&amp;quot; SelectedItem=&amp;quot;{Binding SelectedPerson}&amp;quot;&amp;gt; &amp;lt;i:Interaction.Behaviors&amp;gt; &amp;lt;catel:KeyPressToCommand Command=&amp;quot;{Binding MyCommand}&amp;quot; Key=&amp;quot;Enter&amp;quot; Modifiers=&amp;quot;Ctrl&amp;quot; /&amp;gt; &amp;lt;/i:Interaction.Behaviors&amp;gt; &amp;lt;/ListBox&amp;gt;</description></item><item><title>LocationService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/location-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/location-service/</guid><description>The ILocationService allows a developer to use GPS devices inside a view model.
It is important that the service must be started and stopped to retrieve values Starting the service The GPS service needs to be started and stopped. To start the GPS service, use the following code:
var dependencyResolver = this.GetDependencyResolver(); var locationService = dependencyResolver.Resolve&amp;lt;ILocationService&amp;gt;(); locationService.LocationChanged += OnCurrentLocationChanged; locationService.Start(); The service will raise the LocationChanged event when a new location becomes available.</description></item><item><title>Log4net</title><link>https://docs.catelproject.com/vnext/catel-core/logging/integration-with-external-loggers/log4net/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/logging/integration-with-external-loggers/log4net/</guid><description>The example below provides an ILogListener for Log4net, but any external logging library can be used.
Creating the listener A listener can be created by creating a new class deriving from LogListenerBase.
public class Log4netListener : LogListenerBase { protected override void Debug(ILog log, string message, object extraData) { var finalLog = log4net.LogManager.GetLogger(log.TargetType); finalLog.Debug(message); } protected override void Info(ILog log, string message, object extraData) { var finalLog = log4net.LogManager.GetLogger(log.TargetType); finalLog.Info(message); } protected override void Warning(ILog log, string message, object extraData) { var finalLog = log4net.</description></item><item><title>Mapping properties from view to view model</title><link>https://docs.catelproject.com/vnext/catel-mvvm/view-models/mapping-properties-from-view-to-view-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/view-models/mapping-properties-from-view-to-view-model/</guid><description>Sometimes a view (for example, a user control) contains additional properties besides the DataContext to interact with the view model. By default, it is hard to implement this in an MVVM sccenario, but Catel solves this issue using the ViewToViewModel attribute.
This attribute automatically keeps track of changes in both the view and the view model and this way, a control can have several properties and still implement MVVM.</description></item><item><title>MessageService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/message-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/message-service/</guid><description>The IMessageService allows a developer to show message boxes from a view model.
Showing a message To show a message from a view model, use the following code:
var dependencyResolver = this.GetDependencyResolver(); var messageService = dependencyResolver.Resolve&amp;lt;IMessageService&amp;gt;(); await messageService.Show(&amp;quot;My first message via the service&amp;quot;); Showing an error Showing a warning or error is very easy. Use the following code:
var dependencyResolver = this.GetDependencyResolver(); var messageService = dependencyResolver.Resolve&amp;lt;IMessageService&amp;gt;(); await messageService.ShowError(&amp;quot;Whoops, something went wrong&amp;quot;); Requesting confirmation It is also possible to request confirmation from the user.</description></item><item><title>MouseInfo</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/mouse-info/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/mouse-info/</guid><description>1) Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; 2) Use the following definition:
&amp;lt;ListBox ItemsSource=&amp;quot;{Binding PersonCollection}&amp;quot; SelectedItem=&amp;quot;{Binding SelectedPerson}&amp;quot;&amp;gt; &amp;lt;i:Interaction.Behaviors&amp;gt; &amp;lt;catel:MouseInfo x:Name=&amp;quot;personCollectionMouseInfo&amp;quot; /&amp;gt; &amp;lt;/i:Interaction.Behaviors&amp;gt; &amp;lt;/ListBox&amp;gt; 3) Now, it is easy to bind to the mouse information like this (textblock will become visible when the listbox is hovered):
&amp;lt;TextBlock Visibility=&amp;quot;{Binding ElementName=personCollectionMouseInfo, Path=IsMouseOver, Converter={StaticResource BooleanToCollapsingVisibilityConverter}, ConverterParameter=false}&amp;quot; Text=&amp;quot;Hovering listbox&amp;quot; /&amp;gt;</description></item><item><title>Naming conventions</title><link>https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/naming-conventions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/naming-conventions/</guid><description>Some services in Catel support naming conventions. For example, the IViewLocator and IViewModelLocator allow naming conventions to prevent a user from having to register all views and view models. Internally, the naming conventions are resolved using the NamingConvention helper class. This part of the documentation explains the possible constants in naming conventions.
[AS] constant The [AS] constant will be replaced by the assembly name. For example, the following naming convention:</description></item><item><title>Navigate</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/navigate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/navigate/</guid><description>Note that this behavior is only available for WPF The Hyperlink control in WPF is very powerful, but it is hard to make them work outside pages.
Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; To execute the NavigateUrl, simply use the behavior as shown below:
&amp;lt;TextBlock&amp;gt; &amp;lt;Hyperlink NavigateUri=&amp;quot;http://schemas.catelproject.com&amp;quot;&amp;gt; &amp;lt;i:Interaction.Behaviors&amp;gt; &amp;lt;catel:Navigate /&amp;gt; &amp;lt;/i:Interaction.Behaviors&amp;gt; &amp;lt;TextBlock Text=&amp;quot;The best MVVM Framework&amp;quot; /&amp;gt; &amp;lt;/Hyperlink&amp;gt; &amp;lt;/TextBlock&amp;gt; Another alternative is to use the `LinkLabel` control from [Orc.</description></item><item><title>NavigationService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/navigation-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/navigation-service/</guid><description>The INavigationService allows a developer to navigate to other pages inside an application using view models only.
All pages will have to be registered manually or following the right naming convention.
The `NavigationService` uses the `IViewLocator` and `IViewModelLocator` do handle the navigation. See the [Naming conventions](/vnext/catel-mvvm/locators-naming-conventions/) section for more details. Closing an application It is possible to close an application using the following code:
var dependencyResolver = this.</description></item><item><title>Nested view models</title><link>https://docs.catelproject.com/vnext/catel-mvvm/view-models/nested-view-models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/view-models/nested-view-models/</guid><description>For more information on this topic, see nested user controls.</description></item><item><title>NLog</title><link>https://docs.catelproject.com/vnext/catel-core/logging/integration-with-external-loggers/nlog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/logging/integration-with-external-loggers/nlog/</guid><description>NLog The example below provides an ILogListener for NLog, but any external logging library can be used.
Creating the listener A listener can be created by creating a new class deriving from LogListenerBase.
public class NLogListener : LogListenerBase { protected override void Debug(ILog log, string message, object extraData) { var finalLog = NLog.LogManager.GetLogger(log.TargetType.ToString()); finalLog.Debug(message); } protected override void Info(ILog log, string message, object extraData) { var finalLog = NLog.LogManager.GetLogger(log.TargetType.ToString()); finalLog.</description></item><item><title>NumericTextBox</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/numeric-textbox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/numeric-textbox/</guid><description>The NumericTextBox behavior makes it easy to allow specific numeric input on a TextBox.
1) Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; 2) Use the following definition:
&amp;lt;TextBox Text={Binding Amount}&amp;quot;&amp;gt; &amp;lt;i:Interaction.Behaviors&amp;gt; &amp;lt;catel:NumericTextBox /&amp;gt; &amp;lt;/i:Interaction.Behaviors&amp;gt; &amp;lt;/TextBox&amp;gt; Use the properties on the behavior to customize the behavior to your needs</description></item><item><title>OpenFileService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/open-file-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/open-file-service/</guid><description> The IOpenFileService allows a developer to let the user choose a file from inside a view model.
Opening a file To open a file, it is required to set the right properties of the service and then make a call to the DetermineFile method:
var dependencyResolver = this.GetDependencyResolver(); var openFileService = dependencyResolver.Resolve&amp;lt;IOpenFileService&amp;gt;(); openFileService.Filter = &amp;quot;All files|*.*&amp;quot;; if (openFileService.DetermineFile()) { // User selected a file }</description></item><item><title>PleaseWaitService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/please-wait-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/please-wait-service/</guid><description>The IPleaseWaitService allows a developer to show a please wait message (a.k.a. busy indicator) from a view model. Showing using Catel.IoC; var dependencyResolver = this.GetDependencyResolver(); var pleaseWaitService = dependencyResolver.Resolve&amp;lt;IPleaseWaitService&amp;gt;(); pleaseWaitService.Show(); Hiding var dependencyResolver = this.GetDependencyResolver(); var pleaseWaitService = dependencyResolver.Resolve&amp;lt;IPleaseWaitService&amp;gt;(); pleaseWaitService.Hide(); Showing and automatically hide The IPleaseWaitService can automatically hide itself when an action is completed. To use this feature, simply pass a delegate to the Show method and the service will hide the window as soon as the delegate has completed.</description></item><item><title>ProcessService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/process-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/process-service/</guid><description>The IProcessService allows a developer to run processes from inside a view model.
Starting a process with arguments To start a process with arguments, use the following code:
var dependencyResolver = this.GetDependencyResolver(); var processService = dependencyResolver.Resolve&amp;lt;IProcessService&amp;gt;(); processService.StartProcess(&amp;quot;notepad.exe&amp;quot;, @&amp;quot;C:\mytextfile.txt&amp;quot;); Starting a process with arguments and completed callback To start a process with arguments and receive a callback on completion, use the following code:
var dependencyResolver = this.GetDependencyResolver(); var processService = dependencyResolver.</description></item><item><title>Property bindings</title><link>https://docs.catelproject.com/vnext/catel-mvvm/bindings/property-bindings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/bindings/property-bindings/</guid><description>Property bindings are very important in the MVVM pattern. The binding system in Catel will automatically map properties when the binding system is used.
Binding properties one way To bind properties one way, use the code below.
Android protected override void AddBindings(BindingContext bindingContext, IViewModel viewModel) { var vm = (MainViewModel) viewModel; bindingContext.AddBinding(() =&amp;gt; vm.FirstName, () =&amp;gt; _firstNameEditText.Text, BindingMode.OneWay); } iOS iOS not yet documented Binding properties two way To bind properties two way, use the code below.</description></item><item><title>Property helper</title><link>https://docs.catelproject.com/vnext/catel-core/reflection/propertyhelper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/reflection/propertyhelper/</guid><description>The PropertyHelper class is a reflection-based helper class to get or set properties on classes. This class is used by Catel as a fall-back mechanism to use reflection in case cached expression trees are not supported.
For better performance, use the `FastMemberInvoker` instead Setting or getting properties of objects In lots of cases, you need to possibility to set or get properties of an object via reflection. This behavior is implemented in the PropertyHelper class.</description></item><item><title>Requery commands automatically using CommandManager</title><link>https://docs.catelproject.com/vnext/tips-tricks/mvvm/requery-commands-automatically/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/tips-tricks/mvvm/requery-commands-automatically/</guid><description>For performance reasons, Catel no longer automatically subscribes to the CommandManager to invalidate the state (saves a lot of CanExecute calls). If you want this behavior back, you can create a custom class that subscribes to the command manager and invalidates the commands for you.
This was removed for a reason (performance), so this is not the recommended approach. But this allows you to get back the old behavior. To use this class, instantiate it and register it in the ServiceLocator so it stays alive.</description></item><item><title>RollingInMemoryLogListener</title><link>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/rolling-in-memory-log-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/rolling-in-memory-log-listener/</guid><description>In memory logging can be very useful to be able to query the latest log messages. Catel provides this via the RollingInMemoryLogListener and RollingInMemoryLogService. The *RollingInMemoryLogService *is a wrapper around the *RollingInMemoryLogListener* to provide a simple way to use the listener.
Enabling the feature By default, the feature is disabled to not eat any CPU ticks when not being used. To use the feature, the only thing required is to resolve the type from the ServiceLocator:</description></item><item><title>Running code at design-time</title><link>https://docs.catelproject.com/vnext/catel-mvvm/designers/running-code-at-design-time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/designers/running-code-at-design-time/</guid><description>Sometimes one needs to run code during design-time. A good example is to register a custom LanguageResourceSource in the LanguageService to show translations in the designer. Unfortunately it is not as easy as putting some code in the code-behind to get this working.
Starting with Catel 4.3, calling `CatelEnvironment.IsInDesignTime` will automatically invoke *DesignTimeHelper.InitializeDesignTime* if in design mode. This means you only have to add classes deriving from `DesignTimeInitializer` and they will automatically be invoked when any code is checking if it&#39;s currently running inside a designer context (e.</description></item><item><title>SaveFileService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/save-file-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/save-file-service/</guid><description> The ISaveFileService allows a developer to let the user choose a file from inside a view model.
Choosing a file To select a file to save, it is required to set the right properties of the service and then make a call to the DetermineFile method:
var dependencyResolver = this.GetDependencyResolver(); var saveFileService = dependencyResolver.Resolve&amp;lt;ISaveFileService&amp;gt;(); saveFileService.Filter = &amp;quot;C# File|*.cs&amp;quot;; if (saveFileService.DetermineFile()) { // User selected a file }</description></item><item><title>SchedulerService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/scheduler-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/scheduler-service/</guid><description>The ISchedulerService allows a developer to schedule an action in the relative or absolute future. The SchedulerService will use the DispatcherTimer to invoke the action.
Note that the `SchedulerService` does not provide any persistence of actions and schedules. When the application is closed, all schedules are lost because they are kept in memory. Scheduling an action in the relative future To schedule an action in the relative future, use the Schedule method with the TimeSpan overload.</description></item><item><title>SelectDirectoryService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/select-directory-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/select-directory-service/</guid><description> The ISelectDirectoryService allows a developer to let the user choose a directory from inside a view model.
Selecting a directory To select a directory, it is required to set the right properties of the service and then make a call to the DetermineDirectory method:
var dependencyResolver = this.GetDependencyResolver(); var selectDirectoryService = dependencyResolver.Resolve&amp;lt;ISelectDirectoryService&amp;gt;(); if (selectDirectoryService.DetermineDirectory()) { // User selected a directory }</description></item><item><title>SelectTextOnFocus</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/select-text-on-focus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/select-text-on-focus/</guid><description>The SelectTextOnFocus behavior makes it easy to select all text when a TextBox receives the focus.
1) Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; 2) Use the following definition:
&amp;lt;TextBox Text={Binding Amount}&amp;quot;&amp;gt; &amp;lt;i:Interaction.Behaviors&amp;gt; &amp;lt;catel:SelectTextOnFocus /&amp;gt; &amp;lt;/i:Interaction.Behaviors&amp;gt; &amp;lt;/TextBox&amp;gt;</description></item><item><title>SeqLogListener</title><link>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/seq-log-listener/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/logging/log-listeners/seq-log-listener/</guid><description>Seq is a structured logs server for .NET Apps. It act like a logs repository, allow to diagnostic by query your logs using a natural syntax, react on notifying you through email or instant messages and so on &amp;hellip;
To use the Seq log listener, use the following code:
var logListener = new SeqLogListener(); logListener.IgnoreCatelLogging = true; // TODO: Customize options LogManager.AddListener(logListener); This one can also be used on configuration file:</description></item><item><title>Thread safe code</title><link>https://docs.catelproject.com/vnext/catel-core/parallel-invocation-tasks/thread-safe-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/parallel-invocation-tasks/thread-safe-code/</guid><description>Writing a multiple threading application is always a challenge. Eventually you need use objects or statements with the ability to synchronize access to the critical sections of the code by taking and releasing a lock.
Background information The common solution to access the thread-sensitive resources is use the lock statement just as follow:
private readonly object _syncObj = new object(); public void DoTheWork() { lock (_syncObj) { // Access to the thread-sensitive resources here.</description></item><item><title>Type cache</title><link>https://docs.catelproject.com/vnext/catel-core/reflection/typecache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/reflection/typecache/</guid><description>The TypeCache is the centralized cache by Catel for type information. It should be used by any class to gather type information since most of the calls are being cached by Catel.
Getting types without versioning Sometimes you know what type to get and what assembly it is living in. However, you don&amp;rsquo;t want to be version-dependent by specifying the fully qualified assembly name. By using the TypeCache.GetType method, it is possible to get a type by only the assembly name (e.</description></item><item><title>UIVisualizerService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/ui-visualizer-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/ui-visualizer-service/</guid><description>The IUIVisualizerService allows a developer to show (modal) windows or dialogs without actually referencing a specific view. Internally, the UIVisualizerService uses the ViewLocator to resolve views.
Screenshot Showing a non-modal window To show a non-modal window, use the following code:
var viewModel = new EmployeeViewModel(); var dependencyResolver = this.GetDependencyResolver(); var uiVisualizerService = dependencyResolver.Resolve&amp;lt;IUIVisualizerService&amp;gt;(); uiVisualizerService.Show(viewModel); Showing a modal window To show a modal window, use the following code:
var viewModel = new EmployeeViewModel(); var dependencyResolver = this.</description></item><item><title>UpdateBindingOnPasswordChanged</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/update-binding-on-password-changed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/update-binding-on-password-changed/</guid><description>The UpdateBindingOnPasswordChanged is a very useful behavior which allows to bind the Password property of the PasswordBox Control. Use it, it&amp;rsquo;s really simple.
 1) Add the following XML namespaces:
xmlns:i=&amp;quot;clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity&amp;quot; xmlns:catel=&amp;quot;http://schemas.catelproject.com&amp;quot; 2) Use the following definition:
&amp;lt;PasswordBox&amp;gt; &amp;lt;i:Interaction.Behaviors&amp;gt; &amp;lt;catel:UpdateBindingOnPasswordChanged Password=&amp;quot;{Binding Password, Mode=TwoWay}&amp;quot; /&amp;gt; &amp;lt;/i:Interaction.Behaviors&amp;gt; &amp;lt;/PasswordBox&amp;gt;</description></item><item><title>UpdateBindingOnTextChanged</title><link>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/update-binding-on-text-changed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/behaviors-triggers/update-binding-on-text-changed/</guid><description>The UpdateBindingOnTextChange is a very useful behavior which allows to delay a binding update on the TextChanged event of a TextBox. This way, it is possible to implement search boxes that only start a search after a specific time when no new key presses have occurred. For example, when a user types a new search string, and the user doesn&amp;rsquo;t enter a new key for 500 ms, the binding is updated.</description></item><item><title>UrlLocator</title><link>https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/url-locator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/url-locator/</guid><description>The IUrlLocator class is responsible for resolving the right urls for the xaml views for a view model in navigation based applications. Before Catel 3.0, the INavigationService was responsible for resolving the url, but this responsibility is now taken over by the IUrlLocator. The NavigationService internally uses the IUrlLocator to resolve the views.
Resolving by naming convention It is possible to resolve views using the IUrlLocator. Then you can use the ResolveUrl method to resolve the url based on the type of the view model.</description></item><item><title>UserControl</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/usercontrol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/usercontrol/</guid><description>The UserControl is a very interesting class of Catel, and fully shows the power of the MVVM Framework that ships with Catel. The user control is able to fully integrate MVVM on a user control level and solves the “nested user control” problem, which is explained in detail a bit further in this documentation.
Automatic construction without parameter It simplest thing to do is to create a view model that has an empty constructor (thus without parameters).</description></item><item><title>UserControl - under the hood</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/advanced/usercontrol-under-the-hood/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/advanced/usercontrol-under-the-hood/</guid><description>The UserControl is a pretty sophisticated class. In this part of the documentation, the inner workings of the control are explained. What better way is there than to using flowcharts. There are a few events very important for the inner workings of the user control. The flowcharts are created per event.
Keep in mind that the actual logic is implemented in the `UserControlLogic`, which is used by the `UserControl`.</description></item><item><title>UserControl Resources</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/usercontrol-resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/usercontrol-resources/</guid><description>For the most part the resources declared within a Catel UserControl behave the exact same as resources defined in the standard UserControl. However because of the way the Catel UserControl operates (see UserControl Under the hood) any bindings performed inside a Resource will not be found at runtime (example CollectionViewSource Source) . The solution is to declare the resource inside an element within the UserControl, not at the UserControl level. Example below:</description></item><item><title>Using a custom control</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/external-controls/using-custom-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/external-controls/using-custom-control/</guid><description>In this part of the documentation, the RadTabItem of Telerik will be used as an example on how to create a RadTabItem that behaves like the UserControl.
Creating the base class with behavior The first thing to do is to create a new base class that accepts a view model type argument. In this example, we will call it TabItem (to make it as &amp;ldquo;external control company independent&amp;rdquo; as possible).</description></item><item><title>Using a custom window</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/external-controls/using-custom-window/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/external-controls/using-custom-window/</guid><description>In this part of the documentation, the RadWindow of Telerik will be used as an example on how to create a WindowBase that behaves like the DataWindow.
Creating the base class with behavior The first thing to do is to create a new base class that accepts a view model type argument. In this example, we will call it WindowBase (to make it as &amp;ldquo;external control company independent&amp;rdquo; as possible).</description></item><item><title>Using a tabbed interface with MVVM</title><link>https://docs.catelproject.com/vnext/tips-tricks/mvvm/using-tabbed-interface-with-mvvm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/tips-tricks/mvvm/using-tabbed-interface-with-mvvm/</guid><description>A common scenario in WPF is to use a tabbed interface to give the user the option to use multiple main views in a tabbed environment. This example shows how to implement this correctly with both closable and non-closable tabs.
For this example, we will have a few requirements:
Be able to add, close and activate tabs via a service Be able to specify whether a tab can be closed by the end-user Creating the model describing a tab item First of all, we need a model describing a tab item so we can interact with a service.</description></item><item><title>Using compiled bindings</title><link>https://docs.catelproject.com/vnext/tips-tricks/mvvm/using-compiled-bindings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/tips-tricks/mvvm/using-compiled-bindings/</guid><description>A common scenario in UWP is to use x:Bind instead of Binding. This requires knowledge about the actual type of the view model.
There are 2 options to support this.
Use the VM property Catel by default exposes the ViewModel property as IViewModel. However, there is a reserved VM property you can use that is typed:
public sealed partial class BikeSummaryView { public BikeSummaryView() { InitializeComponent(); } internal BikeSummaryViewModel VM { get { return ViewModel as BikeSummaryViewModel; } } } Since this is a reserved keyword, Catel will automatically take care of the change notifications and x:Bind can be used directly against VM:</description></item><item><title>Validation controls</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/validation-controls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/validation-controls/</guid><description>There are some very important controls in Catel which help with visualizing the validation results.
InfoBarMessageControl Ever wanted to show the details of error messages to your end-users? Then, the InfoBarMessageControl is the control to use! The control shows a summary of all business and field errors provided by bindings on objects that implement the IDataErrorInfo interface.
In combination with the WarningAndErrorValidator control, the InfoBarMessageControl can even show field and business warnings for objects that implement the IDataWarningInfo interface that ships with Catel.</description></item><item><title>Validation in view models</title><link>https://docs.catelproject.com/vnext/catel-mvvm/view-models/validation-in-view-models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/view-models/validation-in-view-models/</guid><description>Validation is very important to provide both feedback to the user, but also to make sure that no invalid data reaches the model or database. Catel offers several ways to implement validation. All options are described in this part of the documentation.
Validation in models via mappings The best way is to put validation into a model. Most model objects nowadays implement INotifyPropertyChanged and IDataErrorInfo, the most important classes that are required to use mappings from/to a model inside a view model.</description></item><item><title>VibrateService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/vibrate-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/vibrate-service/</guid><description>The IVibrateService allows a developer to start and stop vibration of the device via a service.
Starting vibration To start the vibration, use the following code (will vibrate for 250 ms). Note that the time span must be between 0 and 5 seconds.
var dependencyResolver = this.GetDependencyResolver(); var vibrateService = dependencyResolver.Resolve&amp;lt;IVibrateService&amp;gt;(); vibrateService.Start(new TimeSpan(0, 0, 0, 0, 250); Stopping the vibration earlier than initially planned By default, the vibration stops automatically after the specified time span has passed.</description></item><item><title>ViewExportService</title><link>https://docs.catelproject.com/vnext/catel-mvvm/services/view-export-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/services/view-export-service/</guid><description> The IViewExportService allows a developer to export a specific view that belongs to a view model to the clipboard, a file or a printer.
Exporting a view To export a view, use the following code:
var dependencyResolver = this.GetDependencyResolver(); var viewExportService = dependencyResolver.Resolve&amp;lt;IViewExportService&amp;gt;(); viewExportService.Export(myViewModel, ExportMode.File);</description></item><item><title>ViewLocator</title><link>https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/view-locator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/view-locator/</guid><description>The IViewLocator class is responsible for resolving the right views for a view model. Before Catel 3.0, the IUIVisualizerService was responsible for resolving the view, but this responsibility is now taken over by the IViewLocator. The UIVisualizerService internally uses the IViewLocator to resolve the views. Resolving by naming convention It is possible to resolve views using the IViewLocator. Then you can use the ResolveView method to resolve the view based on the type of the view model.</description></item><item><title>ViewModelLocator</title><link>https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/view-model-locator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/locators-naming-conventions/view-model-locator/</guid><description>Starting with Catel 3.0, there are several ways to hook up a view model to the view. When a view is constructed, an MVVM behavior is added to the view. Thanks to these MVVM behaviors, it is possible to use exactly the same logic on 3rd party controls.
Note that the while using the conventions, magic words such as &#34;View&#34;, &#34;Control&#34;, &#34;UserControl&#34;, &#34;Window&#34; and &#34;Page&#34; will be stripped from the view name while locating the view model type Resolving by naming convention If the GetViewModelType method returns null (which is the default behavior), the view will resolve the IViewModelLocator from the ServiceLocator.</description></item><item><title>Weak events</title><link>https://docs.catelproject.com/vnext/catel-core/preventing-memory-leaks/weak-events/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/preventing-memory-leaks/weak-events/</guid><description>You have probably heard about weak events before. This documentation is not about the issue of the cause of weak events, there are lots of articles about that. This documentation writes about the solution, which is the WeakEventListener. Shortly said, when you do this in every class (just for the sake of explaining the problem, don’t start thinking this code has no business value):
var log = Log.Instance; log.LogReceived += OnLogReceived; As you can see, the log is a singleton, so there is only one living instance of the Log class.</description></item><item><title>Window and DataWindow</title><link>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/window-and-datawindow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-mvvm/views/xaml/window-and-datawindow/</guid><description>Introduction to the Window The Window is a simplified class representing the same logic as the regular System.Windows.Window but with the binding support of Catel.
Introduction to the DataWindow When developing software in XAML, most developers always need the following three types of windows:
OK / Cancel buttons for data windows; OK / Cancel / Apply buttons for application settings / options; Close button on windows for action windows.</description></item><item><title>Xml</title><link>https://docs.catelproject.com/vnext/catel-core/serialization/supported-serializers/xml/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://docs.catelproject.com/vnext/catel-core/serialization/supported-serializers/xml/</guid><description>The xml serializer uses the DataContractSerializer from .NET to serialize the object graphs.</description></item></channel></rss>